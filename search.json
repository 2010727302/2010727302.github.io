[{"title":"IAS","url":"/2025/01/27/IAS/","content":"# Optimally Integrating Ad Auction into E-Commerce Platforms\nIAS（Integrated Ad System）模型即集成广告系统模型，用于描述电商平台上广告与有机搜索结果混合排列的情况。该模型的目标函数和约束条件设计紧密围绕电商平台关注的核心指标，旨在平衡广告收入与用户体验。\n1. **目标函数**\n    - **收入（Revenue）**：$Revenue =\\int_{V} \\sum_{i \\in A} p_{i}(v) w_{i} x_{i}(v) f(v) dv$，此公式表示收入是对所有广告商品的支付价格、质量因子、分配情况以及概率分布进行积分求和。其中，$p_{i}(v)$是广告商品$i$的支付价格，$w_{i}$为其质量因子，$x_{i}(v)$代表分配规则，$f(v)$是概率分布函数。通过这一函数计算，反映出平台从广告投放中获取的即时收入 。\n    - **商品交易总量（GMV）**：$GMV=\\int_{V}\\left[\\sum_{i \\in A} g_{i} w_{i} x_{i}(v)+\\sum_{i \\in O} g_{i} w_{i} x_{i}(v)\\right] f(v) dv$，该公式计算的是平台的商品交易总量，考虑了广告商品和有机商品的预估交易量、质量因子和分配情况。其中，$g_{i}$为商品$i$的预估交易量，对广告商品和有机商品分别求和再积分，体现了平台业务的整体交易规模，是衡量用户体验和平台长期收益的重要指标。\n    - **无约束问题（Unconstrained Problem）**：$UCST (\\alpha)$给定加权系数$\\alpha \\in[0,1]$，通过线性凸组合收入和GMV来构建目标函数，即$max _{x \\in \\mathcal{X}} \\alpha \\cdot Revenue +(1-\\alpha) \\cdot GMV$。该目标函数旨在在不同权重下，同时考虑收入和GMV，寻找能使两者综合效益最大化的机制。例如，当$\\alpha$接近1时，更注重收入；当$\\alpha$接近0时，则更倾向于GMV。 \n    Unconstrained Problem $UCST (\\alpha)$ ) Given the weighted coefficient $\\alpha \\in[0,1]$ ,the unconstrained problem $UCST (\\alpha)$ ) can be written as \n $max _{x \\in \\mathcal{X}} \\alpha \\cdot Revenue +(1-\\alpha) \\cdot Volume. (4)$\n    - **约束问题（Constrained Problem）**：$CST(V_{0})$给定GMV阈值$V_{0}$，以优化收入为目标，即$max Revenue$，同时需满足$GMV \\geq V_{0}$和$x \\in \\mathcal{X}$的约束。此目标函数强调在保证一定GMV水平的前提下，最大化广告收入，体现了平台在平衡用户体验和短期收益时的考量。\n    Constrained Problem $CST(V_{0})$ ) Given a threshold $V_{0}$ , the constrained problem $CST(V_{0})$ ) can be written as \n $$max Revenue \\quad (P1)$$ \n $$s.t. Volume \\geq V_{0} \\quad(C 1.1)$$ \n $$x \\in \\mathcal{X} \\quad(C 1.2)$$\n2. **约束条件**\n    - **分配规则约束**：对于分配规则$x_{ik}(b)$需满足$\\sum_{k} x_{ik}(b) \\leq 1, \\forall i \\in A \\cup O$，确保每个商品最多被分配到一个展示位；$\\sum_{i \\in A} x_{ik}(b)+\\sum_{i \\in O} x_{ik}(b)=1, \\forall k$，保证每个展示位都有且仅有一个商品；$x_{ik}(b) \\in\\{0,1\\}, \\forall i, k$，表示商品是否被分配到展示位只能是0或1的二元选择。这些约束保证了分配的合理性和唯一性 。\n    - **个体理性（Individual Rationality）**：$U_{i}(x, p, b_{i}) \\geq 0, \\forall b_{i} \\in[0, u_{i}], \\forall i \\in A$，此约束确保广告商参与拍卖的期望效用非负，即广告商在平台的广告投放行为能获得至少为零的收益，这是吸引广告商参与的基本条件。\n    - **贝叶斯激励兼容（Bayesian Incentive Compatibility）**：$U_{i}(x, p, v_{i}) \\geq U_{i}(x, p, b_{i}), \\forall b_{i} \\in[0, u_{i}], \\forall i \\in A$，该约束保证广告商如实报告自身价值是最优策略，避免广告商虚假报价，维护拍卖机制的公平性和有效性。 \n\n## 无约束问题$UCST(\\alpha)$\n\n   - **目标函数**：$max _{x \\in \\mathcal{X}} \\alpha \\cdot Revenue+(1 - \\alpha)\\cdot GMV(4)$。这里的$\\alpha\\in[0,1]$是加权系数，用于平衡对收入和GMV的侧重程度。\n   转化为**引理 2**:要最大化目标函数 （4），机制需要最大化目标\n $$\\int_{V} \\sum_{i \\in I}\\left(\\alpha \\phi_{i}\\left(v_{i}\\right)+(1-\\alpha) g_{i}\\right) w_{i} x_{i}(v) f(v) d v-\\alpha \\sum_{i \\in I} U_{i}(x, p, 0) . (5)$$\n   - **修正虚拟价值排序**：机制$M$涉及到定义修正虚拟价值$\\psi_{i}(v_{i})=(\\alpha \\phi_{i}(v_{i})+(1 - \\alpha)g_{i})w_{i}=(1 - \\alpha)g_{i}w_{i}$。其中$\\phi_{i}(v_{i})$是广告商品$i$的虚拟价值，$g_{i}$是商品$i$的预估交易量，$w_{i}$是商品$i$的质量因子。按照这个修正虚拟价值对所有商品（包括广告商品和有机商品）进行排序。\n   - **定价规则**(迈尔森)：有机商品的支付为0，广告商品的支付价格是根据其在排序中的位置和相关价值计算得出的，以保证个体理性（广告商参与拍卖的期望效用非负）和贝叶斯激励兼容（广告商如实报告自身价值是最优策略）。\n   给定分配规则和支付规则，广告项目 i 的出价为$b_{i}$时的预期效用可以表示为：$$U_{i}\\left(x, p, b_{i}\\right)=\\int_{V_{-i}}\\left(v_{i}-p_{i}\\left(b_{i}, v_{-i}\\right)\\right) w_{i} x_{i}\\left(b_{i}, v_{-i}\\right) f_{-i}\\left(v_{-i}\\right) d v_{-i}$$\n   因为$p(b)$只出现在$U_{i}(x,p,0)$中，并且我们需要保证（IR）的性质，根据引理 1，如果我们选择$p_{i}(v)=v_{i}-\\frac{\\int_{0}^{v_{i}} x_{i}(s_{i},v_{-i})ds_{i}}{x_{i}(v)}$作为支付规则，那么$U_{i}(x,p,0)$将为 0，并且我们只需要考虑选择合适的$x(b)$来最大化式（5）的第一部分。\n   - **分配规则**：将广告商品插入有机商品序列进行分配。对于分配规则$x_{ik}(b)$，要满足$\\sum_{k}x_{ik}(b)\\leq1,\\forall i\\in A\\cup O$（每个商品最多被分配到一个展示位）、$\\sum_{i\\in A}x_{ik}(b)+\\sum_{i\\in O}x_{ik}(b) = 1,\\forall k$（每个展示位都有且仅有一个商品）和$x_{ik}(b)\\in\\{0,1\\},\\forall i,k$（商品是否被分配到展示位是二元选择）等条件。\n   对于分配规则，我们将 $\\psi_{i}(v_{i}) \\stackrel{ def }{=}(\\alpha \\phi_{i}(v_{i})+(1-\\alpha) g_{i}) w_{i}$ 定义为物品 $i$ 的修正虚拟价值。不难验证，以下分配规则可以最大化公式（5）的第一部分。\n$x_{i k}(v)= \\begin{cases}1 & 如果\\psi_{i}\\left(v_{i}\\right)是第 k 高的修正虚拟价值，k\\in\\{1,2,\\ldots,K\\}。\\\\0&否则。\\end{cases}$\n## 约束问题$CST(V_{0})$ -商业化率约束\n可通过对偶转为无约束问题\n- **放宽约束条件**：由于可行域是离散的，即$x_{i k}(v)$不是关于出价$v$的连续函数，因此很难直接优化目标。我们首先将约束$x_{i k}(v)∈\\{0,1\\}$在（C1.2）中放宽为$x_{i k}(v)∈[0,1]$，并将放宽后的可行域记为$\\bar{x}$。放宽后的约束问题为：\n最大化$$R(x)\\stackrel{ def }{=}\\int_{V}\\sum_{i\\in I}w_{i}p_{i}(v)x_{i}(v)f(v)dv（P2）$$\n约束条件为$$V(x)\\stackrel{ def }{=}\\int_{V}\\sum_{i\\in I}g_{i}w_{i}x_{i}(v)f(v)dv\\geq V_{0}（C2.1）$$\n$$x\\in\\overline{\\mathcal{X}}（C2.2）$$\n- **对偶问题**：对于可访问的$V_{o}$，强对偶性成立意味着\n$$\\begin{aligned}&\\underbrace{\\max_{x:x\\in\\mathcal{X},V(x)\\geq V_{0}}R(x)}_{\\text{原始问题}}=\\underbrace{\\min_{\\lambda\\geq0}\\max_{x\\in\\mathcal{X}}\\left(R(x)+\\lambda\\left(V(x)-V_{0}\\right)\\right)}_{\\text{对偶问题}}\\\\&=\\min_{\\lambda\\geq0}\\max_{x\\in\\mathcal{X}}\\left[\\int_{V}\\sum_{i\\in I}\\left(p_{i}\\left(b_{i}\\right)+\\lambda g_{i}\\right)w_{i}x_{i}(b)f(b)db-\\lambda V_{0}\\right]。\\end{aligned}$$\n- **分配规则**：当给定一个$\\lambda$时，它是一个具有松弛可行域$\\bar{x}$的无约束问题。由于$\\bar{x}$的系数矩阵是完全单模矩阵([22])，内部问题的最优解是整数形式，即 0-1 形式。因此，内部问题的最优解可以通过机制 M 以$\\alpha = 1/(\\lambda + 1)$获得，即\n$$ x_{i k}^{\\lambda}(v)=\\begin{cases}1&\\text{如果}\\psi_{i}^{\\lambda}\\left(v_{i}\\right)\\text{是第}k\\text{高的，}k\\in\\{1,2,\\ldots,K\\},\\\\0&\\text{否则，}\\end{cases}$$\n其中$\\psi_{i}^{\\lambda}(v_{i})\\stackrel{def}{=}[(\\phi_{i}(v_{i})+\\lambda g_{i})w_{i}]/(\\lambda + 1)$。\n- **定价规则**：$p_{i}^{\\lambda}(v)$可以通过在(7)中将$x_{i k}(v)$替换为$x_{i k}^{\\lambda}(v)$得到。\n- **$\\lambda$计算**：二分\n![alt text](./images/lambda.png)\n- **定理 2**：具有阈值$V_0$的约束问题等价于一个具有系数$\\alpha^{*}$的无约束问题，其中$\\alpha^{*}=1/(\\lambda^{*}+1)$，并且$\\lambda^{*}$是约束问题中的最优拉格朗日乘子。\n## 广告数量约束\n\n\n1. **问题设定**：在集成广告系统中引入对广告商品总数的限制，要求广告商品数量不超过 $c$ ，即 $\\sum_{i \\in A} \\sum_{k} x_{ik}(v) \\leq c$，将此约束加入原有的约束条件集 $x$ 后得到新的可行域 $x'$。\n2. **无约束问题的最优机制**：基于此前无约束问题的结论，商品按修正虚拟价值 $\\psi_{i}(v_{i})$ 排序。在新约束下，为保证广告商品数量符合预算，在排序时仅考虑排名前 $c$ 的广告商品。由此得到扩展机制 $M'(c)$，具体步骤为：\n    - 将所有广告商品按 $\\psi_{i}(v_{i})$ 降序排列，保留前 $c$ 个广告商品，删除其余广告商品；\n    - 针对剩余的广告商品和所有有机商品，运行系数为 $\\alpha$ 的原无约束问题机制 $M$。\n    - 由于原机制 $M$ 的最优性以及对广告商品数量的有效控制，$M'(c)$ 是当前设定下无约束问题的最优机制。\n3. **约束问题的求解**：对于约束问题，其求解逻辑与前文类似，但由于新可行域 $x'$ 的系数矩阵不再是全幺模矩阵，导致求解难度增加。通过将其转化为最小费用最大流问题（证明见附录 Lemma 6），可证明松弛问题仍具有0 - 1形式的最优解。基于此，约束问题仍能通过选择合适参数转化为无约束问题求解，从而将此前针对无约束和约束问题关系的结论（Theorem 2）扩展到存在广告数量预算约束的场景。 \n## 广告间隔约束\n用广告数量约束的机制，分别运行局部的无约束问题\n### PC端\n   \n- **页面划分**：当我们在电子商务平台上通过个人电脑搜索产品时，搜索结果通常显示为几行，每行包含几个项目。受这种布局的启发，我们希望限制每行中的广告数量以让用户感到舒适。鉴于此，我们将一个搜索结果页面分成多行，每行包含连续的 l 个槽位。然后，我们要求在这 l 个槽位中显示的广告项目最多为 c 个。我们将这个模型称为稀疏集成广告系统——行（SIASR）。\n- **约束条件**：$$\\sum_{i \\in A} \\sum_{k = ml + 1}^{(m + 1)l} x_{ik}(v)≤c，m = 0,1,\\ldots,|K/l|$$\n$$\\sum_{i \\in A} \\sum_{k=\\lfloor K / l] l+1}^{K} x_{i k}(v) ≤c$$。将它们添加到$x$中并表示新的约束条件。\n- **无约束问题的最优机制**：基于上述分析，我们可以对每个部分运行机制\\(M'(c)\\)来为稀疏集成广告系统（SIASR）生成一个可行的广告排列方案。这是因为机制\\(M'(c)\\)本身具有最优性，所以每个部分都能实现最优的广告商品分配，进而使得整个页面所有展示位都能达到全局最优的分配效果。由此，我们得到了在这种设定下的最优机制，记为\\(\\tilde{M}(c, l)\\)。\n\n   - **第一步**：运行机制\\(M'(c)\\)，对所有商品（包括广告商品和自然商品）分配前\\(l\\)个展示位。机制\\(M'(c)\\)会根据商品的相关价值对商品进行排序，并依据广告商品数量预算\\(c\\)，从所有商品中选择合适的商品分配到这\\(l\\)个展示位上。\n   - **第二步**：运行机制\\(M'(c)\\)，对剩余的所有商品分配接下来的\\(l\\)个展示位。在完成第一步分配后，剩余商品的集合发生了变化，再次运行机制\\(M'(c)\\)，从这些剩余商品中选择合适的商品填充接下来的\\(l\\)个展示位。\n   - **第三步**：重复第二步，直到所有展示位都分配完毕。需要注意的是，在最后一轮分配时，展示位的数量可能会小于\\(l\\)。这是因为前面按照每\\(l\\)个展示位一轮进行分配，到最后可能会剩下不足\\(l\\)个展示位，此时依然按照机制\\(M'(c)\\)对剩余商品进行分配，以完成整个搜索结果页面的广告与自然商品的分配。\n- **约束问题**：我们通过引理 7（在附录中显示）克服了这个问题。到目前为止，我们解决了 SIASR 的受约束问题，并将定理 2 扩展到了这种情况。\n引理 7.对于 SIASR，约束问题的松弛内问题可以构造为最小费用最大流问题，并且具有 0-1 形式的最优解。\n### 移动端\n- **页面划分**：一般来说，输入一个关键字后，搜索结果在一列中显示（与个人电脑终端的布局不同）。如果我们仍然想限制广告的稀疏性，我们需要在任何连续的 l 个位置上添加约束，即任何连续的 l 个位置上最多显示 c 个广告项。\n\n- **约束条件**：$\\sum_{i∈A}\\sum_{k = m + 1}^{m + l}x_{ik}(v)\\leq c$，$m = 0,1,\\ldots,K - l$，并将新的可行区域表示为$\\hat{x}$。我们将这个模型称为稀疏集成广告系统——列（SIASC）。\n- **无约束问题的最优机制**：\n\n\n1. 运行机制$M'(c)$以在所有物品上分配前$l$个时段。\n2. 运行机制$M'(c - a)$，为所有剩余物品分配下一个时段，其中$a$是最后$l - 1$个时段中的广告物品数量。\n3. 重复步骤 2，直到所有槽位都被分配。\n- **约束问题**：对于约束问题，我们可以将 SIASR 中使用的方法扩展到这种设置。唯一的区别是，在这种设置下，连续的 l 个槽有更多的约束。然而，最终它并不影响难度。我们只需要稍微修改一下图 6 的结构：添加一定数量的节点$k_{i}$来代表更多的组，并连接弧$s_{j}^{\\prime\\prime}k_{i}$，其中$j\\in\\{i,i + 1,\\cdots,i + l - 1\\}$，以及弧$k_{i}t$。其他分析是相似的。这样，我们将定理 2 推广到 SIASC 的情况。","tags":["paper","混排"],"categories":["research"]},{"title":"混排","url":"/2025/01/04/mixed-ranking/","content":"# NMA: Neural Multi-slot Auctions with Externalities for Online Advertising\n- **研究背景**：在线广告是众多互联网平台的主要收入来源，拍卖机制的设计对平台、用户和广告商至关重要。广义第二价格（GSP）拍卖是常见机制，但存在用户点击假设与实际不符等问题。如在美团外卖平台，广告展示受多种因素影响，而GSP未考虑这些外部性。Deep Neural Auctions（DNA）虽有改进，但仍有局限，VCG及其变体WVCG在理论上可处理外部性，但在实践中面临收入下降或参数求解复杂等问题。\n- **研究目的**：提出一种新的神经多槽拍卖机制（NMA），有效建模全局外部性，平衡平台收入和社会福利，同时解决现有机制的问题。\n- **方法与模型**\n    - **模型结构**\n        - **上下文感知列表式预测模块（CLPM）**：采用参数共享结构，输入广告列表及相关公共信息，通过嵌入层、自注意力单元和目标注意力单元处理，输出列表式pCTR。还提出基于广告真实反馈的辅助损失，使模型能有效建模全局外部性，提高预测准确性。\n        - **列表式深度排名模块（LDRM）**：结合拍卖机制与深度学习，设计μ-Net子网络计算广告列表排名分数，确定支付规则，保证激励兼容性（IC）和个体理性（IR），实现端到端优化，提高排名公式表达能力。\n        - **列表式可微排序模块（LDSM）**：将排序操作从不可微转换为可微，通过定义排序算子和放松argmax操作，输出行随机置换矩阵表示选择概率，使复杂拍卖机制能端到端训练，解决LDRM在分配和支付处理上与深度学习不适应的问题。\n        - **社会福利最大化辅助损失**：基于广告列表社会福利定义，构建辅助损失，加速学习过程，减少社会福利下降，通过调整参数平衡NMA性能，确保满足社会福利约束。\n    - **实验设计**\n        - **数据集**：使用公共数据集Avito和工业数据集Meituan进行离线实验，将数据集按时间或比例划分为训练集和测试集。\n        - **评估指标**：包括点击率（CTR）、每千次展示收入（RPM）、每千次展示社会福利（SWPM）和社会福利最大化比率（SWMR），同时评估机制的IC属性。\n        - **对比方法**：与GSP、DNA、VCG和WVCG等代表性拍卖机制对比。\n- **实验结果**\n    - **离线实验**\n        - **性能比较**：NMA在两个数据集上的RPM、SWPM和CTR指标上优于DNA和GSP，能有效建模全局外部性；与VCG相比，NMA在广告收入和社会福利间平衡更好；在RPM指标上明显优于WVCG，验证了NMA的强大表达和学习能力。NMA的IC-R值与VCG相当且优于GFP，满足IC约束。\n        - **模块消融研究**：去除CLPM、LDRM - LDSM或社会福利最大化辅助损失后的NMA变体性能均下降，证明各模块对NMA性能提升有重要作用，CLPM能有效建模全局外部性，辅助损失有助于平衡广告收入和社会福利。\n        - **超参数分析**：α₁增大时，SWPM增加但RPM下降，α₂在一定范围内增加可提升性能，过大则导致性能下降，说明辅助损失可帮助平衡收入和福利，且CLPM辅助损失权重需合理设置。\n    - **在线A/B测试**：在美团外卖平台进行为期一个月的在线A/B测试，NMA相比GSP在CTR、RPM和SWPM上分别有显著提升，证明NMA在实际应用中可实现更高平台收入和社会福利，尽管在线测试与离线实验结果在绝对值上存在差异，但趋势一致。\n- **研究结论**：NMA有效建模全局外部性，通过设计的模块和辅助损失平衡平台收入和社会福利，在离线和在线实验中表现优异，已部署于美团外卖平台。未来可进一步优化，如采用列表生成模块替代全排列算法，提高工作效率。\n### 摘要\n在线广告拍卖为社交网络服务和电子商务平台带来了数十亿美元的收入。对于广告商来说简单易懂的广义第二价格（GSP）拍卖，几乎已成为行业中广告拍卖机制的基准。然而，大多数基于GSP的行业实践都假定用户点击仅依赖于广告本身，而忽略了外部项目的影响，即外部性。最近，深度神经网络拍卖（DNA）尝试用深度神经网络升级GSP，并在一定程度上对局部外部性进行建模。然而，它仅考虑了拍卖中的集合级上下文，而忽略了广告的顺序和展示位置，这仍然不是最优的。尽管基于维克里 - 克拉克 - 格罗夫斯（VCG）的多槽拍卖（如VCG、加权VCG（WVCG））使得对全局外部性（如广告的顺序和位置等）进行建模在理论上成为可能，但它们缺乏对收入和社会福利的有效平衡。\n\n在本文中，我们提出了名为神经多槽拍卖（NMA）的新型拍卖机制，以应对上述挑战。具体而言，我们使用上下文感知列表式预测模块对全局外部性进行有效建模，以实现更好的性能。我们设计了一个列表式深度排名模块，以保证端到端学习中的激励兼容性。此外，我们提出了一个社会福利辅助损失，以在最大化收入的同时有效地减少社会福利的下降。在离线大规模数据集和在线A/B测试中的实验结果表明，NMA在工业实践中比其他现有拍卖机制（即GSP、DNA、WVCG）获得了更高的收入，同时平衡了社会福利，并且我们已成功将NMA部署在美团外卖平台上。\n# [Contextual Generative Auction with Permutation-level Externalities for Online Advertising](https://mp.weixin.qq.com/s/bXtJuava8XhjybrlTHAcCA)\n\n1. **研究背景**\n    - **在线广告的重要性与拍卖机制**：在线广告是互联网行业的核心收入来源，广告拍卖在确保平台收入和激励广告商方面起着关键作用。传统拍卖机制如GSP存在局限性，其独立CTR假设忽略了其他展示广告的影响，即外部性。\n    - **学习型拍卖的进展与局限**：学习型拍卖如Deep Neural Auction（DNA）和Score Weighted VCG（SW-VCG）虽能更好地捕捉外部性，但受“分配后预测”设计范式限制，仅考虑候选广告集内的外部性（集合级外部性），未考虑最终分配中影响每个广告CTR的顺序上下文（排列级外部性），导致分配非最优。\n2. **方法设计**\n    - **理论基础与问题建模**\n        - 多槽拍卖与排列级外部性：将在线广告拍卖抽象为多槽拍卖问题，考虑广告商出价、广告特征、用户特征等因素，定义分配规则和支付规则。引入排列级外部性，即广告的CTR受其他展示广告影响，且不同排列会导致外部影响的差异。\n        - 最优多槽拍卖：基于Myerson拍卖理论，推导适应排列级外部性的最优拍卖机制，证明在满足一定条件下，该机制能最大化平台预期收入并满足激励兼容性（IC）和个体理性（IR）约束。\n        - 拍卖设计为学习问题：由于直接实现最优分配规则计算复杂，将拍卖机制参数化，通过学习确定参数。引入事后遗憾（ex-post regret）概念，以量化广告商偏离IC条件的程度，将拍卖设计问题转化为最小化预期负收入并满足事后遗憾为零的约束优化问题。\n    - **CGA框架设计**\n        - **生成器（Generator）**：采用自回归生成模块，包括排列不变集级编码器和排列等变自回归解码器。编码器通过自注意力层和求和池化增强广告表示，解码器基于上下文嵌入学习条件概率，以生成最大化预期虚拟福利的广告序列。\n        - **评估器（Evaluator）**：预测每个广告的排列感知CTR，通过对广告序列嵌入进行双向LSTM和多头自注意力编码，结合预测阶段的逐点CTR，估计个性化外部性感知校准向量，与逐点CTR元素相乘得到排列感知CTR。\n        - **支付计算（Payment Computation）**：受神经网络在多物品拍卖中有效近似最优机制的启发，引入PaymentNet学习最优支付规则。PaymentNet的输入包括分配嵌入、自排除出价配置文件和预期价值配置文件，通过sigmoidal激活函数计算支付率，以满足IR约束并输出支付。\n    - **优化与训练**\n        - G-E框架优化：先训练Evaluator至收敛，然后冻结其参数，使用Evaluator估计的排列感知奖励通过策略梯度训练Generator，以最大化虚拟福利。\n        - PaymentNet优化：在Generator和Evaluator收敛后，冻结它们的参数，应用增广拉格朗日方法解决约束优化问题，优化PaymentNet，尽管问题非凸，但实验表明优化后的CGA能接近最优收入且遗憾极小。\n3. **实验验证**\n    - **实验设置**\n        - 数据集：使用来自淘宝的真实日志数据，包括训练集和测试集，每个样本涉及多个广告商竞争广告槽位，实验设置广告槽位数为3。\n        - 基线方法：对比GSP、DNA、SW-VCG、VCG Auction with Permutation-level Externalities（VCG）、EdgeNet和Optimal等方法，根据外部性建模粒度分类。\n        - 性能指标：考虑每千次展示收入（RPM）、点击率（CTR）和IC度量（衡量广告商操纵出价可获得的效用相对增加）。\n        - 实现细节：设置CGA的特征嵌入大小、注意力机制、隐藏层大小等参数，通过Adam优化器训练，学习型基线方法通过网格搜索调优超参数。\n    - **离线比较结果**\n        - CGA在平台收入（RPM）和CTR方面优于现有方法，且事后遗憾较低，表明CGA能有效近似最优拍卖机制。\n        - 随着外部性建模从无到集合级再到排列级的改进，拍卖性能在三个指标上均有提升，突出了精细建模外部性在拍卖设计中的重要性。\n    - **消融研究**\n        - CGA的各设计考虑有效，去除Evaluator或改变训练方式会导致性能下降，证明了G-E框架、外部奖励建模和虚拟价值使用的重要性。\n        - 去除价值分布对CGA性能影响较小，可能是因为CGA对外部性的建模通过捕捉广告间相关性，部分反映了缺失的价值分布信息。\n    - **在线A/B测试结果**\n        - CGA在淘宝广告系统的在线A/B测试中表现良好，与DNA相比，RPM提升3.2%，平均响应时间仅增加3ms（相对增加1.6%），同时提高了广告商的投资回报率（ROI）、CTR和商品交易总额（GMV），表明CGA能通过生成模型有效探索分配空间，提升平台收入。\n4. **研究结论**\n    - 提出CGA框架，用于在线多槽广告拍卖中考虑排列级外部性，理论上证明了经典Myerson拍卖在适应排列级外部性时的最优性，为CGA框架设计提供依据。\n    - CGA通过自回归生成模型和G-E学习范式优化分配，通过量化IC约束为预期事后遗憾学习最优支付规则，经离线和在线实验验证有效。\n    - 未来研究将扩展上下文生成机制，以整合来自不同渠道的异构项目。\n![alt text](./images/1.13_Figure_1.png)\n![alt text](./images/1.13_Figure_2.png)\n![alt text](./images/1.13_Figure_3.png)\n![alt text](./images/1.13_Figure_4.png)\n![alt text](./images/1.13_Figure_5.png)\n![alt text](./images/1.13_Figure_6.png)\n使用真实监督信号的方式虽然简单直接，但是此类方法只考虑了初始排序这一种排列方式上的物品间关系和用户反馈。假设有序列中有n个物品，其余n!-1种排列方式都被模型忽略，不利于寻找最优排序。\n[refer](https://mp.weixin.qq.com/s/TUpkUi2EpqW0wZ3KxncJYQ)\n\n基于listwise模型的rerank的实现方法。而在listwise模型中根据做法的不同又可以分为序列生成式、基于序列表征pointwise式、半生成式、两段式和强化学习等几种不同的方案。\n\n# model方法\n\n## 基于序列表征，pointwise打分\n这一大类有一个共同的特点，都是以上层精排的输出序列作为输入，在模型结构上借助RNN等序列结构来引入item序列之间的影响。进一步的通过attention的方式来捕捉item之间的相互影响。典型的如DLCM模型。而在阿里的PRM中进一步地将用户的个性化向量通过和item结合的方式引入模型中。这些模型第二个共同特点是最终线上对item的打分还是pointwise的，直接输出序列中每个item的分数，根据分数从高到低排序。\n### [DLCM](https://www.cnblogs.com/xumaomao/p/18213440) \n![alt text](./images/DLCM.png)\n[refer](https://zhuanlan.zhihu.com/p/390857478)\nDLCM模型主要包含3个步骤：\n\n\n1. 使用传统的LTR模型检索Top N个doc，具体做法将查询-文档对 $(q,d)$ 转化特征向量 $\\mathbf{x}_{(q,d)}$，然后使用全局排序函数 $f$ 计算查询 $q$ 的Top N个doc的列表 $R_q^n$\n\n2. 使用GRU对Top N个doc的特征向量 $\\mathbf{x}_{(q,d)}$ 进行编码，从低位置到高位置，一步一步地输入进GRU中，最终产生一个隐向量 $s_n$ 和n个隐层输出 $o_i$， $i \\in [1,n]$。这个局部模型被称为local context model - $I(R_q,X_q)$，输出被称为local ranking context\n\n3. 该步为对Top N个doc进行重排序，使用的是local ranking function (局部排序函数) $\\phi$，并且该函数的输入为 $s_n$ 和 $o$\n### [PRM](https://mp.weixin.qq.com/s/TUpkUi2EpqW0wZ3KxncJYQ)\n![alt text](./images/PRM.png)\n- 用transformer来克服RNN距离遗忘的问题，从而显式建模item之间的相互影响\n- 在transformer中加入用户兴趣的建模 (Transformer equipped with personalized embedding)\n- 其中个性化LTR Loss形式:\n\n$$\\mathcal{L} = \\sum_{r\\in\\mathcal{R}} \\ell(\\{y_i, P(y_i|X,PV;\\hat{\\theta})|i\\in\\mathcal{S}_r\\})$$\n\nPV矩阵会和输入模型的初始item特征矩阵拼接，PV矩阵由预训练模型(CTR预估模型)产生\n- [具体模型](#PRM具体模型)\n\n#### Challenges\n- 重排序后的评分困难：无法为每个反事实列表获取反馈\n- 指数级时间复杂度：组合优化问题，存在n!种可行排列\n#### 评估生成范式\n- 评估器(Evaluator)：Evaluate listwise utility\n- 生成器(Generator)：Generate feasible permutations\n\n\n### SetRank\n\n## 序列生成\n上面的那些方法都是基于预估分数重排，而下面的这些方法主要利用 RNN 直接生成重排序。\n### seq2slate\n考虑了前序信息，通过 RNN 来提取前序信息，再通过 pointer network 来从输入商品列表中一步步地生成最终推荐列表。训练时采用 REINFORCE 算法去训练，并且用的是监督式的方法去训练。\nptrnet：比如求第一个位置，就和encoder部分的都求一遍权重，和第一个关系最大，就输出1，没有词汇表，输出从输入里面选\n\n![alt text](./images/seq2slate.png)\n### [GRN](https://www.notion.so/GRN-17b9114a541680198a4fc3d7b5414f0d)\n\n## Two-Stage\n### SetToSeq\n### [PIER](https://mp.weixin.qq.com/s/NUpGoNM1P5Z5JZ0QPj3D5w)\n![alt text](./images/PIER.png)\n## RL\n从action space的角度出发，基于RL的混排模型可以分为以下两类:\n\n### 离散action space\n- 以不同类型结果的mix pattern为action space\n- 代表工作: **Cross DQN: Cross Deep Q Network for Ads Allocation in Feed**\n- 实现方式:\n  - 每种内容的结果经过精排后形成内部有序队列，如:\n    - A=(a1,a2,a3,a4)\n    - B=(b1,b2,b3,b4) \n    - C=(c1,c2,c3,c4)\n  - RL model的action space是不同类型内容的混排pattern\n  - 每种混排结果对应一种结果类型的mix pattern\n  - 示例:mix pattern = AABCB，输出mix list=a1-a2-b1-c1-b2\n  - action space size = x^N (x为结果类型数,N为混排list长度)\n  - state包含user side info和当前各队列候选list等context\n  - 特例:某些场景需要决定是否在首位透出广告/直播,此时action space简化为透出/不透出\n\n### 连续action space\n- 以多目标融合公式的加权系数作为action space\n- 代表工作: **Multi-Task Fusion via Reinforcement Learning for Long-Term User Satisfaction in Recommender Systems**\n- 实现方式:\n  - 精排后每种内容的混排分由统一的多目标融合公式给出\n  - 示例:mix_score = w1 * ctr + w2 * wtr + w3 * ltr\n  - RL学习个性化权重wi\n  - 采用non-Deterministic Policy Gradient时,w由学习的均值mu和方差sigma决定\n  - state包含user side和context信息\n\n三、方案比较\n1. A方案(离散action space)特点:\n   - 一般采用double-DQN等模型\n   - action space不宜过大(需要对离散空间取max)\n   - 便于控制不同类型结果比例\n   - 适合流量调控(根据mix pattern修正reward)\n\n2. B方案(连续action space)特点:\n   - 基于多目标融合公式进行混排\n   - RL用于动态调整系数,实现个性化\n   - 需要处理不同内容pxtr的量纲不一致问题\n   - non-Deterministic Policy的方差可提供探索能力\n### 京东\n[refer](https://mp.weixin.qq.com/s/MtIe1fZUdK94buLR5Sm64Q)\n基于强化学习的序列优化\n![alt text](./images/image-8.png)\n\n![alt text](./images/image-9.png)\n序列生成和评估模型结构包含两个主要部分:\n\n1. 序列评估模型\n- 底层进行特征抽取,使用Point DNN结构对每个item单独抽取特征\n- Point DNN将稀疏的embedding转化为dense feature,得到item的特征向量\n- 在序列评估模型中,将序列对应的向量抽取组成序列\n- 对序列进行attention操作,突出最相关的特征\n- 输出每个item的预估点击率,与出价、多样性等业务指标融合得到最终得分\n\n2. 序列生成模型\n- 输入:将整个候选集合作为生成模型的输入\n- 特征处理:\n  - 对候选集中所有item特征做max pooling得到候选集合的特征向量\n  - 将集合特征向量与每个item的特征向量拼接得到新特征\n  - 新特征经过多层DNN处理得到概率矩阵\n\n\n如图举例，假设一共有五个item，序列长度是四。如上图左上的表格，按行来看表示的是每一个item出现在当前这个位置的概率，按列来看表示的是item出现在不同位置的概率。模型训练使用2D softmax的交叉熵loss。如果一个item在候选集里被选中了，并且是出现在第一个位置，它的第一个位置的label就是1。如图，SKU1在第一个位置label是1，SKU2在第三个位置label是1。训练完成的模型在线上预测过程中预测采样频率，用一个受控的temperature参数来控制这个采样频率。按照这个表去生成序列，逐个位置去采样多次生成多个序列。举例来说，生成第一个位置需要的SKU，类似扔一个骰子，如果小于0.9，SKU1被选中，如果是0.9到1，SKU2被选中。第二个位置去除第一个位置已经出现过的SKU，进行重新归一化，再采样一次，这样可以生成多个候选序列。再把这些候选序列与启发式的或者随机生成的序列融合起来，变成一个序列的候选集，统一交给序列的评估模型去评估，选出一个最好的序列。\n### 美团\n#### （页面级序列建模）Deep Page-Level Interest Network in Reinforcement Learning for Ads Allocation. \nAccepted by SIGIR2022\n![alt text](./images/image-5.png)\n#### （多通道建模）Cross DQN: Cross Deep Q Network for Ads Allocation in Feed\n![alt text](./images/image-6.png)\n### Reinforcement Learning to Rank with Pairwise Policy Gradient\n这篇论文关注的是信息检索（IR）中的文档排序模型的强化学习（RL）。其中一个分支的方法是将排序过程形式化为马尔可夫决策过程（MDP），并通过策略梯度来确定模型参数。尽管这些方法已经取得了一些初步的成功，但它们仍未完全实现其潜力。现有的策略梯度方法直接使用采样文档列表的绝对性能分数（回报）在其梯度估计中，这可能导致两个限制：1) 无法反映同一查询内文档之间的相对优劣，而这通常与信息检索排序的本质更接近；2) 产生高方差的梯度估计，导致学习速度慢和排序准确性低。为了解决这些问题，本文提出了一种新的策略梯度算法，即成对策略梯度（Pairwise Policy Gradient, PPG），该算法使用同一查询下采样的两个文档列表进行成对比较来确定梯度。PPG算法重复采样文档列表对，通过成对比较估计梯度，并最终更新模型参数。理论分析表明，PPG能够做出无偏且低方差的梯度估计。实验结果也证明了在搜索结果多样化和文本检索方面，相比现有最先进基线方法，PPG有显著的性能提升。\n## 个性化\n### [Multi-Level Interaction Reranking with User Behavior History](https://mp.weixin.qq.com/s/F0tl3GNlUeFqZsN5hzp8Lg)\n该研究关注的是多阶段推荐系统（MRS）的最终阶段——重排序（reranking），其直接关系到用户的体验和满意度，在MRS中扮演着关键角色。尽管现有工作已经取得了一定的进步，但仍有三个问题尚未得到解决：\n1. 用户历史行为中的偏好信息未被充分利用：用户的历史行为包含丰富的偏好信息，例如用户的长期和短期兴趣，但在重排序过程中并未被充分挖掘。以往的工作通常将历史记录中的项目视为同等重要，忽略了历史与候选项目之间的动态交互。\n2. 现有的重排序模型主要关注项目级别的交互，而忽略了特征级别的细粒度交互：这导致了对项目之间细微影响的捕捉不足，从而影响了重排序的效果。\n3. 在重排序前对初始有序列表进行评分可能导致过早评分问题：这种做法可能会产生次优的重排序性能，因为评分是在固定顺序下进行的，未能充分考虑到不同排列可能带来的不同效果。\n\n\n为了解决上述问题，本文提出了一种名为多层次交互重排序（Multi-level Interaction Reranking, MIR）的框架。MIR结合了低级别的跨项目交互和高级别的集到列表交互，其中将待重排序的候选项目视为一个集合，而将用户按时间顺序的行为历史视为一个列表。我们设计了一个新颖的SLAttention结构来建模集到列表的交互，并融合个性化长短期兴趣。此外，为了捕捉项目之间的细粒度影响，我们还引入了特征级别的交互。MIR的设计确保了输入项目的任何排列不会改变输出排名，这一点我们在理论上也进行了证明。\n## 具体模型\n### PRM具体模型\n### 4.2 Input Layer (输入层)\n\n- **Personalized Vector (PV)**：个性化向量\n  - 尽管精排队列给出的列表已经有部分个性化结果了，但对于整个用户的个性化结果来说，还不够\n  - 本文拼接原始的特征向量X与用户个性化的向量PV(图1b)，从而重排阶段引入用户个性化\n\n- **Position Embedding (PE)**：位置向量\n  - 为了利用精排队列中的items的序列信息，本文引入位置编码向量PE(可学习)\n  - 使用方式与[X;PV]+PE\n  - 在输入向量之后使用FFN进行编码与维度转换，得到图1b中输入层最后的e\n\n### 4.3 Encoding Layer(编码层)\n\n- 编码层目的是学习items对与额外信息(用户偏好、items初始列表)之间的交互(图1a)\n- 本文使用N层Transformer进行编码，主要考虑到了:\n  - TRM的并行\n  - self-attention不会依赖item之间的距离等因素\n- 从图1a可以看出，本文使用的Transformer block与原论文基本一致，也是用到了Multi-head Self-Attention，FFN等结构\n\n### 4.4 Output Layer(输出层)\n\n- 输出层目标是为每个item打出一个重排得分\n- 此处最终使用softmax函数进行输出\n- 输出结果为点击每个item的概率\n- 训练模型时，本文使用点击相关数据完成训练，最终损失函数为交叉熵\n$$\\mathcal{L} = \\sum_{r\\in\\mathcal{R}} \\ell(\\{y_i, P(y_i|X,PV;\\hat{\\theta})|i\\in\\mathcal{S}_r\\})$$\n### 4.5 Personalized Module(个性化模块)\n\n- 直观来说，可以直接用PRM来端到端学习用户个性化向量PV\n- 然而在重排阶段学习PV，缺少了用户的通用偏好信息\n- 因此本文使用预训练模型生成用户个性化向量(图1c)\n  - 输入为用户的点击序列items(H)，当前item与用户user的信息(性别、年龄、购买力等)\n  - 训练数据仍然使用点击数据\n  - 损失函数为二分类交叉熵\n  - 最终取sigmoid之前层网络的输出结果作为用户个性化向量PV\n- 由于是CTR任务，作者也建议使用FM、FFM、DeepFM、DCN、FFN、PNN等用来学习PV","tags":["paper","混排"],"categories":["research"]},{"title":"Budget&Dynamic","url":"/2024/12/24/Budget-Dynamic/","content":"\n## An efficient multi-item dynamic auction with budget constrained bidders\n\n### 摘要\n拍卖人出售多个不可分割物品给潜在投标人，投标人有估值但可能受预算约束，瓦尔拉斯均衡可能不存在。本文提出新颖动态拍卖，能找到核心分配，其包含物品分配与支持价格向量，可实现帕累托效率且对联盟偏离威胁有鲁棒性，拍卖中价格过高时可降低。\n\n### 要点\n1. **模型构建**\n   - 包含卖家和多个潜在投标人，卖家有不可分割物品，投标人对物品有估值和预算，且预算为私有信息，定义了相关概念如价格向量、分配、瓦尔拉斯均衡等，还阐述了核心和严格核心概念及性质。\n2. **动态拍卖机制**\n   - 投标人提交出价，拍卖人据出价选分配和价格，投标人再更新出价，重复至无人更新。该拍卖与其他拍卖相比有独特之处，如价格调整灵活、允许降出价等。\n   - 证明了拍卖在有限轮终止，且终止时结果为核心分配，在无预算约束时为严格核心分配且分配完全有效。\n\n### 实验方法\n通过理论分析和举例说明的方式，如在阐述模型时举了多个例子说明不同情况下的市场均衡和核心分配情况，在证明拍卖相关性质时运用了数学推导和逻辑推理。\n\n## AuctionNet: A Novel Benchmark for Decision-Making in Large-Scale Games\n1. **摘要**：决策制定在大规模游戏中是人工智能的重要研究领域，本文提出AuctionNet基准，用于大规模广告拍卖中的出价决策。它由广告拍卖环境、预生成数据集和基线出价决策算法性能评估三部分组成。环境通过多个模块交互复制真实拍卖的完整性和复杂性，数据集包含众多代理竞争轨迹，还评估了多种基线算法性能，该基准已应用于NeurIPS 2024竞赛。\n2. **要点**\n    - **决策问题**：关注广告拍卖中的自动出价问题，用部分可观测随机博弈（POSG）公式化问题，优化目标是在预算约束下最大化价值。\n    - **广告拍卖环境**：包含广告机会生成、出价和拍卖等模块。广告机会生成模块用深度生成模型生成数据，降低与现实差距并避免敏感数据暴露；出价模块模拟广告主竞争，实现多种算法；拍卖模块基于经典GSP拍卖，支持多种规则和多广告位特性。\n    - **预生成数据集**：基于环境生成，包含大量广告剧集、机会和记录，可用于深入了解拍卖生态，分析印象值随时间变化及不同类别关系。\n    - **基线算法评估**：评估了线性规划、强化学习和生成模型等基线算法性能，如Online LP表现较好，IQL和BC等有优化潜力。\n3. **实验方法**\n    - **环境构建与交互**：将广告机会按时间划分决策步骤，代理依次出价，环境提供最终性能，通过多个模块交互实现真实拍卖模拟。\n    - **数据集生成与分析**：使用深度生成模型生成数据，通过PCA可视化、分析价值分布和字段连接等方式验证生成数据与真实数据的相似性，生成的数据集用于分析不同类别印象值变化及关系。\n    - **算法评估**：在基本任务和目标CPA任务中评估基线算法，比较不同算法性能，未对方法针对自动出价任务进行特殊优化。\n\n## Reinforcement Mechanism Design: With Applications to Dynamic Pricing in Sponsored Search Auctions\n### 摘要\n在赞助搜索中，标准机制是广义第二价格（GSP）拍卖，但存在非收入最优问题。本文研究个体和组织互动的社会系统，以赞助搜索拍卖为背景，结合机制设计和人工智能工具解决搜索引擎动态定价问题。通过训练买家行为模型，将动态定价问题建模为马尔可夫决策过程（MDP），应用强化学习算法优化储备价格，实验表明该模型优于多种静态和动态优化策略。\n1. **研究背景**\n    - **赞助搜索拍卖现状**：在线销售广告是搜索引擎公司的盈利模式，如谷歌和百度。用户搜索时，搜索引擎展示广告，广告商竞价竞争位置，按点击付费。常见的广义第二价格（GSP）拍卖机制存在收入非最优问题，且多数收入优化理论基于竞标者理性行为假设，但实际中该假设常不成立。\n    - **相关研究不足**：新兴研究关注竞标者使用学习算法的情况，但多数模型未详细描述竞标者实际行为，难以捕捉异质竞标者群体的不同理性水平。\n2. **研究方法**\n    - **强化机制设计**：提出混合方法，结合机制设计理论和机器学习技术。先依据机制设计理论用参数描述机制，再用优化算法寻找最优参数；同时用机器学习算法构建精确的竞标者行为模型，将机制参数作为输入，考虑机器学习和战略竞标者行为。\n    - **构建竞标者行为模型**\n        - **RNN模型**：基于循环神经网络（RNN）构建，输入包括连续m天的关键绩效指标（KPI）、竞标者的出价分布及日期相关特征。RNN输出经全连接层和softmax激活函数转换为有效概率分布。为简化出价分布表示，将其离散为100维向量。KPI统计数据取对数并用tile - coding编码，以捕捉竞标者对相对变化的关注。同时包含公共特征集，如日期相关特征，因多数广告商有季节性广告活动。\n        - **数学表述为马尔可夫模型**：采用时间齐次马尔可夫模型解释RNN - 基于竞标者行为模型，即竞标者下一时间步的出价分布是前m个时间步出价分布和KPI的函数，该模型符合文献及百度实际观察。\n    - **强化机制设计框架**\n        - **问题表述为MDP**：将动态机制设计问题表述为马尔可夫决策过程（MDP），其中竞标者出价分布为状态，储备价格为行动。目标是选择一系列储备价格配置文件以最大化贴现收入总和。\n        - **优化算法**：虽存在最优储备定价方案，但精确计算成本高。通过限制关注少数主要竞标者的关键词及仅探索当前储备价格小邻域内的行动来降低计算复杂度，并采用蒙特卡洛树搜索（MCTS）算法，通过限制搜索深度和搜索轨迹数量有效控制计算复杂性。\n3. **实验设计与结果**\n    - **实验设置**：选择400个具有特定属性（日查询量大且稳定、大部分收入由最多3个竞标者贡献）的关键词，提取8个月的竞价数据（超70TB）。对每个关键词关注3个主要竞标者，为其构建LSTM网络，设置时间步为1天，用90%数据训练，10%测试，以平均交叉熵为性能指标，用ADAM优化器优化。MCTS算法中探索储备价格为当前储备价格的0.95、1.0和1.05倍，设置相关参数如λ = 0.8、搜索深度为5等。\n    - **结果分析**\n        - **策略比较**：动态策略（MCTS）优于所有静态策略（如STATIC OPT、BAIDU、STATIC 50）及动态策略（GREEDY和POLICY GRAD）。BAIDU曲线快速收敛；STATIC OPT曲线先升后降；之前百度在线实验表明STATIC OPT短期内收入高但长期下降，与模拟结果相符，证明竞标者行为模型准确性。激进定价方案短期内收入高但长期下降，因竞标者对储备价格变化作出反应。GREEDY和POLICY GRAD算法表现良好，虽稍逊于MCTS但更简单、计算成本低，表明竞标者可能不太具战略性。\n        - **储备价格更新频率影响**：MCTS算法中，更新储备价格频率越低（Δt越大），收入越高且收敛越快。GREEDY算法性能与Δt = 3时的MCTS算法几乎相同。\n4. **研究结论**\n    - 提出结合机制设计和人工智能技术的动态定价框架，不依赖多数理论分析中的不现实假设，采用数据驱动方法解决理论市场设计问题。\n    - 框架包含竞标者行为模型（RNN）和优化算法（MCTS），迭代寻找最优机制参数，通过模拟拍卖估计未来目标。\n    - 在中国主要搜索引擎百度的真实竞价数据实验中，该框架显著提高收入，已被百度采用并证明能增加收入。\n\n## A dynamic auction for multi-object procurement under a hard budget constraint\n### 摘要\n本论文重新审视了政府机构分配研发补贴的问题。通常，申请人的财务约束属于私人信息。已有文献建议采用拍卖方式，以减少信息租金，从而提高稀缺公共资金的分配效率。针对这一采购问题，我们提出了一种新的开放式时钟拍卖。这种拍卖在战略上较为简单，因为它在占优策略中体现了说实话的特性，并且在遵守预算约束的同时满足事后理性。我们通过蒙特卡洛模拟对该拍卖进行了测试，并讨论了其适用性和局限性。此外，我们还强调了与计算机科学最新进展的联系。\n\n1. **研究背景**\n    - **创新与市场失灵**：创新存在市场失灵特性，如不可分割性、不可占有性和不确定性，私人企业研发投资常非社会最优，政府采用多种政策工具干预，其中直接补贴私人研发尤为重要，如美国小企业创新研究计划（SBIR）。\n    - **补贴效果与问题**：公共研发资金对社会有益，有直接资助和“光晕”或信号效应等好处，但现有补贴分配实践存在问题，如未充分考虑项目性价比，可能导致资金浪费，同时政府政策可能受游说或政治压力扭曲。\n2. **模型构建**\n    - **参与者与物品**：政府机构为“买家”，申请人为“卖家”，卖家有不可分割物品（研究提案），有私知保留价格\\(\\theta_{i}\\)，提交财务出价\\(b_{i}\\)，买家有固定预算\\(B\\)。\n    - **质量等级与权重**：为评估买家效用，给每个申请人项目设定质量等级及相对权重（如A项目权重1，B项目0.7等），资金决策基于这些等级，实际质量在决策时不确定。\n    - **买家效用与目标**：买家目标是在预算约束下最大化采购物品总质量，效用函数为\\(u_{buyer}(\\mathcal{A})=\\sum_{j \\in \\mathcal{A}} w_{j}=\\sum_{i \\in \\mathcal{I}} q_{i} w_{i}, q_{i} \\in\\{0,1\\}\\)，完全信息下的最优分配是解决相关二进制背包问题。\n3. **拍卖机制**\n    - **初始设置**：申请人给定财务起始出价\\(\\bar{b}_{i}\\)（如当前补贴或匹配赠款），起始出价除以质量得到初始价格质量比\\(\\bar{r}_{i}\\)。\n    - **拍卖过程**：采用开放递减时钟拍卖，时钟从最高初始价格质量比开始倒计时，投标人可随时退出且不能再进入。只要活跃投标人财务出价总和超预算，倒计时继续，直到预算能容纳剩余活跃出价或正好耗尽预算时拍卖结束。\n    - **支付与结果**：输家保留物品无支付，赢家根据拍卖结束方式获得支付（若因退出结束，支付由退出者最终价格质量比决定；若因耗尽预算结束，支付用完预算）。该机制中，说实话是占优策略，满足预算约束且事后个体理性。\n4. **模拟分析**\n    - **模拟设置**：通过蒙特卡洛模拟，假设卖家采用占优策略均衡，对模型参数做多种假设，随机抽取储备价格和信息租金，比较动态拍卖（DA）与最优分配（FB）和现状分配（SQ）。\n    - **模拟结果**\n        - **信息租金影响**：DA旨在减少信息租金，在无信息租金时，DA近似FB且优于SQ；信息租金越大，DA相对SQ优势越明显。\n        - **福利权重影响**：B和C项目福利权重越高，SQ分配误差越大，因SQ过于重视A项目，而DA分配规则能适应福利权重变化。\n        - **预算规模影响**：预算增加时，SQ和DA性能都提升，但SQ对预算变化更敏感。\n        - **储备价格分布影响**：多数情况下，储备价格分布假设对SQ和DA相对性能影响不大，DA性能相对稳定，集中在FB的70 - 75%，而SQ在某些情况下性能较差。总体而言，DA对参数变化不太敏感，跟踪误差主要源于信息租金，SQ则因基本分配误差对假设变化敏感。\n5. **讨论与结论**\n    - **适用性与局限性**：论文基于前人对研发补贴分配的研究，改进拍卖设计简化战略问题，提供稳健预测。假设虽合理但现实中可能被违反，如引入拍卖可能改变申请人行为，导致项目性质、成本超支和作弊风险变化；模型假设项目为完美替代品可能扭曲分配，但偏离该假设会使评估和拍卖难以实施；改变补贴分配方式可能影响高质量申请人数量，但平均质量下降可能仍意味着福利改进；理论上更多参与者应改善拍卖分配，但实践中需平衡项目数量与政策目标及项目启动延迟问题；光环或认证效应使拍卖更理想，但可能降低补贴项目平均质量。\n    - **实施与建议**：实施拍卖需程序管理选择质量等级和福利权重，申请人准备提案并确定储备价格，拍卖实施相对简单且能增加资金决策透明度。使用拍卖的利弊因具体情况而异，需在现实中测试并评估效果，机制适用性取决于创新类型、目标群体和政策目标等因素，理论结果也可能适用于研发资金以外场景。\n  \n  ## Spending Programmed Bidding: Privacy-friendly Bid Optimization with ROI Constraint in Online Advertising\n  ### 摘要\n  隐私政策使得实时且精确的用户数据无法追踪，这扰乱了价值数十亿美元的在线广告市场，给在线广告行业中受投资回报率（ROI）约束的产品优化带来了重大挑战。隐私保护策略，包括事件聚合和报告延迟，阻碍了对详细和即时反馈数据的获取，从而使传统的身份揭示归因技术无法发挥作用。在本文中，我们引入了一种新颖的支出程序化出价（SPB）框架来应对这些挑战。SPB是一个两阶段框架，将长期投放支出规划（宏观阶段）和短期出价执行（微观阶段）分开。宏观阶段对目标ROI进行建模以实现最大效用并得出预期支出，而微观阶段则在给定预期支出的情况下优化出价价格。我们进一步将我们的框架扩展到跨渠道场景，在该场景中，代理在受隐私约束和身份揭示归因渠道中进行出价。我们发现，当存在受隐私约束的渠道时，SPB在离线数据集和大型广告平台的在线实验中均优于最先进的出价方法。\n  “Spending Programmed Bidding: Privacy-friendly Bid Optimization with ROI Constraint in Online Advertising”由Yumin Su、Min Xiang等人撰写，提出了一种创新的在线广告出价框架Spending Programmed Bidding (SPB)，以解决隐私保护下ROI约束的出价优化问题。\n1. **研究背景**\n    - **隐私政策影响广告效果**：隐私政策使实时精准用户数据难以追踪，影响在线广告的ROI优化。如苹果的PCM和SKAN策略虽保护隐私，但存在事件聚合和报告延迟问题，影响广告投放和效果评估。\n    - **现有方法的局限性**：传统身份揭示方法受隐私约束，在解决报告延迟、依赖实时数据等问题上存在局限，如CVR预测模型、PID、MPC和RL等方法在隐私场景中效果不佳。\n2. **研究方法**\n    - **问题定义与数学表示**：基于在线随机背包问题定义，目标是在ROI和花费约束下最大化GMV，给出了相关数学公式和符号定义。\n    - **隐私场景挑战**：隐私政策导致拍卖中\\(c_i\\)和\\(wp_i\\)获取困难，使问题面临粗粒度、滞后性和随机性挑战，影响传统优化方法和实时反馈控制方法的适用性。\n    - **SPB框架**\n        - **两阶段分解**：将在线出价过程分为宏观和微观阶段。宏观阶段根据长期数据规划最优花费\\(S^{(opt)}\\)，微观阶段基于\\(S^{(opt)}\\)生成实时出价价格，有效应对隐私场景挑战。\n        - **阈值算法（THRESHOLD）**：一种贪婪算法，在特定条件下可近似解决问题，通过确定阈值\\(R_{thr}\\)计算最优出价，SPB算法对其改进以适应隐私场景。\n        - **宏观花费规划**：通过探索最优GMV和最优ROI的关系，构建函数关系计算最优花费，利用长期累积数据应对隐私挑战，通过多日数据聚合和拟合确定函数参数。\n        - **微观出价优化**：在宏观确定总体最优花费基础上，通过预算分配获得短期最优花费，利用IMPC方法构建\\(R_{thr}\\)和花费\\(P_S\\)的线性插值模型计算最优出价，具有无累积误差、无需先验函数分布、稳健便携等优点。\n        - **多渠道推广**：将SPB扩展到多渠道场景，宏观部分联合求解各渠道最优花费，微观部分独立应用IMPC算法计算出价，通过定理4确定各渠道\\(R_{thr}\\)相等时整体\\(P_G\\)最大。\n3. **实验验证**\n    - **实验设置**：使用TikTok广告平台工业数据集和模拟隐私数据集，定义预算拆分实验机制，介绍SPB方法设置。\n    - **性能评估指标**：根据ROI和花费利用率将广告活动分组，通过计算GMV和花费评估出价方法性能。\n    - **对比出价方法**：对比BidCap、MPC和SPB三种出价方法。\n    - **实验结果**\n        - **在线实验**：SPB在Accomplish组提高GMV和收入，在Violation组降低GMV和收入；在隐私约束场景表现良好，尤其在SKAN归因活动中；对ROI波动容忍度降低时，Violation组GMV比例增加较小，GMV分布更倾向于\\(R_{res}/R_{target}>1\\)。\n        - **离线实验**：SPB在Accomplish组增强GMV，在Violation组降低GMV；在不同延迟下，Accomplish组比例高且随延迟增加优势更明显，Violation组GMV比例增加缓慢；在离线环境中，GMV分布更集中于\\(R_{res}/R_{target}=1\\)，能产生更多\\(R_{res}/R_{target}≥1.0\\)的GMV。\n4. **研究结论**\n    - 提出的SPB框架有效解决隐私保护下ROI约束的出价优化问题，在离线和在线实验中表现优于现有方法。\n    - 未来将探索更隐私敏感的广告市场平衡。","tags":["paper","Budget","Dynamic"],"categories":["research"]},{"title":"多进程","url":"/2024/10/24/sync/","content":"\n# 多进程\n\n## （微软）1：\n\n\"\\\"n分割的文本文件存储很大，存储在分布式集群中 M个进程需要较为均匀的分配读取整个文件，进程需要对每行记录进行处理。 每行数据最大不超过10MB。 要求处理的数据没有重复和丢失。 提供的API // get the file size, failed with negative value. File open(std::string filename); // file attributes size_t File::size() // read length bytes from offset postion. std::vector<char> read(std::uint64_t offset, std::uint64_t  length); void ProcessRead(std::string filename, int processcount, int pid) {    vector<string>  records  // You need to finish this part. }  // Process Process(records) }\n\n```c++\n#include <iostream>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <thread>\n#include <mutex>\n\nclass File {\npublic:\n    File(std::string filename) : filename_(filename) {\n        std::ifstream in(filename, std::ifstream::ate | std::ifstream::binary);\n        if (in) {\n            size_ = in.tellg(); // 获取文件大小\n        } else {\n            size_ = -1; // 文件打开失败，返回负值\n        }\n    }\n\n    size_t size() const {\n        return size_;\n    }\n\n    std::vector<char> read(std::uint64_t offset, std::uint64_t length) {\n        std::ifstream in(filename_, std::ifstream::binary);\n        if (!in) return {};\n\n        in.seekg(offset);\n        std::vector<char> buffer(length);\n        in.read(buffer.data(), length);\n        return buffer;\n    }\n\nprivate:\n    std::string filename_;\n    size_t size_;\n};\n\n// 处理读取到的记录，这里可以定义你自己的处理逻辑\nvoid Process(const std::vector<std::string>& records) {\n    for (const auto& record : records) {\n        // 在这里处理每行记录\n        std::cout << \"Processing record: \" << record << std::endl;\n    }\n}\n\n// 读取文件的具体实现\nvoid ProcessRead(std::string filename, int processcount, int pid) {\n    File file(filename);\n    size_t filesize = file.size();\n    if (filesize < 0) {\n        std::cerr << \"Failed to open file: \" << filename << std::endl;\n        return;\n    }\n\n    // 计算每个进程需要读取的部分大小\n    size_t chunk_size = filesize / processcount;\n    size_t start_offset = pid * chunk_size;\n    size_t end_offset = (pid == processcount - 1) ? filesize : (pid + 1) * chunk_size;\n\n    std::vector<std::string> records;\n    size_t current_offset = start_offset;\n\n    while (current_offset < end_offset) {\n        size_t read_size = std::min(static_cast<size_t>(10 * 1024 * 1024), end_offset - current_offset);\n        auto buffer = file.read(current_offset, read_size);\n        if (buffer.empty()) break;\n\n        std::string record;\n        for (char ch : buffer) {\n            if (ch == '\\n') {\n                records.push_back(record);\n                record.clear();\n            } else {\n                record.push_back(ch);\n            }\n        }\n\n        // 更新偏移量\n        current_offset += read_size;\n    }\n\n    // 处理当前进程读取的所有记录\n    Process(records);\n}\n\nint main() {\n    int processcount = 4; // 假设有4个进程\n    std::vector<std::thread> threads;\n\n    // 启动多个进程（实际上是多个线程模拟）\n    for (int pid = 0; pid < processcount; ++pid) {\n        threads.push_back(std::thread(ProcessRead, \"data.txt\", processcount, pid));\n    }\n\n    // 等待所有进程完成\n    for (auto& t : threads) {\n        t.join();\n    }\n\n    return 0;\n}\n\n```\n\n","tags":["加密文章tag"],"categories":["Interview"]},{"title":"KDD2024 adv","url":"/2024/10/10/KDD2024-adv/","content":"# KDD 2024 工业界搜广推（广告）工作整理\n\n[参考](https://mp.weixin.qq.com/s/jSRiHyg0yRGaRzFDpIl81Q)\n\n# **Alibaba**\n\n**生成式出价 |** **Generative Auto-bidding via Conditional Diffusion Modeling**\n\n利用条件扩散模型进行自动出价，提高在线广告的效率。\n\nJiayan Guo (Peking University, Alibaba Group); Yusen Huo (Alibaba Group); Zhilin Zhang (Alibaba Group); Tianyu Wang (Alibaba Group); Chuan Yu (Alibaba Group); Jian Xu (Alibaba Group); Bo Zheng (Alibaba Group); Yan Zhang (Peking University)\n\n**因果推断 | CURLS: Causal Rule Learning for Subgroups with Significant Treatment Effect**\n\n针对具有显著处理效应的子群体的因果规则学习。\n\nJiehui Zhou (State Key Lab of CAD&CG, Zhejiang University, DAMO Academy, Alibaba Group); Linxiao Yang (DAMO Academy, Alibaba Group); Xingyu Liu (State Key Lab of CAD&CG, Zhejiang University); Xinyue Gu (DAMO Academy, Alibaba Group); Liang Sun (DAMO Academy, Alibaba Group); Wei Chen (State Key Lab of CAD&CG, Zhejiang University)\n\n**合约广告 | Bi-Objective Contract Allocation for Guaranteed Delivery Advertising**\n\n合约广告的双目标合同分配问题。\n\nan Li (Key Laboratory of System Software (Chinese Academy of Sciences) and State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences, School of Computer Science and Technology, University of Chinese Academy of Sciences); Yundu Huang (Alibaba Group); Wuyang Mao (Alibaba Group); Furong Ye (Key Laboratory of System Software (Chinese Academy of Sciences) and State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences); Xiang He (Key Laboratory of System Software (Chinese Academy of Sciences) and State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences, School of Computer Science and Technology, University of Chinese Academy of Sciences); Zhonglin Zu (Alibaba Group); Shaowei Cai (Key Laboratory of System Software (Chinese Academy of Sciences) and State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences, School of Computer Science and Technology, University of Chinese Academy of Sciences)\n\n**拍卖广告 | Truthful Bandit Mechanisms for Repeated Two-stage Ad Auctions**\n\n为重复两阶段广告拍卖设计真实性多臂老虎机机制。\n\nHaoming Li (Shanghai Jiaotong University); Yumou Liu (The Chinese University of Hong Kong, Shenzhen); Zhenzhe Zheng (Shanghai Jiao Tong University); Zhilin Zhang (Alibaba Group); Jian Xu (Alibaba Group); Fan Wu (Shanghai Jiao Tong University)\n\n\n\n# **Bytedance**\n\n**出价 | Spending Programmed Bidding: Privacy-friendly Bid Optimization with ROI Constraint in Online Advertising**\n\nYumin Su (ByteDance Inc.); Min Xiang (ByteDance Inc.); Yifei Chen (ByteDance Inc.); Yanbiao Li (ByteDance Inc.); Tian Qin (ByteDance Inc.); Hongyi Zhang (ByteDance Inc.); Yasong Li (ByteDance Inc.); Xiaobing Liu (ByteDance Inc.)\n\n\n\n# **Tencent**\n\n**排序增强的uplift | Rankability-enhanced Revenue Uplift Modeling Framework for Online Marketing**\n\nBowei He (City University of Hong Kong); Yunpeng Weng (FiT, Tencent); Xing Tang (FiT, Tencent); Ziqiang Cui (City University of Hong Kong); Zexu Sun (Renmin University of China); Liang Chen (FiT, Tencent); Xiuqiang He (FiT, Tencent); Chen Ma (City University of Hong Kong)\n\n\n\n# **Meituan**\n\n**拍卖 | Joint Auction in the Online Advertising Market**\n\nZhen Zhang (Gaoling School of Artificial Intelligence, Renmin University of China); Weian Li (School of Software, Shandong University); Yahui Lei (Meituan Inc.); Bingzhe Wang (Gaoling School of Artificial Intelligence, Renmin University of China); Zhicheng Zhang (Gaoling School of Artificial Intelligence, Renmin University of China); Qi Qi (Gaoling School of Artificial Intelligence, Renmin University of China); Qiang Liu (Meituan Inc.); Xingxing Wang (Meituan Inc.)\n\n**因果推断 | Decision Focused Causal Learning for Direct Counterfactual Marketing Optimization**\n\nHao Zhou (State Key Laboratory for Novel Software Technology, Nanjing University, Meituan); Rongxiao Huang (State Key Laboratory for Novel Software Technology, Nanjing University); Shaoming Li (Meituan); Guibin Jiang (Meituan); Jiaqi Zheng (State Key Laboratory for Novel Software Technology, Nanjing University); Bing Cheng (Meituan); Wei Lin (Meituan)\n\n\n\n# **Google**\n\n**LLM用于拍卖 | Auctions with LLM Summaries**\n\nAvinava Dubey (Google Research); Zhe Feng (Google Research); Rahul Kidambi (Google Research); Aranyak Mehta (Google Research); Di Wang (Google Research)\n\n\n\n# **Shopee**\n\n**广告校准 | Deep Ensemble Shape Calibration: Multi-Field Post-hoc Calibration in Online Advertising**\n\nShuai Yang (Shopee Discovery Ads); Hao Yang (Shopee Discovery Ads); Zhuang Zou (Shopee Discovery Ads); Linhe Xu (Shopee Discovery Ads); Shuo Yuan (Shopee Discovery Ads); Yifan Zeng (Shopee Discovery Ads)\n\n\n\n# **Meta**\n\n**离线强化学习出价 | Offline Reinforcement Learning for Optimizing Production Bidding Policies**\n\nDmytro Korenkevych (AI at Meta); Frank Cheng (AI at Meta); Artsiom Balakir (AI at Meta); Alex Nikulkov (AI at Meta); Lingnan Gao (Meta Platform Inc.); Zhihao Cen (AI at Meta); Zuobing Xu (Meta Platform Inc.); Zheqing Zhu (AI at Meta)\n\n\n\n\n\n\n\n\n\n","tags":["paper"],"categories":["research"]},{"title":"Deep learning for revenue-optimal auctions with budgets","url":"/2024/09/29/Deep-learning-for-revenue-optimal-auctions-with-budgets/","content":"### 1. 研究的问题：\n这篇论文研究的问题是如何设计收入最大化的拍卖机制，特别是针对具有私人预算限制的环境中的拍卖。在这种环境下，竞拍者由于财务约束，无法支付超过他们预算的金额。论文探讨了即使在单一物品和两个竞拍者的情况下，带有私人预算约束的最优主导策略激励相容（DSIC）设计也是未知的。作者尝试使用深度学习方法来解决这个问题。\n\n### 2. 研究的对象：\n研究的对象是多物品拍卖环境中的私人预算约束，包括但不限于单一物品拍卖、多物品拍卖、具有附加价值的竞拍者和单位需求竞拍者的拍卖。这些拍卖场景中的竞拍者具有私人价值和预算限制，论文尝试设计出在这些约束下能够最大化预期收益的拍卖规则。\n\n### 3. 使用的技术：\n作者使用了深度学习技术，特别是神经网络来模拟拍卖规则，并使用机器学习进行最优拍卖的自动化设计。具体来说，他们扩展了RegretNet框架，以处理私人预算约束和贝叶斯激励相容性（BIC）。他们还使用了增强拉格朗日方法来解决基于样本的优化问题，并通过Adam优化器来逼近解决内层优化问题。此外，他们还使用了TensorFlow深度学习库进行实验，并采用了增强拉格朗日方法中的拉格朗日乘数更新技术来处理约束条件。\n### 扩展RegretNet的部分\n预算约束（Budget Constraints）：\n\n原始的RegretNet框架没有考虑预算约束。在这篇论文中，作者扩展了框架以包括预算约束，即确保拍卖机制不会让竞拍者支付超过其预算的金额。\n这是通过在损失函数中加入预算约束（BC）罚分来实现的，以确保每个竞拍者的支付不超过其预算。\n贝叶斯激励相容性（Bayesian Incentive Compatibility, BIC）：\n\n除了主导策略激励相容性（DSIC），作者还扩展了框架以支持BIC，这是一种在竞拍者类型分布未知的情况下的激励相容性。\n在BIC拍卖中，竞拍者在报告自己的类型时，说真话是其最优策略，从期望上讲，相对于其他竞拍者的类型。\n条件激励相容性（Conditional Incentive Compatibility）：\n\n作者还考虑了条件激励相容性，即竞拍者只能低估自己的预算，而不是高估。\n这需要对RegretNet框架进行进一步的调整，以处理这种单向的激励约束。\n### 公式变化：（3.1）\n![regret](image1.png)\n原始RegretNet：\n![regret](image2.png)\n现在的loss function：\n![regret](image3.png)\n原始RegretNet：\n![regret](image4.png)\n其实就是加上考虑了budget和IR，pay要小于budget，收益不能为负\n![regret](image8.png)\n### 网络结构变化：\n本文：\nBudgeted RegretNet: (a) Allocation rule a and (b) Payment rule p for a setting withm distinct items and n unit-demand buyers.\n![regret](image5.png)\n原始RegretNet：\n![regret](image6.png)\n![regret](image7.png)\n其实就是输入的从只有bid变成value（可能不truthful）+budget","tags":["paper"],"categories":["research"]},{"title":"Related Work","url":"/2024/09/29/Related-Work/","content":"1.研究的问题 2. 研究的对象 3. 使用的技术。\n\n# AMD:\n\n## 1.原版\n\n```latex\n@misc{conitzer2002complexitymechanismdesign,\n      title={Complexity of Mechanism Design}, \n      author={Vincent Conitzer and Tuomas Sandholm},\n      year={2002},\n      eprint={cs/0205075},\n      archivePrefix={arXiv},\n      primaryClass={cs.GT},\n      url={https://arxiv.org/abs/cs/0205075}, \n}\n@inproceedings{conitzer2004self,\n  title={Self-interested automated mechanism design and implications for optimal combinatorial auctions},\n  author={Conitzer, Vincent and Sandholm, Tuomas},\n  booktitle={Proceedings of the 5th ACM Conference on Electronic Commerce},\n  pages={132--141},\n  year={2004}\n}\n@inproceedings{sandholm2003automated,\n  title={Automated mechanism design: A new application area for search algorithms},\n  author={Sandholm, Tuomas},\n  booktitle={International Conference on Principles and Practice of Constraint Programming},\n  pages={19--36},\n  year={2003},\n  organization={Springer}\n}\n@article{sandholm2015automated,\n  title={Automated design of revenue-maximizing combinatorial auctions},\n  author={Sandholm, Tuomas and Likhodedov, Anton},\n  journal={Operations Research},\n  volume={63},\n  number={5},\n  pages={1000--1025},\n  year={2015},\n  publisher={INFORMS}\n}\n```\n\n2.本文研究了在线广告平台中的两阶段拍卖架构，该架构用于在低延迟下向用户传递个性化广告。第一阶段从完整的广告池中高效选择一小部分有潜力的广告。第二阶段在子集中进行拍卖以确定展示的广告，使用第二阶段机器学习模型的点击率预测。研究了第一阶段子集选择策略的在线学习过程，并确保在重复的两阶段广告拍卖中具有博弈论属性。提出了一种新的实验设计，即“集群多重随机化设计”（cMRD），它在客户和搜索查询群集级别独立随机化，允许在单一实验中同时衡量定价变化的直接和间接效果。\n\n```latex\n@inproceedings{li2024truthful,\n  title={Truthful Bandit Mechanisms for Repeated Two-stage Ad Auctions},\n  author={Li, Haoming and Liu, Yumou and Zheng, Zhenzhe and Zhang, Zhilin and Xu, Jian and Wu, Fan},\n  booktitle={Proceedings of the 30th ACM SIGKDD Conference on Knowledge Discovery and Data Mining},\n  pages={1565--1575},\n  year={2024}\n}\n```\n\n### 3.regret的一坨\n\n\n\n```LATEX\n@article{dutting2024optimal,\n  title={Optimal auctions through deep learning: Advances in differentiable economics},\n  author={D{\\\"u}tting, Paul and Feng, Zhe and Narasimhan, Harikrishna and Parkes, David C and Ravindranath, Sai Srivatsa},\n  journal={Journal of the ACM},\n  volume={71},\n  number={1},\n  pages={1--53},\n  year={2024},\n  publisher={ACM New York, NY}\n}\n\n\n```\n\n衍生\n\n```latex\n@inproceedings{duan2022context,\n  title={A context-integrated transformer-based neural network for auction design},\n  author={Duan, Zhijian and Tang, Jingwu and Yin, Yutong and Feng, Zhe and Yan, Xiang and Zaheer, Manzil and Deng, Xiaotie},\n  booktitle={International Conference on Machine Learning},\n  pages={5609--5626},\n  year={2022},\n  organization={PMLR}\n}\n@article{ivanov2022optimal,\n  title={Optimal-er auctions through attention},\n  author={Ivanov, Dmitry and Safiulin, Iskander and Filippov, Igor and Balabaeva, Ksenia},\n  journal={Advances in Neural Information Processing Systems},\n  volume={35},\n  pages={34734--34747},\n  year={2022}\n}\n```\n\n1. **\"[A Context-Integrated Transformer-Based Neural Network for Auction Design]([A Context-Integrated Transformer-Based Neural Network for Auction Design | 一个田螺突然就 (2010727302.github.io)](https://2010727302.github.io/2024/09/29/A-Context-Integrated-Transformer-Based-Neural-Network-for-Auction-Design/))\"** 介绍了一种基于Transformer模型的神经网络，该网络能够整合上下文信息来设计拍卖机制。这种方法能够更好地适应动态变化的市场环境和参与者的多样性。\n\n   introduces a neural network based on the Transformer model that integrates contextual information to design auction mechanisms. This approach better adapts to the dynamic market environment and the diversity of participants.\n\n2. **\"Optimal-er Auctions through Attention\"** 则专注于利用注意力机制来改进拍卖设计。通过关注关键的拍卖参数和参与者特征，该研究提出了一种能够自动调整拍卖规则以适应不同场景的算法。\n\n   focuses on improving auction design using attention mechanisms. By focusing on key auction parameters and participant features, the study proposes an algorithm that can automatically adjust auction rules to fit different scenarios.\n\n### with constraints\n\n```latex\n@inproceedings{feng2018deep,\n  title={Deep learning for revenue-optimal auctions with budgets},\n  author={Feng, Zhe and Narasimhan, Harikrishna and Parkes, David C},\n  booktitle={Proceedings of the 17th international conference on autonomous agents and multiagent systems},\n  pages={354--362},\n  year={2018}\n}\n```\n\n\n\n### 4.joint\n\n```latex\n@inproceedings{zhang2024joint,\n  title={Joint Auction in the Online Advertising Market},\n  author={Zhang, Zhen and Li, Weian and Lei, Yahui and Wang, Bingzhe and Zhang, Zhicheng and Qi, Qi and Liu, Qiang and Wang, Xingxing},\n  booktitle={Proceedings of the 30th ACM SIGKDD Conference on Knowledge Discovery and Data Mining},\n  pages={4362--4373},\n  year={2024}\n}\n@article{aggarwal2024selling,\n  title={Selling joint ads: A regret minimization perspective},\n  author={Aggarwal, Gagan and Badanidiyuru, Ashwinkumar and D{\\\"u}tting, Paul and Fusco, Federico},\n  journal={arXiv preprint arXiv:2409.07819},\n  year={2024}\n}\n@inproceedings{ma2024joint,\n  title={Joint Bidding in Ad Auctions},\n  author={Ma, Yuchao and Li, Weian and Zhang, Wanzhi and Lei, Yahui and Zhang, Zhicheng and Qi, Qi and Liu, Qiang and Wang, Xingxing},\n  booktitle={Annual Conference on Theory and Applications of Models of Computation},\n  pages={344--354},\n  year={2024},\n  organization={Springer}\n}\n```\n[Selling joint ads: A regret minimization perspective](https://2010727302.github.io/2024/09/29/Selling-Joint-Ads-A-Regret-Minimization-Perspective/#3-Used-Technology)\n","tags":["paper"]},{"title":"Selling Joint Ads: A Regret Minimization Perspective","url":"/2024/09/29/Selling-Joint-Ads-A-Regret-Minimization-Perspective/","content":"### 1. 研究的问题\n\n这篇论文探讨的核心问题是设计一种收益最大化的激励相容机制，用于在线零售环境中的联合广告销售。具体来说，就是如何将一个广告位（例如）出售给两个不可排除的买家（例如，一个商家和一个品牌），这两个买家可能共同在拍卖中出价以推广一个产品，并且都从广告的展示中获益。该问题涉及到设计一个机制，该机制从两个买家那里收集出价，并决定是否分配广告位以及两个参与方应支付的金额。这个问题引出了复杂的激励相容性约束，例如，如何在两个参与方之间分配付款。\n\n### 2. 研究的对象\n\n研究对象是在线零售领域的广告销售机制，尤其是在涉及两个或多个买家共同对一个非排他性商品（如广告位）出价的场景。论文特别关注了那些在拍卖设计中产生的复杂问题，包括如何在不同的买家之间分割付款，以及如何确保拍卖机制既能最大化收益，又能满足激励相容性和个体理性的要求。\n\n### 3. 使用的技术\n\n论文采用了在线学习视角来解决寻找收益最大化激励相容机制的问题。作者提出了一种高效的学习算法，该算法基于自适应离散化机制空间的方法，因为任何非自适应离散化都无法实现次线性遗憾。在随机设置中（即代理的估值根据某些固定但未知的分布进行抽取），作者设计了一个有效的学习算法，实现了 \\(\\tilde{O}(n^{3/4})\\) 的遗憾界限。而在对抗性设置中（即估值是预先任意生成的），作者利用问题的非Lipschitz性质来证明一个强有力的负面结果，即没有任何学习算法能够实现超过最佳固定机制收益的一半。\n\n此外，论文还考虑了 \\(\\pi\\)-平滑对手设置，即估值随机生成自平滑分布，但与随机情况不同，可以以非平稳方式进行。在这个设置中，作者构建了一个有效的学习算法，实现了 \\(\\tilde{O}(n^{2/3})\\) 的遗憾界限，并基于对数数量级的专家进行简洁编码。最后，作者证明了在随机和平滑设置中，没有任何学习算法能够实现小于 \\(\\Omega(\\sqrt{n})\\) 的遗憾，从而缩小了这两种问题中最小最大遗憾率的范围。\n\n### 1. Research Problem\n\nThe core issue explored in this paper is the design of a revenue-maximizing incentive-compatible mechanism for selling a non-excludable good, such as an advertisement slot, to two cooperative bidders (e.g., a merchant and a brand). This problem captures scenarios where two parties jointly bid in an auction and both benefit from the ad being displayed. The mechanism collects bids from both parties and decides on the allocation and payments. This gives rise to intricate incentive compatibility constraints, such as how to split payments between the two parties. The paper tackles the problem of finding a revenue-maximizing incentive-compatible mechanism from an online learning perspective, which poses significant technical challenges due to the large action space and the highly irregular function mapping mechanisms to revenue.\n\n### 2. Research Object\n\nThe research object is the mechanism design for selling joint advertisements in the online retail sector, specifically focusing on scenarios where multiple bidders are involved in the bidding process for a single, non-excludable item. The paper is particularly concerned with the complexities that arise in auction design, including how to divide payments among different bidders and ensuring that the auction mechanism maximizes revenue while meeting the criteria for incentive compatibility and individual rationality.\n\n### 3. Used Technology\n\nThe paper employs an online learning approach to address the challenge of identifying a revenue-maximizing incentive-compatible mechanism. The authors propose an efficient learning algorithm based on an adaptive discretization scheme of the mechanism space, as any non-adaptive discretization fails to achieve sublinear regret. In the stochastic setting, where agents' valuations are drawn from a fixed but unknown distribution, the algorithm achieves a regret bound of \\(\\tilde{O}(n^{3/4})\\). In the adversarial setting, where valuations are arbitrarily generated upfront, the authors exploit the non-Lipschitzness of the problem to prove a strong negative result, indicating that no learning algorithm can achieve more than half of the revenue of the best fixed mechanism in hindsight. They also consider the \\(\\pi\\)-smooth adversary setting, where valuations are randomly generated from smooth distributions but can be non-stationary. In this setting, they construct an efficient learning algorithm that achieves a regret bound of \\(\\tilde{O}(n^{2/3})\\) and is based on a succinct encoding of exponentially many experts. Finally, they prove that no learning algorithm can achieve less than \\(\\Omega(\\sqrt{n})\\) regret in both the stochastic and the smooth setting, thus narrowing the range where the minimax regret rates for these two problems lie.","tags":["paper"],"categories":["research"]},{"title":"A Context-Integrated Transformer-Based Neural Network for Auction Design","url":"/2024/09/29/A-Context-Integrated-Transformer-Based-Neural-Network-for-Auction-Design/","content":"### 中文版\n\n**研究的问题**：\n这篇论文探讨的核心问题是如何设计一个激励相容的拍卖机制，以最大化拍卖人的预期收益。尽管理论上在单件物品拍卖中已有较为成熟的解决方案，但在多件物品拍卖中，如何设计最优拍卖机制仍然是一个挑战。近年来，深度学习方法在这方面取得了显著进展，但现有研究通常只关注固定数量的竞拍者和物品，或者将拍卖限制为对称形式。本研究通过将竞拍者和物品的公共上下文信息纳入拍卖学习框架，克服了这些限制。\n\n**研究的对象**：\n研究对象是具有上下文信息的拍卖设计，即在拍卖中，每个竞拍者和物品都有相关的上下文信息。这些上下文信息能够在一定程度上描述不同的竞拍者和物品，使得拍卖更接近实际情况。例如，在电子商务广告中，有大量具有各种特征的竞拍者和物品（即广告位），每个拍卖都涉及不同数量的竞拍者和物品。\n\n**使用的技术**：\n论文提出了CITransNet，这是一个基于上下文集成的Transformer神经网络，用于最优拍卖设计。CITransNet结合了出价信息、竞拍者上下文和物品上下文，开发拍卖机制。它建立在Transformer架构上，能够捕捉拍卖中不同竞拍者和物品之间复杂的相互影响。CITransNet在出价和上下文上保持排列等变性，即竞拍者（或物品）在出价信息和竞拍者上下文（或物品上下文）中的任何排列都会导致拍卖结果的相同排列。此外，CITransNet的参数数量不依赖于拍卖规模（即竞拍者和物品的数量），使其有潜力泛化到具有不同竞拍者或物品的各种拍卖中。\n\n### English Version\n\n**Research Problem**:\nThe central problem explored in this paper is how to design an incentive-compatible auction mechanism to maximize the auctioneer's expected revenue. Although theoretical approaches have provided optimal solutions for single-item auctions, designing optimal mechanisms for multi-item auctions remains a challenge. Recently, deep learning methods have made significant progress in this area, but existing studies typically focus on a fixed set of bidders and items or restrict auctions to be symmetric. This study overcomes these limitations by integrating public contextual information of bidders and items into the auction learning framework.\n\n**Research Object**:\nThe research object is auction design with contextual information, where each bidder and item in the auction is equipped with relevant contextual information. This contextual information can describe different bidders and items to some extent, making the auctions closer to practical scenarios. For instance, in e-commerce advertising, there are a large number of bidders and items (i.e., ad slots) with various features, and each auction involves a different number of bidders and items.\n\n**Used Technology**:\nThe paper proposes CITransNet, a Context-Integrated Transformer-based neural network for optimal auction design. CITransNet integrates bidding information, bidder contexts, and item contexts to develop an auction mechanism. It is built upon the Transformer architecture, capturing the complex interplay among different bidders and items in an auction. CITransNet maintains permutation-equivariance over bids and contexts, meaning any permutation of bidders (or items) in the bidding profile and bidder contexts (or item contexts) will cause the same permutation of auction results. Moreover, the number of parameters in CITransNet does not depend on the scale of the auction (i.e., the number of bidders and items), giving CITransNet the potential to generalize to auctions with various bidders or items.","tags":["paper"],"categories":["research"]},{"title":"moni","url":"/2024/09/19/moni/","content":"# 模拟\n\n|      | [273. 整数转换英文表示](https://leetcode.cn/problems/integer-to-english-words/) |      |                                                              | metabit |\n| ---- | ------------------------------------------------------------ | ---- | ------------------------------------------------------------ | ------- |\n|      | [lintcode3656 · 贪吃蛇](https://www.lintcode.com/problem/3656/description)<br />[353. 贪吃蛇](https://leetcode.cn/problems/design-snake-game) |      | [题面](https://blog.csdn.net/ChaoYue_miku/article/details/128391564)<br />类似bfs | 微软    |\n|      | [2578. 最小和分割](https://leetcode.cn/problems/split-with-minimum-sum/) |      | 贪心                                                         | 微软    |\n|      | [6. Z 字形变换](https://leetcode.cn/problems/zigzag-conversion/) |      | [找规律](https://leetcode.cn/problems/zigzag-conversion/solutions/9490/6-z-zi-xing-bian-huan-c-c-by-bian-bian-xiong) |         |\n|      |                                                              |      |                                                              |         |\n|      |                                                              |      |                                                              |         |\n\n[lintcode3656 · 贪吃蛇](https://www.lintcode.com/problem/3656/description)<br />[353. 贪吃蛇](https://leetcode.cn/problems/design-snake-game)\n\n```c++\n#define debug(a) cout<<#a<<\"=\"<<a<<\" \"\nclass SnakeGame {\npublic:\n    int m, n, i = 0, score = 0;\n    int nx = 0, ny = 0;\n    unordered_map<string, vector<int>> dir;\n    vector<vector<int>> foods;\n    deque<pair<int, int>> q;    // 双端队列，存放 <横坐标，纵坐标>\n    set<pair<int,int>> body_set;\n    SnakeGame(int width, int height, vector<vector<int>>& foods) {\n        this->foods = foods;\n        n = width;\n        m = height;\n        dir[\"r\"] = {0,1};\n        dir[\"d\"] = {1,0};\n        dir[\"u\"] = {-1,0};\n        dir[\"l\"] = {0,-1};\n        // cout<<\"nx\"<<nx<<endl;\n        // cout<<\"ny\"<<ny<<endl;\n        q.push_back({0,0});\n        body_set.insert({0,0});\n        \n    }\n\n    /**\n     * @param direction: the direction of the move\n     * @return: the score after the move\n     */\n    int move(string &direction) {\n        // write your code here\n        auto [nx, ny] = q.front();\n        nx += dir[direction][0];\n        ny += dir[direction][1];\n        // cout<<\"nx\"<<nx<<endl;\n        // cout<<\"ny\"<<ny<<endl;\n\n        if(!(nx>=0 && nx<m && ny>=0 && ny<n)) return -1;//出界\n        if(i<foods.size()&&nx==foods[i][0]&&ny==foods[i][1])//吃到食物\n        {\n            i++;\n            score++;\n            //队尾不用出队\n        }\n        else//没吃到\n        {\n            pair<int,int> tail = q.back();\n            body_set.erase(tail);//删除尾巴\n            q.pop_back();//删除尾巴\n            if(body_set.count({nx,ny}))return -1;\n        }\n        q.push_front({nx, ny});    // 将新坐标添加到队头\n        body_set.insert({nx, ny});\n        return score;\n    }\n};\n```\n\n","tags":["加密文章tag"],"categories":["Algorithm"]},{"title":"template3","url":"/2024/09/19/template3/","content":"\n## 背包dp\n\n### 2. 01背包&完全背包\n\n```c++\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>v[i]>>w[i];\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=m;j>=v[i];j--)\n        //for(int j=v[i];j<=m;j++)完全\n\t\t{\n\t\t\tdp[j]=max(dp[j],dp[j-v[i]]+w[i]);\n\t\t}\n\t}\n\tcout<<dp[m]<<endl;\n}\n```\n\n### 5.多重背包\n\n#### 写法一：\n\n```c++\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>a>>b>>s;\n\t\tint k=1;\n\t\twhile(s>=k)//1,2,4,8...c\n\t\t{\n\t\t\tcnt++;\n\t\t\tv[cnt]=a*k;\n\t\t\tw[cnt]=b*k;\n\t\t\ts-=k;\n\t\t\tk*=2;\n\t\t}\n\t\tif(s>0)//remain c c+2^(k-1)=s\n\t\t{\n\t\t\tcnt++;\n\t\t\tv[cnt]=a*s;\n\t\t\tw[cnt]=b*s;\n\t\t}\n\t}\n\tn=cnt;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=m;j>=v[i];j--)\n\t\t{\n\t\t\tdp[j]=max(dp[j],dp[j-v[i]]+w[i]);\n\t\t}\n\t}\n\tcout<<dp[m]<<endl;\n}\n```\n\n#### 写法二：\n\n```c++\nint main()\n{\n    cin>>n>>m;\n    vector<good> Good;\n    good tmp;\n    //二进制处理\n    for(int i = 1 ; i <= n ; i++ )\n    {\n        int v,w,s;\n        cin>>v>>w>>s;\n        //坑,k <= s\n        for(int k = 1 ; k <= s ; k*=2 )\n        {\n            s-=k;\n            Good.push_back({k*w,k*v});\n        }\n        if(s>0) Good.push_back({s*w,s*v});\n    }\n    //01背包优化+二进制\n    for(auto t : Good)\n        for(int j = m ; j >= t.v ; j--)\n            f[j] = max(f[j] , f[j-t.v]+t.w ); //这里就是f[j]\n    cout<<f[m]<<endl;\n    return 0;\n}\n```\n\n### 9.分组背包\n\n```c++\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=m;j>=0;j--)\n\t\t{\n\t\t\tfor(int k=0;k<s[i];k++)//第i组中选哪个物品 \n\t\t\t\tif(j>=v[i][k])\n\t\t\t\t\tdp[j]=max(dp[j],dp[j-v[i][k]]+w[i][k]);\n\t\t}\n\t}\n```\n\n## 线性DP\n\n### 898. 数字三角形\n\n#### 写法一\n\n```c++\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=i;j++)\n\t\t{\n\t\t\tcin>>tr[i][j];\n\t\t}\n\t\t\n\t}\n\tmemset(dp,-0x3f,sizeof(dp));\n\tdp[1][1]=tr[1][1];\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tfor(int j=i;j>=1;j--)\n\t\t{\t\n\t\t\tdp[i][j]=max(dp[i-1][j],dp[i-1][j-1])+tr[i][j];\n\t\t\t//if(i==2)cout<<dp[i-1][j]<<\" \"<< dp[i-1][j-1];\n\t\t\t//cout<<dp[i][j]<<\" \";\n\t\t}\n\t//\tcout<<endl;\n\t}\n\tint res=-INF;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tres=max(res,dp[n][i]);\n\t}\n\tcout<<res<<endl;\n}\n```\n\n#### 写法二\n\n```c++\n\tdp[1]=tr[1][1];\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tfor(int j=i;j>=1;j--)\n\t\t{\n\t\t\t\n\t\t\tdp[j]=max(dp[j],dp[j-1])+tr[i][j];\n\t\t\t//if(i==2)cout<<dp[i-1][j]<<\" \"<< dp[i-1][j-1];\n\t\t\t//cout<<dp[i][j]<<\" \";\n\t\t}\n\t//\tcout<<endl;\n\t}\n\tint res=-INF;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tres=max(res,dp[i]);\n\t}\n\tcout<<res<<endl;\n```\n\n#### 写法三\n\n```c++\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=i;j++)\n\t\t{\n\t\t\tcin>>tr[i][j];\n\t\t\tif(i==n)\n\t\t\t{\n\t\t\t\tdp[j]=tr[i][j];\n\t\t\t}\n\t\t}\n\t}\n\t//memset(dp,-0x3f,sizeof(dp));\n\tfor(int i=n-1;i>=1;i--)\n\t{\n\t\tfor(int j=1;j<=i;j++)\n\t\t{\n\t\t\tdp[j]=max(dp[j],dp[j+1])+tr[i][j];\n\t\t\t//cout<<dp[j]<<\" \";\n\t\t}\n\t\t//cout<<endl;\n\t}\n\tcout<<dp[1]<<endl;\n}\n```\n\n### 895. 最长上升子序列\n\n```c++\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdp[i]=1;//一个数的时候\n\t\tfor(int j=1;j<i;j++)\n\t\t{\n\t\t\tif(a[j]<a[i])\n\t\t\t{\n\t\t\t\tdp[i]=max(dp[i],dp[j]+1);\n\t\t\t}\n\t\t\t\n\t\t} \n\t\tans=max(dp[i],ans)\t;\n\t}\n```\n\n#### 优化版\n\n```c++\n\tdp.push_back(a[1]);\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(a[i]>dp.back())\n\t\t{\n\t\t    dp.push_back(a[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t    auto itr=lower_bound(dp.begin(),dp.end(),a[i]);\n\t\t    *itr=a[i];\n\t\t}\n\t}\n\tcout<<dp.size()<<endl;\n```\n\n#### 优化版2\n\n```c++\n\tvector<int>stk;\n\tstk.push_back(a[1]);\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(a[i]>stk.back())//如果该元素大于栈顶元素,将该元素入栈\n\t\t{\n\t\t\tstk.push_back(a[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\n\t\t\t//返回数组中第一个大于或等于被查数的值 \n\t\t\t*lower_bound(stk.begin(), stk.end(), a[i])=a[i];\n\t\t}\n\t}\n\tcout<<stk.size()<<endl;\n```\n\n#### 优化版3\n\n```c++\ninline int find(int x) \n{\n    int l = 1, r = cnt; \n    while(l < r) \n\t{\n        int mid = l + r >> 1;\n        if(dp[mid] >= x) r = mid;\n        else l = mid + 1;\n    }\n\n    return l;\n}\n\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tdp[++cnt]=a[1];\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(a[i]>dp[cnt])\n\t\t{\n\t\t\tdp[++cnt]=a[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint pos=find(a[i]);\n\t\t\tdp[pos]=a[i];\n\t\t}\n\t}\n\tcout<<cnt<<endl;\n\treturn 0;\n}\n```\n\n#### 优化版4\n\n```c++\n#include<bits/stdc++.h>\n#define debug(a) cout<<#a<<\"=\"<<a<<endl\n#define ll long long\nusing namespace std;\nconst int INF=100086;\nvector<int>dp;\nint a[INF],ans=1,n=0;\nint check(int mid,int target)\n{\n\tif(dp[mid]<target)return 1;\n\telse return 0;\n}\nint find(int l, int r,int target)\n{\n\twhile(l+1<r)\n\t{\n\t\tint mid=l+((r-l)>>1);\n//\t\tcout<<a[mid]<<\"mid \";\n\t\tif(check(mid,target))l=mid;\n\t\telse\n\t\t{\n\t\t\tr=mid;\n\t\t}\n\t}\n//\tcout<<a[r]<<\"r \";\n\treturn r;\n}\t\t\t\t\t\t\nint main() \n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tdp.push_back(a[0]);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(a[i]>dp.back())\n\t\t{\n\t\t\tdp.push_back(a[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint pos=find(-1,dp.size(),a[i]);\n\t\t\tdp[pos]=a[i];\n//\t\t\tcout<<pos<<\" :\";\n\t\t}\n\t}\n\tcout<<dp.size()<<endl;\n    return 0;\n}\n\n```\n\n\n\n### 897. 最长公共子序列\n\n```c++\nchar a[N],b[N];\nint ans=0,n=0,m=0,cnt=0;\nint main()\n{\n\tcin>>n>>m;\n\tcin>>a+1>>b+1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tdp[i][j]=max(dp[i][j-1],dp[i-1][j]);\n\n\t\t\tif(a[i]==b[j])\n\t\t\tdp[i][j]=max(dp[i][j],dp[i-1][j-1]+1);\n\t\t\t\n\t\t}\n\t}\n\tcout<<dp[n][m]<<endl;\n\treturn 0;\n}\n```\n\n### 最大连续子序列和\n\n#### [KY63 最大子矩阵](https://www.nowcoder.com/practice/a5a0b05f0505406ca837a3a76a5419b3?tpId=61&tqId=29535&tPage=2&ru=/kaoyan/retest/1002&qru=/ta/pku-kaoyan/question-ranking)\n\n```c++\nint ma[N][N],dp[N];\nint main() \n{\n\twhile(cin>>n)\n\t{\n\t\t// cout<<r<<endl;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tcin>>ma[i][j];\n//\t\t\t\tcout<<ma[i][j]<<\" \";\n\t\t\t}\n\t\t}\n\t\tint maxx=INT_MIN;\n\t\tfor(int i=0;i<n;i++)//开始下标i\n\t\t{\n\t\t\tmemset(sum,0,sizeof(sum));\n\t\t\tfor(int j=i;j<n;j++)//结束下标j\n\t\t\t{\n\t\t\t\tint d=-32767;\n\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t{\n\t\t\t\t\tsum[k]+=ma[k][j];\n\t\t\t\t\td=max(d+sum[k],sum[k]);\n\t\t\t\t\tmaxx=max(maxx,d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<maxx<<endl;\n\t}\n    return 0;\n}   \n```\n\n#### [KY141 最大连续子序列](https://www.nowcoder.com/practice/afe7c043f0644f60af98a0fba61af8e7?tpId=63&tqId=29588&tPage=2&ru=/kaoyan/retest/9001&qru=/ta/zju-kaoyan/question-ranking)\n\n[【图解】不需要倒推就能找到开始下标的方法，一次遍历_牛客博客 (nowcoder.net)](https://blog.nowcoder.net/n/b7218d98c90c4380871d485bfdf8c47a)\n\n```c++\nlong long dp[N];\nint flag;\nint n;\nint main() \n{\n    \n\twhile(cin>>n)\n    {\n        if(n==0)break;\n        flag=0;\n        for(int i=0;i<n;i++)\n        {\n            cin>>b[i];\n            if(b[i]>=0)flag=1;\n            a[i]=b[i];\n        }\n        if(!flag)\n        {\n            cout<<0<<\" \"<<b[0]<<\" \"<<b[n-1]<<endl;\n            continue;\n        }\n        res=a[0];\n        int left=0,right=0,t=0;\n        for(int i=1;i<n;i++)\n        {\n            if(a[i]+a[i-1]<a[i])// 新起一段序列\n            {\n                t=i;\n            }\n            else \n            {\n                a[i]=a[i]+a[i-1];\n            }\n            if(res<a[i])\n            {\n                res=a[i];\n                left=t;\n                right=i;\n            }\n            // cout<<res<<\" \"<<a[i]<<left<<\" \"<<right<<endl;\n        }\n        cout<<res<<\" \"<<b[left]<<\" \"<<b[right]<<endl;\n    }\n    return 0;\n}\n```\n\n##### 贪心\n\n```c++\n#include <bits/stdc++.h>\n#include <climits>\nusing namespace std;\nconst int N = 1e6+10;  \nlong long res=-1;\nlong long a[N],b[N];\nlong long dp[N];\nint flag;\nint n;\nint main() \n{\n    \n\twhile(cin>>n)\n    {\n        if(n==0)break;\n        flag=0;\n        for(int i=0;i<n;i++)\n        {\n            cin>>b[i];\n            if(b[i]>=0)flag=1;\n            a[i]=b[i];\n        }\n        if(!flag)\n        {\n            cout<<0<<\" \"<<b[0]<<\" \"<<b[n-1]<<endl;\n            continue;\n        }\n        res=-INT_MAX;\n        int left=0,right=0,t=0;\n        int sum=0;   \n        for(int i=0;i<n;i++)\n        {\n            sum+=a[i];\n            if(res<sum)\n            {\n                res=sum;\n                left=t;\n                right=i;\n                // cout<<sum<<\",\"<<i<<endl;\n            }\n            if(sum<0)\n            {\n                sum=0;\n                t=i+1;\n                // cout<<sum<<\" \"<<i<<endl;\n            } \n            \n            // cout<<res<<\" \"<<a[i]<<left<<\" \"<<right<<endl;\n        }\n        cout<<res<<\" \"<<b[left]<<\" \"<<b[right]<<endl;\n    }\n    return 0;\n}\n```\n\n#### 变式\n\n进阶版：[求该数组中2个不重叠的连续子数组之和的最大值](https://blog.csdn.net/grllery/article/details/89159989)\n\n```c++\nint max2Sum(vector<int>& nums) {\n\tint n = nums.size();\n\tif (n == 0) return -1;\n\t\n\tvector<int> left(n), right(n), dp(n);\n\tdp[0] = nums[0], left[0] = dp[0];\n\tfor (int i = 1; i < n; ++i) {\n\t\tdp[i] = max(0, dp[i - 1]) + nums[i];\n\t\tleft[i] = max(left[i - 1], dp[i]);\n\t}\n\n\tdp[n - 1] = nums.back();\n\tright[n - 1] = dp[n - 1];\n\tfor (int i = n - 2; i >= 0; --i) {\n\t\tdp[i] = max(0, dp[i + 1]) + nums[i];\n\t\tright[i] = max(right[i + 1], dp[i]);\n\t}\n\n\tint res = INT_MIN;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint sum = left[i] + right[i + 1];\n\t\tres = max(res, sum);\n\t}\n\treturn res;\n}\n\n```\n\n方法是从左到右和从右到左各扫描一遍，时间复杂度O(n) <br />终极版：[求该数组中k个不重叠的连续子数组之和的最大值](https://verytoolz.com/blog/91600c813a/#:~:text=%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E5%80%BC%20k%EF%BC%8C%E6%89%BE%E5%87%BA%20k%20%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%8F%A0%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%9C%89%20k%20%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%92%8C%E3%80%82%20%E4%BE%8B%E5%AD%90%EF%BC%9A%20Input,sum1%3A%208%2C%20starting%20index%3A%206%2C%20ending%20index%3A%207.)。要求时间复杂度最低，因此不可用递归，因此采用DP。时间复杂度O(nk)，网上可以找到答案，但这些答案的空间复杂度是O(nk)，面试官要求降低到O(k)\n\n### 902. 最短编辑距离 & 899. 编辑距离\n\n```c++\nint editd(char a[],char b[])\n{\n\tint n=strlen(a+1);//\n\tint m=strlen(b+1);// \n\t//memset(dp,0,sizeof(dp));\n\t for(int i=1;i<=n;i++)\n    {\n        dp[i][0]=i;\n    }\n    for(int j=1;j<=m;j++)\n    {\n        dp[0][j]=j;\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)\n        {\n\n            if(a[i]==b[j])\n                dp[i][j]=dp[i-1][j-1];\n            else\n            {\n                dp[i][j]=min(min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1])+1;\n            }\n        }\n    }\n\treturn dp[n][m];\n } \nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i]+1;\n\t}\n\twhile(m--)\n\t{\n\t\tchar b[N];\n\t\tcin>>b+1>>lim;\n\t\tans=0;\n\t\t\n\t\tfor(int k=0;k<n;k++)\n\t\t{\n\t\t\t\n\t\t\tif(editd(a[k],b)<=lim)ans++;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\t\n\treturn 0;\n}\n```\n\n\n\n## 区间DP \n\n### 282. 石子合并\n\n```c++\n\tfor(int i=1;i<=n;i++)\n    {\n    \tcin>>a[i];\n    \ta[i]+=a[i-1];\n\t}\n    for(int len=2;len<=n;len++)\n    {\n    \tfor(int i=1;i+len-1<=n;i++)\n    \t{\n    \t\tint j=i+len-1;\n    \t\tdp[i][j]=inf;\n    \t\tfor(int k=i;k<j;k++)\n    \t\t{\n    \t\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+a[j]-a[i-1]);\n\t\t\t}\n\t\t}\n\t}\n    cout<<dp[1][n]<<endl;\n```\n\n## 计数类DP\n\n### 900. 整数划分\n\n```c++\n\tfor(int i=0;i<=n;i++)\n    {\n        dp[i][0]=1;\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=0;j<=n;j++)\n        {\n            dp[i][j]=dp[i-1][j]%mod;\n            if(j-i>=0)\n            {\n                dp[i][j]=(dp[i-1][j]+dp[i][j-i])%mod;\n            }\n        }\n    }\n    cout<<dp[n][n]<<endl;\n```\n\n```c++\n \tdp[0]=1;\n\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=i;j<=n;j++)\n        {\n            dp[j]=(dp[j]+dp[j-i])%mod;\n\n        }\n    }\n    cout<<dp[n]<<endl;\n```\n\n## 数位统计DP\n\n### 338. 计数问题\n\n```c++\nconst int N = 11; //位数\n\nint f[N][N][10];// f[a][b]表示从a个数中选b个数的方案数，即组合数\n\nint K, B; //K是能用的1的个数，B是B进制\n\n//求组合数：预处理\nvoid init()\n{\n\tfor(int i=0;i<=9;i++)\n\t{\n\t\tf[1][i][i]=1;\n\t}\n\tfor(int i=2;i<N;i++)\n\t{\n\t\tfor(int j=0;j<=9;j++)\n\t\t{\n\t\t\tfor(int u=0;u<=9;u++)\n\t\t\t{\n\t\t\t\tif(j==u)f[i][j][u]+=pow(10,i-1);\n\t\t\t\tfor(int k=0;k<=9;k++)\n\t\t\t\t{\n\t\t\t\t\tf[i][j][u]+=f[i-1][k][u];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dp(int n,int u)\n{\n    if(n == 0) return u?0:1; //如果上界n是0，直接就是0种\n    vector<int> nums; //存放n在B进制下的每一位\n    B=10;\n    while(n) nums.push_back( n% B) , n/= B;\n    int ans = 0;\n    int last = 0; \n    cout<<n<<endl;\n    for(int i = nums.size()-1; i>= 0; i--)\n    {\n        int x = nums[i]; //取当前位上的数\n\t\tfor(int j=(i==nums.size()-1);j<x;j++)\n\t\t{\n\t\t\tans+=f[i+1][j][u];\n\t\t}\n\t\tans+=x*last*pow(10,i);\n\t\tif(x==u)last++;\n\t\tif(!i)ans+=last;\n\t\tcout<<i<<\":\"<<last<<\"endl\"<<endl;\n    }\n\tfor(int i=1;i<nums.size();i++)\n\t{\n\t\tfor(int j=1;j<=9;j++)\n\t\t{\n\t\t\tans+=f[i][j][u];\n\t\t}\n\t}\n\tif(!u)ans+=f[1][u][u];\n    return ans;\n}\n\nint main()\n{\n    init();\n    int l,r;\n    while(cin >>  l >> r)\n    {\n    \tif(l==0&&r==0)break;\n    \tif(l>r)swap(l,r);\n    \tfor(int i=0;i<=9;i++)\n    \t{\n    \t\tcout<< dp(r,i) - dp(l-1,i) <<\" \"; \n\t\t}\n    \tcout<<endl;\n\t}\n    return 0;\n}\n\n```\n\n## 状态压缩DP\n\n### 291. 蒙德里安的梦想\n\n```c++\n/*\n下文对  if ((j & k ) == 0 && st[ j | k] )  有清晰的解释！！！\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 12, M = 1<< N;  \nlong long f[N][M] ;// 第一维表示列， 第二维表示所有可能的状态\nbool st[M];  //存储每种状态是否有奇数个连续的0，如果奇数个0是无效状态，如果是偶数个零置为true。\n//vector<int > state[M];  //二维数组记录合法的状态\nvector<vector<int>> state(M);  //两种写法等价:二维数组\n\nint m, n;\n\nint main() \n{\n\n    while (cin >> n >> m, n || m) \n    { //读入n和m，并且不是两个0即合法输入就继续读入\n\n        //第一部分：预处理1\n        //对于每种状态，先预处理每列不能有奇数个连续的0\n\n        for(int i = 0; i < (1 << n); i ++) \n        {\n\n            int cnt = 0 ;//记录连续的0的个数\n\n            bool isValid = true; // 某种状态没有奇数个连续的0则标记为true\n\n            for(int j = 0; j < n; j ++) \n            { //遍历这一列，从上到下\n\n                 if ( (i >> j) & 1) \n                 {  \n                     //i >> j位运算，表示i（i在此处是一种状态）的二进制数的第j位； \n                     // &1为判断该位是否为1，如果为1进入if\n                    if (cnt & 1) \n                    { \n                    //这一位为1，看前面连续的0的个数，如果是奇数（cnt &1为真）则该状态不合法\n                        isValid =false; break;\n                    } \n\n                    cnt = 0; // 既然该位是1，并且前面不是奇数个0（经过上面的if判断），计数器清零。\n                    //其实清不清零没有影响\n                 }\n                 else cnt ++; //否则的话该位还是0，则统计连续0的计数器++。\n            }\n            if (cnt & 1)  isValid = false; //最下面的那一段判断一下连续的0的个数\n\n            st[i]  = isValid; //状态i是否有奇数个连续的0的情况,输入到数组st中\n        }\n\n        //第二部分：预处理2\n        // 经过上面每种状态 连续0的判断，已经筛掉一些状态。\n        //下面来看进一步的判断：看第i-2列伸出来的和第i-1列伸出去的是否冲突\n\n        for (int j = 0; j < (1 << n); j ++) \n        { //对于第i列的所有状态\n            state[j].clear(); //清空上次操作遗留的状态，防止影响本次状态。\n\n            for (int k = 0; k < (1 << n); k ++) \n            { //对于第i-1列所有状态\n                if ((j & k ) == 0 && st[ j | k]) \n                // 第i-2列伸出来的 和第i-1列伸出来的不冲突(不在同一行) \n                //解释一下st[j | k] \n                //已经知道st[]数组表示的是这一列没有连续奇数个0的情况，\n                //我们要考虑的是第i-1列（第i-1列是这里的主体）中从第i-2列横插过来的，\n                //还要考虑自己这一列（i-1列）横插到第i列的\n                //比如 第i-2列插过来的是k=10101，第i-1列插出去到第i列的是 j =01000，\n                //那么合在第i-1列，到底有多少个1呢？\n                //自然想到的就是这两个操作共同的结果：两个状态或。 j | k = 01000 | 10101 = 11101\n                //这个 j|k 就是当前 第i-1列的到底有几个1，即哪几行是横着放格子的\n\n                    state[j].push_back(k);  \n                    //二维数组state[j]表示第j行， \n                    //j表示 第i列“真正”可行的状态，\n                    //如果第i-1列的状态k和j不冲突则压入state数组中的第j行。\n                    //“真正”可行是指：既没有前后两列伸进伸出的冲突；又没有连续奇数个0。\n            }\n        }\n\n        //第三部分：dp开始\n        memset(f, 0, sizeof f);  \n        //全部初始化为0，因为是连续读入，这里是一个清空操作。\n        //类似上面的state[j].clear()\n        f[0][0] = 1 ;// 这里需要回忆状态表示的定义\n        //按定义这里是：前第-1列都摆好，且从-1列到第0列伸出来的状态为0的方案数。\n        //首先，这里没有-1列，最少也是0列。\n        //其次，没有伸出来，即没有横着摆的。即这里第0列只有竖着摆这1种状态。\n\n        for (int i = 1; i <= m; i ++) \n        { //遍历每一列:第i列合法范围是(0~m-1列)\n            for (int j = 0; j < (1<<n); j ++) \n            {  //遍历当前列（第i列）所有状态j\n                for (auto k : state[j])    // 遍历第i-1列的状态k，如果“真正”可行，就转移\n                    f[i][j] += f[i-1][k];    // 当前列的方案数就等于之前的第i-1列所有状态k的累加。\n            }\n        }\n        //最后答案是什么呢？\n        //f[m][0]表示 前m-1列都处理完，并且第m-1列没有伸出来的所有方案数。\n        //即整个棋盘处理完的方案数\n        cout << f[m][0] << endl;\n    }\n}   \n\n```\n\n### 91. 最短Hamilton路径\n\n```c++\n/*\n下文对  if ((j & k ) == 0 && st[ j | k] )  有清晰的解释！！！\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 20, M = 1<< N;  \nlong long f[M][N] ;\nint w[N][N];\nint m, n;\nint main() \n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tcin>>w[i][j];\n\t\t}\n\t}\n\tmemset(f,0x3f,sizeof(f));\n\tf[1][0]=0;\n\tfor(int i=0;i<(1<<n);i++)//i表示所有的情况\n\t{\n\t\tfor(int j=0;j<n;j++)//j表示走到哪一个点\n\t\t{\n\t\t\tif(i>>j&1)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<n;k++)//k表示走到j这个点之前,以k为终点的最短距离\n\t\t\t\t{\n\t\t\t\t\tif(i>>k&1)\n\t\t\t\t\t{\n\t\t\t\t\t\tf[i][j]=min(f[i][j],f[i-(1<<j)][k]+w[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f[(1<<n)-1][n-1]<<endl;\n\t//表示所有点都走过了,且终点是n-1的最短距离\n    //位运算的优先级低于'+'-'所以有必要的情况下要打括号\n    return 0;\n}   \n```\n\n## 树形DP\n\n### 285. 没有上司的舞会\n\n```c++\nint f[N][2],idx;\nint h[N],e[N],ne[N],happy[N];\nint m, n;\nint st[N];\nvector<int> edge[6010];\nvoid add(int a,int b)\n{ //把a插入树中\n    e[idx] = b,ne[idx] = h[a],h[a] = idx ++;\n}\nvoid dfs(int u)\n{\n\tf[u][1]=happy[u];\n\tfor(int i=0;i<edge[u].size();i++)\n\t{\n\t\tint j=edge[u][i];\n\t\tdfs(j);\n\t\tf[u][0]+=max(f[j][1],f[j][0]);\n\t\tf[u][1]+=f[j][0];\n\t}\n}\nint main() \n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)cin>>happy[i];\n//\tmemset(h,-1,sizeof(h));\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a=0,b=0;\n\t\tcin>>a>>b;\n\t\tst[a]=1;\n\t\tedge[b].push_back(a);\n\t} \n\tint root=1;\n\twhile(st[root])root++;\n//\tcout<<root<<endl;\n\tdfs(root);\n\tcout<<max(f[root][0],f[root][1])<<endl;\n    return 0;\n}   \n```\n\n### 1074.树的最长路径\n\n[题解](https://www.acwing.com/solution/content/29832/)\n\n```c++\n#include<bits/stdc++.h>\n#define debug(a) cout<<#a<<\"=\"<<a<<endl\n#define ll long long\nusing namespace std;\nconst int N=1e6+10; \nconst ll INF=2E18;\nint n,sz,ai,m;\nstruct node\n{\n\tint e;\n\tint w;\n};\nint ans;\nvector<node>edge[N];\nint dfs(int u,int father)\n{\n\tint dist=0;\n\tint d1=0,d2=0;\n\tfor(int i=0;i<edge[u].size();i++)\n\t{\n\t\tint j=edge[u][i].e,w=edge[u][i].w;\n\t\tif(j==father) continue;\n\t\tint d=dfs(j,u) + w;\n\t\tdist=max(dist,d);//求f[x]的最大值\n\t\t//d1,d2求出以该点为顶点的最长路径\n\t\tif(d>=d1)d2=d1,d1=d;\n\t\telse if(d2<d)d2=d;\n\t\t//d1,d2求出以该点为顶点的最长路径\n\t}\n\tans=max(ans,d1+d2);\n\treturn dist;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tedge[a].push_back({b,c});\n\t\tedge[b].push_back({a,c});\n\t}\n\tdfs(1,-1);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n```\n\n\n\n## 记忆化搜索\n\n### 901. 滑雪\n\n### [329. 矩阵中的最长递增路径](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/)\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 310;  \nint dp[N][N],idx;\nint r,c;\nint res=0;\nint ma[N][N];\nint dir[4][2]={{-1,0},{0,-1},{1,0},{0,1}};\nint dfs(int x,int y)\n{\n\tint &v = dp[x][y];\n\tif(v!=-1)return v;\n\tv=1;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tint dx=x+dir[i][0];\n\t\tint dy=y+dir[i][1];\n\t\tif(dx>=0&&dy>=0&&dx<r&&dy<c&&ma[x][y]>ma[dx][dy])\n\t\t{\n\t\t\tv=max(dfs(dx,dy)+1,v);\n\t\t}\n\t}\n//\tcout<<x<<\" \"<<y<<\":\"<<dp[x][y]<<endl;\n\treturn v;\n}\nint main() \n{\n\tcin>>r>>c;\n\tfor(int i=0;i<r;i++)\n\t{\n\t\tfor(int j=0;j<c;j++)\n\t\t{\n\t\t\tcin>>ma[i][j];\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tfor(int i=0;i<r;i++)\n\t{\n\t\tfor(int j=0;j<c;j++)\n\t\t{\n//\t\t\tcout<<i<<\",\"<<j<<endl;\n\t\t\tres=max(res,dfs(i,j));\n\t\t}\n\t}\n\tcout<<res<<endl;\n    return 0;\n}   \n```\n\n### [3180. 执行操作可获得的最大总奖励 I](https://leetcode.cn/problems/maximum-total-reward-using-operations-i/)\n\n```c++\nclass Solution {\npublic:\n    unordered_map<int, int> dp; \n    vector<int> rewardValues;\n    int dfs(int cur)\n    {\n        if(dp.count(cur))return dp[cur];\n        int res=0;\n        for(auto x:rewardValues)\n        {\n            if(cur<x)res=max(res,dfs(cur+x)+x);\n        }\n        dp[cur]=res;\n        return res;\n    }\n    int maxTotalReward(vector<int>& _rewardValues) {\n        sort(_rewardValues.begin(), _rewardValues.end());\n        rewardValues=_rewardValues;\n        return dfs(0);\n    }\n};\n```\n\n### [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)\n\n记忆化解法\n\n```c++\nclass Solution {\npublic:\n    unordered_map<int, int> dp; \n    vector<int> nums;\n    int dfs(int i)\n    {\n        if(!i)return 1;\n        if(dp.count(i))return dp[i];\n        int res=0;\n        for(int x:nums)\n        {\n            if(x<=i)res+=dfs(i-x);\n        }\n        dp[i]=res;\n        return res;\n    }\n    int combinationSum4(vector<int>& nums, int target) {\n        \n        this->nums=nums;\n        return dfs(target);\n    }\n};\n```\n\n\n\n## 其他问题\n\n### KY8 整数拆分\n\n#### 法1：\n\n```c++\n\tdp[0]=1;\n    while(cin>>n)\n    {\n        for(int i=1;i<=n;i++)\n        {\n            if(i%2==0)\n            {\n                dp[i]=(dp[i-1]+dp[i/2])%mod;\n            }\n            else\n            {\n                dp[i]=dp[i-1]%mod;\n            }\n        }\n        cout<<dp[n]<<endl;\n    }\n    return 0;\n```\n\n#### 法2：\n\n```c++\n\tdp[0]=1;\n    // f[i][j] = f[i-1][j] + f[i][j-a[i]]\n    for(int i=1;i<=n;i*=2)\n    {\n        for(int j=i;j<=n;j++)\n        {\n            dp[j]=(dp[j]+dp[j-i])%mod;\n        }\n    }\n    cout<<dp[n]<<endl;\n```\n\n### KY41 放苹果\n\n#### 法1：\n\n```c++\n        dp[0]=1;\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=i;j<=m;j++)\n            {\n                dp[j]=dp[j]+dp[j-i];\n                // cout<<dp[j]<<\" \"<<j<<endl;\n            }\n            // cout<<endl;\n        }\n        cout<<dp[m]<<endl;\n```\n\n#### 法2：\n\n```c++\n\t\tdp[0][0]=1;\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=0;j<=m;j++)\n            {\n                if(j>=i)dp[i][j]=dp[i-1][j]+dp[i][j-i];\n                else\n                {\n                    dp[i][j]=dp[i-1][j];\n                }\n            }\n        }\n        cout<<dp[n][m]<<endl;\n```\n\n## 区间问题\n\n### 905. 区间选点 & 908. 最大不相交区间数量\n\n1. 将每个区间按照右端点从小到大进行排序\n\n2. 从前往后枚举区间，end值初始化为无穷小\n\n\n​\t\t\t如果本次区间不能覆盖掉上次区间的右端点， ed < range[i].l\n\n​\t\t\t说明需要选择一个新的点， res ++ ; ed = range[i].r;\n\n<img src=\"D:\\wyh\\大学\\信息\\acwing\\AcWing 905. 区间选点 - AcWing_files\\652_632882e016-image_19.png\" style=\"zoom:50%;\" />\n$$\n时间复杂度：O(nlogn)\n$$\n\n```c++\nstruct Range\n{\n    int l, r;\n    bool operator< (const Range &W)const\n    {\n        return r < W.r;\n    }\n}range[N];\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i ++ ) scanf(\"%d%d\", &range[i].l, &range[i].r);\n\n    sort(range, range + n);\n\n    int res = 0, ed = -2e9;\n    for (int i = 0; i < n; i ++ )\n        if (ed < range[i].l)\n        {\n            res ++ ;\n            ed = range[i].r;\n        }\n\n    printf(\"%d\\n\", res);\n\n    return 0;\n}\n```\n\n### 906. 区间分组 ([会议室 II](https://www.lintcode.com/problem/919/description))\n\n从前往后枚举每个区间，判断此区间能否将其放到现有的组中\n\n1. 如果一个区间的左端点比最小组的右端点要小，ranges[i].l<=heap.top() ， 就开一个新组 heap.push(range[i].r);\n\n2. 如果一个区间的左端点比最小组的右端点要大，则放在该组， heap.pop(), heap.push(range[i].r);\n\n\n每组去除右端点最小的区间，只保留一个右端点较大的区间，这样heap有多少区间，就有多少组。\n\n区间分组，在组内区间不相交的前提下，分成尽可能少的组。\n而不是尽可能多的组，因为一个区间一组，就是尽可能多组的答案。\n等效于把尽可能多的区间塞进同一组，要满足range[i].l > heap.top。\nheap 存储的是每个组的最右的端点，由于是小根堆heap.top()是对应的最小的最右点。\n\n那如果遇到，塞不进去的情况呢？\n就是heap.top >= range[i].l, 当前区间的左端点比最小的右端点还要小，放到任何一组都会有相交部分。\n那就需要新开一组，heap.push(range[i].r).\n\n1. 把所有区间按照左端点从小到大排序\n\n2. 从前往后枚举每个区间，判断此区间能否将其放到现有的组中\n\n3. heap有多少区间，就有多少组\n\n\n```c++\n static bool cmp(const Interval& a, const Interval& b)\n    {\n        if (a.start != b.start) \n        {\n            return a.start < b.start;\n        } \n        else \n        {\n            return a.end < b.end;\n        }\n    }\n int minMeetingRooms(vector<Interval> &intervals) \n {\n        // Write your code here\n        sort(intervals.begin(),intervals.end(),cmp);\n        priority_queue<int, vector<int>, greater<int>> heap;\n        for(auto interval:intervals)\n        {\n            if (heap.empty() || heap.top() > interval.start)\n            {\n                heap.push(interval.end);\n            }\n            else \n            {\n                heap.pop();\n                heap.push(interval.end);\n            }\n        }\n        return heap.size();\n    }\n```\n\n### 907. 区间覆盖([lc56. 合并区间](https://leetcode.cn/problems/merge-intervals/))\n\n1. 将所有区间按照左端点从小到大进行排序\n\n2. 从前往后枚举每个区间，在所有能覆盖start的区间中，选择右端点的最大区间，然后将start更新成右端点的最大值\n\n```c++\nsort(range, range + n);\n\n    int res = 0;\n    bool success = false;\n    for (int i = 0; i < n; i ++ )\n    {\n        int j = i, r = -2e9;\n        while (j < n && range[j].l <= st)\n        {\n            r = max(r, range[j].r);\n            j ++ ;\n        }\n\n        if (r < st)\n        {\n            res = -1;\n            break;\n        }\n\n        res ++ ;\n        if (r >= ed)\n        {\n            success = true;\n            break;\n        }\n\n        st = r;\n        i = j - 1; \n    }\n\n    if (!success) res = -1;\n    printf(\"%d\\n\", res);\n```\n\n## Huffman树\n\n### 148. 合并果子\n\n```c++\n\t\tpriority_queue<int,vector<int>,greater<int>> q;\n        int res=0;\n        for(int i=0;i<n;i++)\n        {\n            int tmp=0;\n            cin>>tmp;\n            q.push(tmp);\n        }\n        //cout<<n<<endl;\n        while(q.size()>1)\n        {\n            int x=q.top();\n            q.pop();\n            int y=q.top();\n            q.pop();\n            res+=x+y;\n            q.push(x+y);\n            // cout<<res<<endl;\n        }\n        cout<<res<<endl;\n```\n\n## 绝对值不等式\n\n### 104. 货仓选址\n\n在一条数轴上有 N 家商店，它们的坐标分别为 A1∼AN。\n\n现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。\n\n为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。\n\n```c++\nans+=abs(a[i]-a[n/2]);\n```\n\n## 推公式\n\n### 125. 耍杂技的牛\n\n```c++\ntypedef pair<int,int> PII;\nconst int N=50010;\n#define x first\n#define y second\n\nint n;\nPII cow[N];\n\nint main()\n{\n    cin >> n;\n    for(int i=0;i<n;i++)\n    {\n        int w,s;\n        cin >> w >> s;\n        cow[i] = {w+s,w};\n    }\n    sort(cow,cow+n);\n    int res = -1e9,sum=0;\n    for(int i=0;i<n;i++)\n    {\n        int s;\n        s = cow[i].x-cow[i].y;\n        res = max(res,sum-s);//风险 = 上面的重量-当前的承受\n        sum+=cow[i].y;\n    }\n    cout << res;\n    return 0;\n}\n```\n\n","tags":["加密文章tag"],"categories":["Algorithm"]},{"title":"template2","url":"/2024/09/19/template2/","content":"[TOC]\n\n## [算法笔记](https://sunnywhy.com/sfbj)\n\n#### 树的遍历\n\n```c++\n#include<bits/stdc++.h>\n#define debug(a) cout<<#a<<\"=\"<<a<<endl\n#define ll long long\nusing namespace std;\ntypedef unsigned long long ull;\nconst int N=1e3+10;\nint n;\nstruct TreeNode \n{\n    int val;\n    int left;\n    int right;\n    TreeNode() : val(0), left(-1), right(-1) {}\n    TreeNode(int x) : val(x), left(-1), right(-1) {}\n//    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\nTreeNode tree[N];\nvector<int> levelOrder(int root) \n{\n        queue<int>q;\n        vector<int>res;\n        if(root!=-1)\n        {\n            q.push(root);\n        }\n        while(q.size())\n        {\n            int size=q.size();\n            // vector<int>vec;\n            for(int i=0;i<size;i++)\n            {\n                int t=q.front();\n                q.pop();\n//                cout<<t<<\" \";\n                res.push_back(t);\n                if(tree[t].left!=-1)q.push(tree[t].left);\n                if(tree[t].right!=-1)q.push(tree[t].right);\n            }\n            // res.push_back(vec);\n        }\n        return res;\n}\nvoid postOrder(int root, vector<int>& res)\n{\n\tif(root==-1)\n\t{\n\t\treturn;\n\t}\n\tpostOrder(tree[root].left,res);\n\tpostOrder(tree[root].right,res);\n\tres.push_back(root);\n}\nint main()\n{\n\tcin>>n;\n\tint l=0,r=0;\n\tvector<int >f(n),res;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>l>>r;\n\t\tif(l!=-1)\n\t\t{\n\t\t\ttree[i].left=l;\n\t\t\tf[l]=1;\n\t\t}\n\t\tif(r!=-1)\n\t\t{\n\t\t\ttree[i].right=r;\n\t\t\tf[r]=1;\n\t\t}\n\t}\n\tint root=find(f.begin(),f.end(),0)-f.begin();\n\tpostOrder(root,res);\n\tfor(int i=0;i<res.size();i++)\n\t{\n\t\tint x=res[i];\n\t\tif(i!=res.size()-1)\n\t\t\tcout<<x<<\" \";\n\t\telse\n\t\t\tcout<<x<<endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n## DFS\n\n### 842. 排列数字\n\n全排列\n\n```c++\nvoid dfs(int u)\n{\n\tif(u==n)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tcout<<path[i]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t\treturn;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(used[i])continue;\n\t\tpath.push_back(i);\n\t\tused[i]=1;\n\t\tdfs(u+1);\n\t\tused[i]=0;\n\t\tpath.pop_back();\n\t}\n}\n```\n\n### 843.n皇后\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int INF=20;\nint udg[INF],dg[INF],col[INF],n; \nchar g[INF][INF];\nvoid dfs(int u)\n{\n\tif(u==n)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tcout<<g[i][j];\n\t\t\t\t\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<endl;\n\t\treturn;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(!col[i]&&!udg[n+i-u]&&!dg[u+i])\n\t\t{\n\t\t\tg[u][i]='Q';\n\t\t\tcol[i]=udg[n+i-u]=dg[u+i]=true;\n\t\t\tdfs(u+1);\n\t\t\tg[u][i]='.';\n\t\t\tcol[i]=udg[n+i-u]=dg[u+i]=false;\n\t\t}\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n    \tfor(int j=0;j<n;j++)\n    \t\tg[i][j]='.'; \n\tdfs(0);\n\treturn 0;\t\n}\n```\n\n#### 8皇后\n\n```c++\ndfs改变\n\tif(u==n)\n    {\n        string a;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                if(g[i][j]=='Q')\n                {\n                    a+=to_string(j+1);\n                }\n            }\n        }\n        // cout<<a<<endl;\n        res.push_back(a);\n        return;\n    }\n```\n\n### oj 1490:A Knight's Journey\n\n```C++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100086;\nint p,q,n;\nint vis[110][110],flag;\nstring path;\nint f[8][2]={{-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1}};//方向\nvoid dfs(int x,int y,int t)\n{\n\tif(t==p*q||flag)\n\t{\n\t\tflag=1;\n\t\treturn;\n\t}\n\tfor(int i=0;i<8;i++)\n\t{\n\t\tint dx=f[i][0]+x;\n\t\tint dy=f[i][1]+y;\n\t\tif(!vis[dx][dy]&&dx>=0&&dx<q&&dy>=0&&dy<p)\n\t\t{\n\t\t\tchar xx=char(dx+'A');\n\t\t\tchar yy=char(dy+'0'+1);\n\t\t\tpath+=xx;\n\t\t\tpath+=yy;\n//\t\t\tcout<<dx<<\" \"<<dy<<endl;\n\t\t\tvis[dx][dy]=1;\n\t\t\tdfs(dx,dy,t+1); \n\t\t\tif(flag)break;\n\t\t\tvis[dx][dy]=0;\n\t\t\tpath.pop_back();\n\t\t\tpath.pop_back();\n\t\t}\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>n;\n   for(int i=0;i<n;i++)\n    {\n    \tcin>>p>>q;\n    \tcout<<\"Scenario #\"<<i+1<<\":\"<<endl;\n    \tflag=0;\n    \tmemset(vis,false,sizeof(vis)); \n    \tpath.clear();\n//    \tcout<<path<<endl;\n\t\tfor(int i=0;i<q;i++)\n\t\t{\n\t\t\tfor(int j=0;j<p;j++)\n\t\t\t{\n\t\t\t\tchar xx=char(i+'A');\n\t\t\t\tchar yy=char(j+'0'+1);\n\t\t\t\tpath+=xx;\n\t\t\t\tpath+=yy;\n\t\t\t\tvis[i][j]=1;\n//\t\t\t\tcout<<i<<\" \"<<j<<endl;\n\t\t\t\tdfs(i,j,1);\n\t\t\t\tif(flag)break;\n\t\t\t\tvis[i][j]=0;\n\t\t\t\tpath.pop_back();\n\t\t\t\tpath.pop_back();\n\t\t\t\t\n\t\t\t}\n\t\t\tif(flag)break;\n\t\t}\n\t\tif(flag)\n\t\t{\n\t\t\t\n\t\t\tcout<<path<<endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout<<\"impossible\"<<endl;\n\t\t}\n\t\tcout<<endl;\n\t}\n    return 0;\n}\n```\n\n### poj 2362 Square\n\n给出一堆长度各异的木棍，这些木棍能否头尾相连形成一个正方形\n\n```c++\nvoid dfs(int num,int len,int start)//成功边数,目前长度,开始位置\n{\n    if(flag)\n        return ;\n    if(num==4)\n    {\n        flag=1;\n        return;\n    }\n    if(len==he)\n    {\n        dfs(num+1,0,0);\n        if(flag)\n            return ;\n    }\n    for(int i=start;i<m;i++)\n    {\n        if(!vis[i]&&len+a[i]<=he)\n        {\n            vis[i]=1;\n            dfs(num,len+a[i],i+1);\n            vis[i]=0;\n            if(flag)\n                return ;\n \n        }\n    }\n}\nint main()\n{\n\n    cin>>n;\n    while(n--)\n    {\n        cin>>m;\n        sum=0,maxlen=0;\n        for(int i=0;i<m;i++)\n        {\n            cin>>a[i];\n            sum+=a[i];\n            maxlen=max(maxlen,a[i]);\n//            if(a[i]>maxlen)\n//                maxlen=a[i];\n        }\n        he=sum/4;\n        if(sum%4!=0||maxlen>he)\n        {\n            cout<<\"no\"<<endl;\n            continue;\n        }\n        sort(a,a+m);\n        memset(vis,0,sizeof(vis));\n        flag=0;\n        dfs(0,0,0);\n        if(flag)\n            cout<<\"yes\"<<endl;\n        else\n            cout<<\"no\"<<endl;\n    }\n    return 0;\n}\n```\n\n### [字节面试](https://blog.csdn.net/xiexingshishu/article/details/27242891)\n\n题目描述：\n一个整数数组，长度为n，将其分为m份，使各份的和相等，求m的最大值\n  比如{3，2，4，3，6} 可以分成{3，2，4，3，6} m=1;\n  {3,6}{2,4,3} m=2\n  {3,3}{2,4}{6} m=3 所以m的最大值为3。\n\n输入：\n存在多组数据，每组数据一定行为一个正整数n（n<=64），第二行为n个数字。当n为0时，测试结束。\n\n输出：\n输出最大值m。\n\n```c++\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nconst int N = 100;\nint numArr[N];\nint n, sum;\nbool vis[N];\n\nbool dfs(int cnt, int maxx, int re, int s) //成功边数,边最大长，目前长度,开始位置\n{\n    if (cnt == 0) return true;\n\n    if (re == maxx) return dfs(cnt - 1, maxx, 0, 0);\n    \n\n    for (int i = s; i < n; i++)\n    {\n        if (vis[i] || re + numArr[i] > maxx) continue;\n        if (i > 0 && numArr[i] == numArr[i - 1] && vis[i - 1] == false) continue;\n\n        vis[i] = true;\n        if (dfs(cnt, maxx, re + numArr[i], i + 1)) return true;\n\n        vis[i] = false;\n        if (re + numArr[i] == maxx) break;\n        if (maxx == re) break;\n\n//        while (i + 1 < n && numArr[i + 1] == numArr[i]) i++;//去重\n    }\n\n    return false;\n}\nbool Try(int m) \n{\n    if (sum % m != 0) return false;\n\n    memset(vis, false, sizeof(vis));\n\n    return dfs(sum / m, m, m, 0);\n}\nvoid solve() {\n    sort(numArr, numArr + n, greater<int>());\n\n    int m = numArr[0];\n    while (!Try(m)) m++;\n\n    cout << (sum / m) << endl;\n}\n\nint main() {\n    cin >> n;\n    if (n == 0) return false;\n\n    sum = 0;\n    for (int i = 0; i < n; i++) {\n        cin >> numArr[i];\n        sum += numArr[i];\n    }\n    solve();\n\n    return 0;\n}\n\n```\n\n\n\n## BFS\n\n### 844. 走迷宫\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int INF=110;\nint d[INF][INF],n,m; \nint g[INF][INF];\ntypedef pair<int,int >PII;\nPII pprev[INF][INF];\nint dir[5][3]={{0,0},{0,-1},{-1,0},{0,1},{1,0}};\nint bfs()\n{\n\tqueue<pair<int,int > >q;\n\tq.push({0,0});\n\tint dx=0,dy=0;\n\twhile(q.size()>0)\n\t{\n\t\tauto t=q.front();\n\t\tq.pop();\n\t\tfor(int i=1;i<=4;i++)\n\t\t{\n\t\t\tdx=t.first+dir[i][0];\n        \tdy=t.second+dir[i][1];\n        \tif(dx>=0&&dx<n&&dy>=0&&dy<m&&!g[dx][dy]&&d[dx][dy]==-1)\n        \t{\n        \t\td[dx][dy]=d[t.first][t.second]+1;\n        \t//\tpprev[dx][dy]=t;\n        \t\tq.push({dx,dy});\n\t\t\t}\n\t\t}\n\t}\n\t//int x=n-1,y=m-1;\n\t//while(x||y)\n\t//{\n\t//    cout<<x<<\" \"<<y<<endl;\n\t//    auto t=pprev[x][y];\n\t//    x=t.first,y=t.second;\n    //}\n\treturn d[n-1][m-1];\n\t\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++)\n    \tfor(int j=0;j<m;j++)\n    \t\tcin>>g[i][j];\n    memset(d,-1,sizeof(d));\n    d[0][0]=0;\n\tcout<<bfs()<<endl;\n\t \n\treturn 0;\t\n}\n```\n\n### 845. 八数码\n\n在一个 3×3 的网格中，1∼8 这 8 个数字和一个 `x` 恰好不重不漏地分布在这 3×3 的网格中。\n\n例如：\n\n```\n1 2 3\nx 4 6\n7 5 8\n```\n\n在游戏过程中，可以把 `x` 与其上、下、左、右四个方向之一的数字交换（如果存在）。\n\n我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：\n\n```\n1 2 3\n4 5 6\n7 8 x\n```\n\n例如，示例中图形就可以通过让 `x` 先后与右、下、右三个方向的数字交换成功得到正确排列。\n\n```c++\nint f[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\nstring c,start;\nint bfs()\n{\n\tqueue<string >q;\n\tunordered_map<string,int >d;\n\tq.push(start);\n\td[start]=0;\n\n\twhile(q.size())\n\t{\n\t\tauto t=q.front();\n\t\tq.pop();\n\t\tint cnt=d[t];\n\t\tif(t==\"12345678x\")return cnt;\n\t\tint pos=t.find('x');\n\t\tint dx=pos/3,dy=pos%3;\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tint xx=dx+f[i][0];\n\t\t\tint yy=dy+f[i][1];\n\t\t\tif(xx>=0&&xx<3&&yy>=0&&yy<3)\n\t\t\t{\n\t\t\t\tswap(t[pos],t[xx*3+yy]);\n\t\t\t\tif(!d.count(t))\n\t\t\t\t{\n\t\t\t\t\td[t]=cnt+1;\n\t\t\t\t\tq.push(t);\n\t\t\t\t}\n\t\t\t\tswap(t[pos],t[xx*3+yy]);\n\t\t\t}\n//\t\t\tcout<<xx<<','<<yy<<endl;\n\t\t}\n\t}\n\treturn -1;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\tfor(int i=0;i<9;i++)\n\t{\n\t\tcin>>c;\n\t\tstart+=c;\t\t\n\t}\n\tcout<<bfs()<<endl;\n\treturn 0;\t\n}\n```\n\n### poj 1426.Find The Multiple\n\n给定一个正整数n，请编写一个程序来寻找n的一个非零的倍数m，这个m应当在十进制表示时每一位上只包含0或者1。你可以假定n不大于200且m不多于100位。\n\n```c++\nvoid bfs(long long x,long long y)\n{\n    queue<long long >q;\n    q.push(x);\n    while(q.size())\n    {\n\t\t\n        if(q.front()%m==0)\n        {\n           cout<<q.front()<<endl;\n            return ;\n        }\n        q.push(q.front()*10);\n        q.push(q.front()*10+1);\n        q.pop();\n    }\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n\twhile(cin>>m)\n\t{\n\t\tif(m==0) break;\n\t\tflag=0;\n\t\tbfs(1,1);\n\t}\n\treturn 0;\t\n}\n```\n\n## 树与图存储遍历\n\n### 846. 树的重心\n\n给定一颗树，树中包含 n 个结点（编号 1∼n）和 n−1 条无向边。\n\n请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。\n\n重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。\n\n```c++\nint e[N],ne[N],h[N],vis[N];\nvoid add(int a,int b)\n{\n\te[idx]=b,ne[idx]=h[a],h[a]=idx++;\n}\nint dfs(int u)\n{\n\tvis[u]=1;\n\tint sum=1,res=0;\n\tfor(int i=h[u];~i;i=ne[i])\n\t{\n\t\tint j=e[i];\n\t\tif(!vis[j])\n\t\t{\n\t\t\tint s=dfs(j);\n\t\t\tres=max(res,s);\n\t\t\tsum+=s;\n\t\t}\n\t}\n\tres=max(res,n-sum);\n\tans=min(ans,res);\n\treturn sum;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int a=0,b=0;\n\tcin>>n;\n\tmemset(h,-1,sizeof(h));\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tcin>>a>>b;\n\t\tadd(a,b);\n\t\tadd(b,a);\n\t}\n\tdfs(1);\n\tcout<<ans<<endl;\n\treturn 0;\t\n}\n```\n\n### 847. 图中点的层次\n\n```c++\nint bfs()\n{\n\tqueue<int >q;\n\tq.push(1);\n\td[1]=1;\n\twhile(q.size())\n\t{\n\t\tint t=q.front();\n\t\tq.pop();\n\t\tfor(int i=h[t];~i;i=ne[i])\n\t\t{\n\t\t\tint j=e[i];\n\t\t\tif(!d[j])\n\t\t\t{\n\t\t\t\td[j]=d[t]+1;\n\t\t\t\tq.push(j);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[n]-1;\n}\n```\n\n## 拓扑排序 848\n\n时间复杂度 O(n+m), n 表示点数，m 表示边数\n\n```c++\nint bfs()\n{\n\tqueue<int >q;\n\tint tt=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!d[i])\n\t\t{\n\t\t\tq.push(i);\n\t\t\t//tt++;\n\t\t}\n\t}\n\t\n\twhile(q.size()>0)\n\t{\n\t\tint t=q.front();\n\t\tq.pop();\n\t\ta[tt++]=t;\n\t\t//cout<<t<<endl;\n\t\t//if(t==n)return d[t];\n\t\tfor(int i=h[t];~i;i=ne[i])\n\t\t{\n\t\t\tint j=e[i];\n\t\t\td[j]--;\n\t\t\tif(!d[j])\n\t\t\t{\n\t\t\t\tq.push(j);\n\t\t\t\t//tt++;\n\t\t\t}\n\t\t}\n\t}\n\treturn tt==n;\n}\n```\n\n## 最短路径\n\n### 849. Dijkstra求最短路 I\n\n$$\n时间复杂度：O(n^2+m)\n$$\n\n```c++\nint h[N], w[M], e[M], ne[M], idx;\nint n, m;\nint dist[N];\nbool st[N];\n\nvoid add(int a, int b, int c)\n{\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;\n}\n\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<string>\n#include<string.h>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n\n#define debug(a) cout<<#a<<\"=\"<<a<<endl\nusing namespace std;\nconst int N=150010;\nint ncnt,n,m,k;\nint a[N],flag=0;\nint st[N];\nint dist[N];\nvector<pair<int,int> >edge[N]; \nint dij()\n{\n\tmemset(dist,0x3f,sizeof dist);\n\tdist[1]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint k=-1;\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(!st[j]&&(k==-1||dist[j]<dist[k]))\n\t\t\t{\n\t\t\t\tk=j;\n\t\t\t}\n\t\t}\n\t\tst[k]=1;\n\t\tfor(int i=0;i<edge[k].size();i++)\n\t\t{\n\t\t\tint j=edge[k][i].first;\n\t\t\tint w=edge[k][i].second; \n\t\t\tdist[j]=min(dist[j],dist[k]+w);\n\t\t}\n\t}\n\tif(dist[n]==0x3f3f3f3f)return -1;\n\telse return dist[n];\n\t\n\t\n}\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint a=0,b=0,c=0;\n\t\tcin>>a>>b>>c;\n\t\tedge[a].push_back({b,c});\n\t}\n\tcout<<dij()<<endl;\n\treturn 0;\n}\n\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int INF=510;\nint d[INF],st[INF],n,m,ans; \nint g[INF][INF];\ntypedef pair<int,int >PII;\nPII pprev[INF][INF];\nint dist[INF];\nint dij()\n{\n\tmemset(dist,0x3f,sizeof(dist));\n\tdist[1]=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint t=-1;\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(!st[j]&&(t==-1||dist[t]>dist[j]))\n\t\t\t\tt=j;\t\n\t\t}\n\t\tst[t]=1;\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tdist[j]=min(dist[j],dist[t]+g[t][j]);\n\t\t}\n\t}\n\tif(dist[n]==0x3f3f3f3f)return -1;\n\treturn dist[n];\n\t\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\tcin>>n>>m;\n\tmemset(g,0x3f,sizeof(g));\n\twhile(m--)\n\t{\n\t\tint a=0,b=0,c=0;\n\t\tcin>>a>>b>>c;\n\t\tg[a][b]=min(g[a][b],c);\n\t}\n    int t=dij();\n\tcout<<t<<endl;\n\t \n\treturn 0;\t\n}\n\n```\n\n### 903. 昂贵的聘礼\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=110;\nint n,k;\nint level[N];//等级数组\nint dist[N];//最短距离\nint g[N][N];//直线距离\nbool st[N];\nint dij(int low,int high)\n{\n\tmemset(dist,0x3f,sizeof(dist));\n\tdist[0]=0;\n\tfor(int i=0;i<n+1;i++)\n\t{\n\t\tint t=-1;\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tif(!st[j]&&(t==-1||dist[t]>dist[j]))\n\t\t\t{\n\t\t\t\tt=j;\n\t\t\t}\n\t\t}\n\t\tst[t]=1;\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(level[j]>=low&&level[j]<=high)\n\t\t\t{\n\t\t\t\tdist[j]=min(dist[j],dist[t]+g[t][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[1];\n}\nint main()\n{\n\tcin>>k>>n;\n\tmemset(g,0x3f, sizeof g);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint p=0,l=0,m=0;\n\t\tcin>>p>>l>>m;\n\t\tg[0][i]=min(g[0][i],p);\n\t\tlevel[i]=l;\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tint u=0,v=0;\n\t\t\tcin>>u>>v;\n\t\t\tg[u][i]=min(g[u][i],v);\n\t\t}\n\t}\n\tint res=INT_MAX;\n\tfor(int i=level[1]-k;i<=level[1];i++)\n\t{\n\t\tres=min(res,dij(i,i+k));\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n } \n```\n\n\n\n### 850. Dijkstra求最短路 II\n\n$$\n时间复杂度： O(mlogn)\n$$\n\n```c++\ntypedef pair<int, int> PII;\n\nint n;      // 点的数量\nint h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边\nint dist[N];        // 存储所有点到1号点的距离\nbool st[N];     // 存储每个点的最短距离是否已确定\n\n// 求1号点到n号点的最短距离，如果不存在，则返回-1\nint dijkstra()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n    priority_queue<PII, vector<PII>, greater<PII>> heap;\n    heap.push({0, 1});      // first存储距离，second存储节点编号\n\n    while (heap.size())\n    {\n        auto t = heap.top();\n        heap.pop();\n\n        int ver = t.second, distance = t.first;\n\n        if (st[ver]) continue;\n        st[ver] = true;\n\n        for (int i = h[ver]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dist[j] > distance + w[i])\n            {\n                dist[j] = distance + w[i];\n                heap.push({dist[j], j});\n            }\n        }\n    }\n\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n}\n```\n\n#### STL\n\n```c++\ntypedef pair<int, int> PII;\nint n,m;      // 点的数量\nvector<pair<int,int>>edge[N];\nint dist[N];        // 存储所有点到1号点的距离\nbool st[N];     // 存储每个点的最短距离是否已确定\nint dij()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n    priority_queue<PII, vector<PII>, greater<PII>> heap;\n    heap.push({0, 1});      // first存储距离，second存储节点编号\n\n    while (heap.size())\n    {\n        auto t = heap.top();\n        heap.pop();\n\n        int ver = t.second, distance = t.first;\n\n        if (st[ver]) continue;\n        st[ver] = true;\n\n        for (int i = 0;i<edge[ver].size();i++)\n        {\n            int j = edge[ver][i].first;\n            int w=edge[ver][i].second;\n            if (dist[j] > distance + w)\n            {\n                dist[j] = distance + w;\n                heap.push({dist[j], j});\n            }\n        }\n    }\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n}\n```\n\n### 853. 有边数限制的最短路（Bellman-Ford）\n\n$$\n时间复杂度： O(mn)\n$$\n\n```c++\nint dist[N],backup[N];\nint k,n,m;\nstruct edge{\n    int a;int b;int w;\n}edge[N];\nint bellman_ford()\n{\n    memset(dist,0x3f,sizeof dist);\n    dist[1]=0;\n    for(int i=1;i<=k;i++)\n    {\n        memcpy(backup,dist,sizeof dist);\n        for(int j=1;j<=m;j++)\n        {\n            int a=edge[j].a,b=edge[j].b,w=edge[j].w;\n            dist[b]=min(dist[b],backup[a]+w);\n        }\n    }\n    return dist[n];\n}\nint main()\n{\n    cin>>n>>m>>k;\n    for(int i=1;i<=m;i++)\n    {\n        int a,b,c;\n        cin>>a>>b>>c;\n        edge[i].a=a,edge[i].b=b,edge[i].w=c;\n    }\n    int t=bellman_ford();\n    if(t>=0x3f3f3f3f/2)puts(\"impossible\");\n    else cout<<t<<endl;\n}\n```\n\n### 851. spfa求最短路\n\n$$\n时间复杂度： O(mn)，平均 O(n)\n$$\n\n```c++\ntypedef pair<int, int> PII;\nint n,m;      // 点的数量\nint h[N], w[N], e[N], ne[N], idx;       \nint dist[N];        // 存储所有点到1号点的距离\nbool st[N];    \nvoid add(int a,int b,int c)\n{\n\te[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;\n}\n\nvoid spfa()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1]=0;\n\tqueue<int >q;\n\tq.push(1);      \n\tst[1]=true;\n    while (q.size())\n    {\n    \tint t=q.front();\n    \tq.pop();\n    \tst[t]=false;\n    \tfor(int i=h[t];~i;i=ne[i])\n    \t{\n    \t\tint j=e[i];\n    \t\tif(dist[j]>dist[t]+w[i])\n    \t\t{\n    \t\t\tdist[j]=dist[t]+w[i];\n    \t\t\tif(!st[j])\n    \t\t\t{\n    \t\t\t\tq.push(j);\n    \t\t\t\tst[j]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    \n    if (dist[n] == 0x3f3f3f3f) cout<<\"impossible\"<<endl;\n    else cout<<dist[n] <<endl;\n}\n```\n\n### 852. spfa判断负环\n\n$$\n时间复杂度： O(mn)\n$$\n\n```c++\nint n;      // 总点数\nint h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边\nint dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数\nbool st[N];     // 存储每个点是否在队列中\n\n// 如果存在负环，则返回true，否则返回false。\nbool spfa()\n{\n    // 不需要初始化dist数组\n    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。\n\n    queue<int> q;\n    for (int i = 1; i <= n; i ++ )\n    {\n        q.push(i);\n        st[i] = true;\n    }\n\n    while (q.size())\n    {\n        auto t = q.front();\n        q.pop();\n\n        st[t] = false;\n\n        for (int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dist[j] > dist[t] + w[i])\n            {\n                dist[j] = dist[t] + w[i];\n                cnt[j] = cnt[t] + 1;\n                if (cnt[j] >= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环\n                if (!st[j])\n                {\n                    q.push(j);\n                    st[j] = true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```\n\n### 854. Floyd求最短路\n\n$$\n时间复杂度： O(n^3)\n$$\n\n```c++\nint n, m, k, x, y, z;\nint d[N][N];\nvoid floyd()\n{\n\tfor(int k=1;k<=n;k++)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(i==j)d[i][j]=0;\n\t\t\telse\n\t\t\t{\n\t\t\t\td[i][j]=INF;\n\t\t\t}\n\t\t}\n\t}\n\twhile(m--)\n\t{\n\t\tcin>>x>>y>>z;\n\t\td[x][y]=min(d[x][y],z);\n\t}\n\tfloyd();\n\twhile(k--)\n\t{\n\t\tcin>>x>>y;\n\t\tif(d[x][y]>INF/2)cout<<\"impossible\"<<endl;\n\t\telse\n\t\t{\n\t\t\tcout<<d[x][y]<<endl;\n\t\t}\n\t}\n\treturn 0;\t\n}\n```\n\n### 最短路径问题\n\n给你n个点，m条无向边，每条边都有长度d和花费p，给你起点s终点t，要求输出起点到终点的最短距离及其花费，如果最短距离有多条路线，则输出花费最少的。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=300086;\ntypedef pair<int, int> PII;\nint n,m,s,t2;      // 点的数量\nint h[N], w[N], e[N], ne[N], idx,cost[N];       // 邻接表存储所有边\nint cnt[N];\nint dist[N];        // 存储所有点到1号点的距离\nbool st[N];     // 存储每个点的最短距离是否已确定\nstruct edge\n{\n    int to;\n    int length;\n    int money;\n    edge(int t,int l,int m):to(t),length(l),money(m){}\n};\nvector<edge>graph[1010];\nclass pp\n{\npublic:\n    int fir;\n    int sec;\n    int cos;\n    pp(int a,int b,int c):fir(a),sec(b),cos(c){}\n     bool operator>(const pp &p)const\n     {\n        if(fir==p.fir)\n        {\n            return cos>p.cos;\n        }\n        else\n        {\n            return fir>p.fir;\n        }\n     }\n};\n// 求1号点到n号点的最短距离，如果不存在，则返回-1\nint dij()\n{\n    memset(dist, 0x3f, sizeof dist);\n    memset(cnt, 0x3f, sizeof cnt);\n    dist[s] = 0;\n    cnt[s]=0;\n    priority_queue<pp, vector<pp>, greater<pp>> heap;\n    heap.push({0, s,0});      // first存储距离，second存储节点编号\n    while (heap.size())\n    {\n        auto t = heap.top();\n        heap.pop();\n\n        int node = t.sec, distance = t.fir,price=t.cos;\n\n        if (st[node]) continue;\n        st[node] = true;\n\n        for (int i=0;i<graph[node].size();++i)\n        {\n            int new_node = graph[node][i].to;\n            int len = graph[node][i].length;\n            int p=graph[node][i].money;\n            if (dist[new_node] > dist[node] + len||(dist[new_node] == dist[node] + len&&cnt[new_node]>p+cnt[node]))\n            {\n                dist[new_node] = dist[node] + len;\n                cnt[new_node]=p+cnt[node];\n                heap.push({ dist[new_node], new_node, cnt[new_node]});\n            }\n        }\n    }\n\n    if (dist[t2] == 0x3f3f3f3f) return -1;\n    return dist[t2];\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\twhile(cin>>n>>m)\n\t{\n\t\tif(n==0&&m==0)break;\n\t\tmemset(st,false,sizeof(st));\n        // for(int i=1;i<=n;i++)\n        // {\n        //     add(i,i,0,0);\n        // }\n        // for(int i = 1; i <= N; i++) graph[i].clear();\n\t\twhile(m--)\n\t\t{\n\t\t\tint a=0,b=0,c=0,d=0;\n\t\t\tcin>>a>>b>>c>>d;\n\n            // add(a,b,c,d); \n\t\t\t// add(b,a,c,d);\n\t\t\tgraph[a].push_back({b, c, d});\n            graph[b].push_back({a, c, d});\n\t\t}\n        cin>>s>>t2;\n    \tint t=dij();\n\t\tcout<<t<<\" \"<<cnt[t2]<<endl;\n\t}\t \n\treturn 0;\t\n}\n```\n\n## 最小生成树\n\n### 858. Prim算法求最小生成树\n\n含输出路径\n$$\n时间复杂度： O(n^2+m)\n$$\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 510, INF = 0x3f3f3f3f;\nint dist[N], g[N][N],pre[N];\nint n, m;\nbool st[N];\nint res = 0;\nint prim()\n{\n    memset(dist, 0x3f, sizeof dist);\n    int res=0;\n    dist[1]=0;\n    for(int i=0;i<n;i++)\n    {\n    \tint t=-1;\n    \tfor(int j=1;j<=n;j++)\n    \t{\n    \t\tif(!st[j]&&(t==-1||dist[j]<dist[t]))\n    \t\t{\n    \t\t\tt=j;\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF)return INF;\n\t\tst[t]=true;\n\t\tres+=dist[t];\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(dist[j]>g[t][j]&&!st[j])\n\t\t\t{\n\t\t\t\tdist[j]=g[t][j];\n\t\t\t\tpre[j] = t;//从 t 到 j 的距离更短，i 的前驱变为 t.\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\treturn res;\n}\nvoid getPath()//输出各个边\n{\n    for(int i = n; i > 1; i--)//n 个节点，所以有 n-1 条边。\n    {\n        cout << i <<\" \" << pre[i] << \" \"<< endl;// i 是节点编号，pre[i] 是 i 节点的前驱节点。他们构成一条边。\n    }\n}\nint main()\n{\n//\tios::sync_with_stdio(false);\n//    cin.tie(0);\n//    cout.tie(0);\n    memset(g,0x3f,sizeof(g)); \n\twhile(cin>>n>>m)\n\t{\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint a=0,b=0,c=0;\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\tg[a][b]=g[b][a]=min(g[a][b],c);\n\t\t}\n\t\tint t=prim();\n\t\tif(t==INF)cout<<\"impossible\"<<endl;\n\t\telse\n\t\t{\n\t\t\tcout<<t<<endl;\n\t\t}\n\t}\t \n\treturn 0;\t\n}\n```\n\n### 859. Kruskal算法求最小生成树\n\n$$\n时间复杂度： O(mlogm)\n$$\n\n```c++\nstruct Edge \n{\n    int a, b, w;\n    bool operator<(const Edge &e) const \n\t{\n        return w < e.w;\n    }\n} es[M];\nint find(int x) \n{\n    if (p[x] != x) p[x] = find(p[x]);\n    return p[x];\n}\nint init(int n)\n{\n\tfor (int i = 1; i <= n; i++) p[i] = i;\n}\nint kruskal() \n{\n    int cnt = 0, res = 0;\n    sort(es, es + m);\n    init(n);\n    for (int i = 0; i < m; i++) \n\t{\n        int a = es[i].a, b = es[i].b, w = es[i].w;\n        a = find(a), b = find(b);\n        if (a != b) \n\t\t{\n            p[a] = b;\n            res += w;\n            cnt++;\n        }\n    }\n    if (cnt < n - 1) return INF;\n    else return res;\n}\n\nint main() \n{\n    while(cin >> n >> m)\n    {\n    \tfor (int i = 0; i < m; i++) \n\t\t{\n        \tint a, b, w;\n        \tscanf(\"%d%d%d\", &a, &b, &w);\n        \tes[i] = {a, b, w};\n    \t}\n    \tint t = kruskal();\n    \tif (t == INF) cout << \"impossible\";\n    \telse cout << t;\n\t}    \n}\n```\n\n### [poj2349](http://poj.org/problem?id=2349)\n\n[refer](https://blog.csdn.net/lyhvoyage/article/details/19930551)\n\n```c++\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<string.h>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\ndouble px[550],py[550];\nvector<double> d;\nint p[550],t,s,p1;\nconst int M=500086;\nint m=0;\nstruct Edge\n{\n\tint a,b;\n\tdouble w;\n\tbool operator <(const Edge &e)const\n\t{\n\t\treturn w<e.w;\n\t}\n}es[M];\nint find(int x)\n{\n\tif(p[x]!=x)\n\t{\n\t\tp[x]=find(p[x]);\n\t}\n\treturn p[x];\n}\n\ndouble getdis(int i,int j)\n{\n\tdouble d1=sqrt((px[i]-px[j])*(px[i]-px[j])+(py[i]-py[j])*(py[i]-py[j]));\n\treturn d1;\n}\nvoid init(int n)\n{\n\td.clear();\n\tfor(int i=0;i<=n;i++)p[i]=i;\n}\nvoid kruskal(int n)\n{\n\td.clear();\n\tint cnt=0,res=0;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint a=es[i].a,b=es[i].b;\n\t\tdouble w=es[i].w;\n\t\ta=find(a),b=find(b);\n\t\tif(a!=b)\n\t\t{\n\t\t\tp[a]=b;\n\t\t\td.push_back(w);\n//\t\t\tres+=w;\n\t\t\tn--;\n//\t\t\tcout<<w<<endl;\n\t\t\tif(n==1)return;\n\t\t}\n\t}\n\treturn;\n}\nint main()\n{\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tm=0;\n\t\tcin>>s>>p1;\n\t\tinit(p1);\n\t\tfor(int i=1;i<=p1;i++)\n\t\t{\n\t\t\tcin>>px[i]>>py[i];\n\t\t} \n\t\tfor(int i=1;i<=p1;i++)\n\t\t{\n\t\t\tfor(int j=i+1;j<=p1;j++)\n\t\t\t{\n\t\t\t\tes[m].a=i;\n\t\t\t\tes[m].b=j;\n\t\t\t\tes[m].w=getdis(i,j);\n\t\t\t\tm++;\n\t\t\t\tes[m].a=j;\n\t\t\t\tes[m].b=i;\n\t\t\t\tes[m].w=getdis(i,j);\n\t\t\t\tm++;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tsort(es,es+m);\n\t\tkruskal(p1);\n\t\tprintf(\"%.2lf\\n\",d[p1-s-1]);\n\t}\n\treturn 0;\n}\n```\n\n\n\n## 860. 染色法判定二分图\n\n$$\n时间复杂度： O(n+m)\n$$\n\n```c++\ntypedef pair<int, int> PII;\nint n,m;      // 点的数量\nint h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边\nint color[N],flag;        // 存储所有点到1号点的距离\nbool st[N];     // 存储每个点的最短距离是否已确定\nvoid add(int a,int b)\n{\n\te[idx]=b,ne[idx]=h[a],h[a]=idx++;\n}\nint dfs(int u,int c)\n{\n\tcolor[u]=c;\n\tfor(int i=h[u];~i;i=ne[i])\n\t{\n\t\tint b=e[i];\n\t\tif(!color[b])\n\t\t{\n\t\t\tif(!dfs(b,3-c))return false;\n\t\t}\n\t\telse if(color[b]==c)return false;\n\t}\n\treturn true;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\twhile(cin>>n>>m)\n\t{\n\t\tif(n==0&&m==0)break;\n\t\tmemset(h,-1,sizeof(h));\n//\t\tmemset(e,-1,sizeof(e));\n//\t\tmemset(w,-1,sizeof(w));\n\t\tmemset(st,false,sizeof(st));\n//\t\tidx=0;\n\t\twhile(m--)\n\t\t{\n\t\t\tint a=0,b=0,c=0;\n\t\t\tcin>>a>>b;\n\t\t\tadd(a,b); \n\t\t\tadd(b,a);\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(!color[i])\n\t\t\t{\n\t\t\t\tif(!dfs(i,1))\n\t\t\t\t{\n\t\t\t\t\tcout << \"No\" << endl;//出现矛盾，输出NO \n\t\t\t\t\tflag=1;\n                \tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!flag)\n\t\t\tcout << \"Yes\" << endl; \t\t\n\t} \n\treturn 0;\t\n}\n```\n\nSTL\n\n```c++\n \t\tfor(int i = 0; i < N; i++) e[i].clear();\n        if(n == 0 && m == 0) break;\n        while( m -- )\n        {\n            int a, b;\n            cin >> a >> b ;\n            e[a].push_back(b);\n            e[b].push_back(a);\n        }\n//dfs中改为 for(int i=0;i<e[u].size();i++)\n//int b=e[u][i];\n```\n\n## 861. 二分图的最大匹配（匈牙利算法）\n\n```c++\nint n,m,n2;      // 点的数量\nint h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边\nint match[N],flag;        // 存储所有点到1号点的距离\nbool st[N];     // 存储每个点的最短距离是否已确定\nvoid add(int a,int b)\n{\n\te[idx]=b,ne[idx]=h[a],h[a]=idx++;\n}\nint find(int u)\n{\n\tfor(int i=h[u];~i;i=ne[i])\n\t{\n\t\tint b=e[i];\n\t\tif(!st[b])\n\t\t{\n\t\t\tst[b]=true;\n\t\t\t//如果女孩j没有男朋友，或者她原来的男朋友能够预定其它喜欢的女孩。配对成功\n\t\t\tif(!match[b]||find(match[b]))\n\t\t\t{\n\t\t\t\tmatch[b]=u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\twhile(cin>>n>>n2>>m)\n\t{\n\t\tif(n==0&&m==0)break;\n\t\tmemset(h,-1,sizeof(h));\n\t\twhile(m--)\n\t\t{\n\t\t\tint a=0,b=0,c=0;\n\t\t\tcin>>a>>b;\n\t\t\tadd(a,b); \n\t\t}\n\t\tint res=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tmemset(st,false,sizeof(st));\n\t\t\tif(find(i))res++;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\t \n\treturn 0;\t\n}\n```\n\n## 质数\n\n### 866. 试除法判定质数\n\n```c++\nbool is_prime(int x)\n{\n    if (x < 2) return false;\n    for (int i = 2; i <= x / i; i ++ )\n        if (x % i == 0)\n            return false;\n    return true;\n}\n```\n\n### 867. 分解质因数\n\n```c++\nvoid divide(int x)\n{\n    for (int i = 2; i <= x / i; i ++ )\n        if (x % i == 0)\n        {\n            int s = 0;\n            while (x % i == 0) x /= i, s ++ ;\n            cout << i << ' ' << s << endl;\n        }\n    if (x > 1) cout << x << ' ' << 1 << endl;\n    cout << endl;\n}\n```\n\n### 868. 筛质数\n\n线性筛法求素数\n\n```c++\nint primes[N], cnt;     // primes[]存储所有素数\nbool st[N];         // st[x]存储x是否被筛掉\nvoid get_primes(int n)\n{\n    for (int i = 2; i <= n; i ++ )\n    {\n        if (!st[i]) primes[cnt ++ ] = i;\n        for (int j = 0; primes[j] <= n / i; j ++ )\n        {\n            st[primes[j] * i] = true;\n            if (i % primes[j] == 0) break;\n        }\n    }\n}\n```\n\n埃式+线性\n\n```c++\nvoid getprime(int n)\n{\n\tint cnt=0;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(!st[i])\n\t\t{\n\t\t\tprime[cnt++]=i;\n\t\t\tfor(int j=i;j<=n;j+=i)\n\t\t\t{\n\t\t\t\tst[j]=1;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tcout<<cnt<<endl;\n}\n\t\t\t/*\n                prime[]数组中的素数是递增的,当i能整除prime[j]，那么i*prime[j+1]这个合数\n                肯定被prime[j]乘以某个数筛掉。\n                因为i中含有prime[j],prime[j]比prime[j+1]小，\n                即i=k*prime[j]，那么i*prime[j+1]=(k*prime[j])*prime[j+1]=k’*prime[j]，\n                接下去的素数同理。所以不用筛下去了。\n                因此，在满足i%prime[j]==0这个条件之前以及第一次满足改条件时,\n                prime[j]必定是prime[j]*i的最小因子。\n            */\nvoid getprime2(int n)\n{\n\tint cnt=0;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(!st[i])\n\t\t{\n\t\t\tprime[cnt++]=i;\n\t\t}\n\t\tfor(int j=0;prime[j]<=n/i;j++)\n\t\t{\n\t\t\tst[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n\tcout<<cnt<<endl;\n}\n```\n\n## 约数\n\n### 869. 试除法求约数\n\n```c++\nvector<int> get_divisors(int x)\n{\n    vector<int> res;\n    for (int i = 1; i <= x / i; i ++ )\n        if (x % i == 0)\n        {\n            res.push_back(i);\n            if (i != x / i) res.push_back(x / i);\n        }\n    sort(res.begin(), res.end());\n    return res;\n}\n```\n\n### 870. 约数个数\n\n```c++\n如果 N = p1^c1 * p2^c2 * ... *pk^ck\n约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)\n约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)\n```\n\n```c++\nint n,m,n2;      // 点的数量\nunordered_map<int,int>umap;\nint match[N],flag;        // 存储所有点到1号点的距离\nlong long res=1;\nbool st[N];     // 存储每个点的最短距离是否已确定\nvoid qprime(int n)\n{\n//\tif(n<2)return 0;\n\tfor(int i=2;i<=n/i;i++)\n\t{\n\t\tif(n%i==0)\n\t\t{\n\t\t\twhile(n%i==0)\n\t\t\t{\n\t\t\t\tn/=i;\n\t\t\t\tumap[i]++;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\tif(n>1)umap[n]++;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    while(cin>>n)\n    {\n    \tfor(int i=1;i<=n;i++)\n    \t{\n    \t\tint x=0;\n    \t\tcin>>x;\n    \t\tqprime(x);\n\t\t}\n\t\tfor(auto x:umap)\n\t\t{\n\t\t\tres=res*(x.second+1)%MOD;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\t \n\treturn 0;\t\n}\n```\n\n### 871. 约数之和\n\n```c++\n//int main()中\n\t\tfor(auto x:umap)\n\t\t{\n\t\t\tlong long t=1;\n\t\t\tint p=x.first,j=x.second;\n\t\t\twhile(j--)\n\t\t\t{\n\t\t\t\tt=(t*p+1)%MOD;\n\t\t\t}\n\t\t\tres=(res*t)%MOD;\n\t\t}\n```\n\n### 最小公倍数\n\n```c++\n//最小公倍数=两个数的乘积/最大公约数\n    int a,b;\n    cin>>a>>b;\n    cout << a/gcd(a,b)*b <<endl; //注意:小心x*y直接溢出大于最大范围.\n```\n\n### KY105 整除问题\n\n#### 法一\n\n```c++\nunordered_map<int, int>cnt1;\nunordered_map<int, int>cnt2;\nint n,m,a;      // 点的数量\nint prime[N],flag;        // 存储所有点到1号点的距离\nint st[N];     // 存储每个点的最短距离是否已确定\nint init()\n{\n    int cnt=0;\n    for(int i=2;i<=1000;i++)\n    {\n        if(!st[i])\n        {\n            prime[cnt++]=i;\n            for(int j=i*i;j<=1000;j+=i)\n            {\n                st[j]=1;\n            }\n        }\n         \n    }\n    return cnt;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int cnt=init();\n    while(cin>>n>>a)\n    {        \n        for(int i=0;i<cnt;i++)\n        {\n            int tmp=n;\n            while(tmp)\n            {\n                cnt1[i]+=tmp/prime[i];\n                tmp/=prime[i];\n            }\n        }\n        int res=0x3f3f3f3f3f;\n        for(int i=0;i<cnt;i++)\n        {\n            while(a%prime[i]==0)\n            {\n                cnt2[i]++;\n                a/=prime[i];\n            }\n            if(cnt2[i]==0)continue;\n            if(cnt1[i]/cnt2[i]<res)\n            {\n                res=cnt1[i]/cnt2[i];\n            }\n        }\n        cout<<res<<endl;\n    }  \n    return 0;  \n}\n```\n\n#### 法二\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n//得到数n的质因子及其个数\nvoid getPrime(vector<int>& factors, int n)\n{\n\tfor(int i=2; i<=n/i; i++)\n    {\n\t\twhile(n % i == 0)\n        {\n\t\t\tfactors[i]++;\n\t\t\tn /= i;\n\t\t\tif(n <= 1)\n\t\t\t\treturn;\n\t\t}\n\t}\n\tif(n > 1)\n\t\tfactors[n]++;\n}\n\nint main()\n{\n\tint n, a;\n\twhile(cin >> n >> a)\n    {\n\t\tvector<int> factora(1000), factorn(1000);\n\t\tgetPrime(factora, a);\n\t\t//计算阶乘的每一个数的质因子及其个数；并进行个数的累加\n\t\tfor(int i=2; i<=n; i++)\n\t\t\tgetPrime(factorn, i);\n\t\tint k = 1000;\n\t\t//看2~n包含多少个对应的质因子\n\t\tfor(int i=2; i<=a; i++)\n\t\t\tif(factora[i])\n\t\t\t\tk = min(k, factorn[i]/factora[i]);\n\t\tcout << k << endl;\n\t}\n}\n```\n\n## 欧拉函数\n\n### 873. 欧拉函数\n\n```c++\nint gcd(int a, int b)\n{\n    return b ? gcd(b, a % b) : a;\n}\n//__gcd\n```\n\n### 874. 筛法求欧拉函数\n\n```c++\nint primes[N], cnt;     // primes[]存储所有素数\nint euler[N];           // 存储每个数的欧拉函数\nbool st[N];         // st[x]存储x是否被筛掉\n\n\nvoid get_eulers(int n)\n{\n    euler[1] = 1;\n    for (int i = 2; i <= n; i ++ )\n    {\n        if (!st[i])\n        {\n            primes[cnt ++ ] = i;\n            euler[i] = i - 1;\n        }\n        for (int j = 0; primes[j] <= n / i; j ++ )\n        {\n            int t = primes[j] * i;\n            st[t] = true;\n            if (i % primes[j] == 0)\n            {\n                euler[t] = euler[i] * primes[j];\n                break;\n            }\n            euler[t] = euler[i] * (primes[j] - 1);\n        }\n    }\n}\n```\n\n## 快速幂\n\n### [50. Pow(x, n)](https://leetcode.cn/problems/powx-n/)\n\n递归\n\n```c++\nclass Solution {\npublic:\n    double quickMul(double x, long long N) \n    {\n        if (N == 0) return 1.0;\n        double y = quickMul(x, N / 2);\n        return N % 2 == 0 ? y * y : y * y * x;\n    }\n\n    double myPow(double x, int N) {\n        double ans=1;\n        long long n=N;\n        if(n<0)\n        {\n            n=-n;\n            x=1/x;\n        }\n        \n        return quickMul(x, n);\n    }\n};\n```\n\n\n\n### 875. 快速幂\n\n```c++\n求 m^k mod p，时间复杂度 O(logk)。\nlong long qpow(long long a,int k,int p)\n{\n\tll res=1;\n\twhile(k)\n\t{\n\t\tif(k&1)\n\t\t{\n\t\t\tres=(ll)res*a%p;\n\t\t}\n\t\tk>>=1;\n\t\ta=(ll)a*a%p;\n\t}\n\treturn res;\n}\n```\n\n### 876. 快速幂求逆元\n\n##### 乘法逆元的定义\n\n> 若整数 b，m 互质，并且对于任意的整数 a，如果满足 b|a，则存在一个整数 x，使得 a/b≡a×x(modm)，则称 xx 为 b 的模 m 乘法逆元，记为 b−1(modm)。\n> b 存在乘法逆元的充要条件是 b 与模数 m 互质。当模数 m 为质数时，b^m−2 即为 b 的乘法逆元。\n\n```c++\nll res=qpow(a,p-2,p)\n```\n\n### KY191 矩阵幂\n\n给定一个n*n的矩阵，求该矩阵的k次幂，即P^k。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=11,INF = 0x3f3f3f3f;;\ntypedef pair<int, int> PII;\nint a[N][N]={0};\nint f[N][N]={0};\nint n,k;      // 点的数量\nvoid mul(int c[][N],int a[][N],int b[][N])\n{\n\tint temp[N][N]={0};\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tfor(int k=0;k<n;k++)\n\t\t\t{\n\t\t\t\ttemp[i][j]=(temp[i][j]+a[i][k]*b[k][j]);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tmemcpy(c,temp,sizeof temp);\n}\n\nvoid qpow(int f[][N],int a[][N],int n)\n{\n\twhile(n)\n\t{//快速幂\n        if(n&1)mul(f,f,a);\n        mul(a,a,a);\n        n >>= 1;\n    }\n\treturn ;\n}\nint main()\n{\n    while(cin>>n>>k)\n    {\n        memset(a,0,sizeof(a));\n        memset(f,0,sizeof(f));\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                cin>>a[i][j];\n                if(i==j)\n                f[i][j]=1;\n                else\n                f[i][j]=0;\n            }\n        }\n        qpow(f,a,k);\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                cout<<f[i][j]<< \" \";\n            }\n            cout<<endl;\n        }\n    }\n    return 0;\n}\n```\n\n### KY21 递推数列\n\n给定a0,a1,以及an=p*a(n-1) + q*a(n-2)中的p,q。这里n >= 2。 求第k个数对10000的模。\n\n```c++\nconst int N=2,INF = 0x3f3f3f3f;;\nvoid mul(int c[],int a[],int b[][N])\n{\n\tint temp[N]={0};\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tfor(int j=0;j<N;j++)\n\t\t{\n\t\t\ttemp[i]=(temp[i]+(ll)a[j]*b[j][i])%m;\n\t\t}\n\t}\n\tmemcpy(c,temp,sizeof temp);\n}\nvoid mul(int c[][N],int a[][N],int b[][N])\n{\n\tint temp[N][N]={0};\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tfor(int j=0;j<N;j++)\n\t\t{\n\t\t\tfor(int k=0;k<N;k++)\n\t\t\t{\n\t\t\t\ttemp[i][j]=(temp[i][j]+(ll)a[i][k]*b[k][j])%m;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tmemcpy(c,temp,sizeof temp);\n}\n\nvoid qpow(int f[],int a[][N],int n)\n{\n\twhile(n)\n\t{//快速幂\n        if(n&1)mul(f,f,a);\n        mul(a,a,a);\n        n >>= 1;\n    }\n\treturn ;\n}\nint main()\n{\n    int f[N]={1,1};//f1{f1,f2}\n\tcin >> f[0]>>f[1]>>p>>q>>k;\n    int a[N][N]={0};\n    a[0][0]=0;a[0][1]=q;a[1][0]=1;a[1][1]=p;\n    // k--;\n    qpow(f,a,k-1);\n    cout << f[1];\n    return 0;\n}\n```\n\n直接推做法\n\n```c++\nint main()\n{\n    int a0,a1,p,q,k;\n    int i;\n    while(cin>>a0>>a1>>p>>q>>k)\n    {\n        int a[k+1];\n        a[0]=a0;\n        a[1]=a1;\n        for(i=2;i<k+1;i++) a[i]=(p*a[i-1]+q*a[i-2])%10000;\n        printf(\"%d\\n\",a[k]);\n    }\n}\n```\n\n## 倍增\n\n### [29. 两数相除](https://leetcode.cn/problems/divide-two-integers/)\n\n二分\n\n```c++\n#define debug(a) cout<<#a<<\"=\"<<a<<endl\nclass Solution {\npublic:\n        long mul(long a, long k) \n        {\n            long ans = 0;\n            while (k > 0) {\n                if ((k & 1) == 1) ans += a;\n                k >>= 1;\n                a += a;\n            }\n            return ans;\n    }\n\n    int divide(int _a, int _b) {\n        int flag=0;\n        long a = _a, b = _b;\n        if ((a < 0 && b > 0) || (a > 0 && b < 0)) flag = true;\n        if (a < 0) a = -a;\n        if (b < 0) b = -b;\n        long l=-1,r=(long)(a+1);\n        while(l+1<r)\n        {\n            long mid=l+((r-l)/2);\n            if(mul(mid,(long)b)<=(long)a)l=mid;\n            else r=mid;\n        }\n        // if(l<0)l=0;\n        l=flag?-l:l;\n        debug(l);\n        debug(flag);\n        if(l>INT_MAX||l<INT_MIN)return INT_MAX;\n        return (int)l;\n    }\n};\n```\n\n","tags":["加密文章tag"],"categories":["Algorithm"]},{"title":"greedy","url":"/2024/09/19/greedy/","content":"# 贪心\n\n| 子序列 | [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/) | HOT100                                                       | dp or贪心                                                    |        |\n| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------ |\n|        | 变式（板子三）：[KY141 最大连续子序列](https://www.nowcoder.com/practice/afe7c043f0644f60af98a0fba61af8e7?tpId=63&tqId=29588&tPage=2&ru=/kaoyan/retest/9001&qru=/ta/zju-kaoyan/question-ranking) | [【图解】不需要倒推就能找到开始下标的方法，一次遍历_牛客博客 (nowcoder.net)](https://blog.nowcoder.net/n/b7218d98c90c4380871d485bfdf8c47a) |                                                              |        |\n|        | 2022/3/5 美团 变式-[1330. 翻转子数组得到最大的数组值](https://leetcode.cn/problems/reverse-subarray-to-maximize-array-value/) | [数学](https://leetcode.cn/problems/reverse-subarray-to-maximize-array-value/solutions/2266500/bu-hui-hua-jian-qing-kan-zhe-pythonjavac-c2s6)<br />[思路还可参考评论](https://leetcode.cn/problems/reverse-subarray-to-maximize-array-value/solutions/2266500/bu-hui-hua-jian-qing-kan-zhe-pythonjavac-c2s6/comments/2015692) |                                                              |        |\n| 排序   | [56. 合并区间                                                | **HOT100**                                                   |                                                              |        |\n|        | [57. 插入区间](https://leetcode.cn/problems/insert-interval/) |                                                              | 可直接56 or模拟 or二分                                       |        |\n|        | [919 · 会议室 II - LintCode](https://www.lintcode.com/problem/919/description) |                                                              |                                                              |        |\n|        | [179. 最大数](https://leetcode.cn/problems/largest-number/)  | 排序比较 两个字符串return x+y>y+x;<br/>[证明](https://leetcode.cn/problems/largest-number/solutions/716725/gong-shui-san-xie-noxiang-xin-ke-xue-xi-vn86e) |                                                              |        |\n|        | [769. 最多能完成排序的块](https://leetcode.cn/problems/max-chunks-to-make-sorted/) | 可以直接贪心                                                 | 单调栈                                                       | 前缀和 |\n|        | [768. 最多能完成排序的块 II](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/) | 贪心+前后缀                                                  | 单调栈和769相同                                              |        |\n| 贪心   | [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/) | **HOT100**                                                   |                                                              |        |\n|        | [55. 跳跃游戏](https://leetcode.cn/problems/jump-game)       | **HOT100**                                                   | 贪心记录当前的跳跃范围和最大的跳跃<br />循环到nums.size()-1  |        |\n|        | [763. 划分字母区间](https://leetcode.cn/problems/partition-labels/) | **HOT100**                                                   | [贪心](https://leetcode.cn/problems/partition-labels/solutions/455814/shou-hua-tu-jie-hua-fen-zi-mu-qu-jian-ji-lu-zui-yu)，确定每个segment窗口的left和right |        |\n\n## [134. 加油站](https://leetcode.cn/problems/gas-station/)\n\n### [法一](https://leetcode.cn/problems/gas-station/solution/shi-yong-tu-de-si-xiang-fen-xi-gai-wen-ti-by-cyayc/)\n\n```c++\nclass Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int cur=0,cursum=0,res=0;\n        int minn=INT_MAX;\n        for(int i=0;i<gas.size();i++)\n        {\n            cur+=gas[i]-cost[i];\n            \n            if(cur<minn)\n            {\n                minn=cur;\n                res=i;\n            }\n        }\n        if(cur<0)\n        {\n            return -1;\n        }\n        return (res+1)%gas.size();\n    }\n};\n```\n\n\n\n### [法二&法三](https://programmercarl.com/0134.%E5%8A%A0%E6%B2%B9%E7%AB%99.html#贪心算法-方法二)\n\n```c++\n//2\nclass Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int cur=0,cursum=0,res=0;\n        int minn=INT_MAX;\n        for(int i=0;i<gas.size();i++)\n        {\n            cur+=gas[i]-cost[i];\n            \n            if(cur<minn)\n            {\n                minn=cur;\n            }\n        }\n        if(cur<0)return -1;\n        if(minn>=0)return 0;\n        for(int i=gas.size()-1;i>=0;i--)\n        {\n            minn+=gas[i]-cost[i];\n            if(minn>=0)\n            {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n\n//3\nclass Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int cur=0,cursum=0,res=0;\n        int minn=INT_MAX;\n        for(int i=0;i<gas.size();i++)\n        {\n            cur+=gas[i]-cost[i];\n            cursum+=gas[i]-cost[i];\n            if(cursum<0)\n            {\n                res=i+1;\n                cursum=0;\n            }\n        }\n        if(cur<0)return -1;\n       \n        return res;\n    }\n};\n```\n\n## [406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)\n\n### [法一](https://programmercarl.com/0406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html#思路)\n\n## [763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)\n\n## [738. 单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/)\n\n看写法\n\n## [968. 监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/)\n\n贪心\n\n# 图论\n\n## 求割点\n\n### [TARJAN](https://www.bilibili.com/video/BV1Q7411e7bM?p=4&vd_source=446947e89517447be9aac68199196f4f)\n\n[【朝夕的ACM笔记】图论-割点 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/269306969)\n","tags":["加密文章tag"],"categories":["Algorithm"]},{"title":"ml","url":"/2024/09/19/ml/","content":"\n[ref](https://mp.weixin.qq.com/s/FK28E4eBSv3rYeNdmkMGOg)\n[ref2较全](https://mp.weixin.qq.com/s/7TOgX24hW2YP9oY5DF4E7Q)\n\n\n绝对位置编码，旋转位置编码，mha，mqa，gqa，ln，bn，rn，dn，ffn\n\nrope\n\nAUC\n\nlr\n\ngbdt\n\n## SelfAttention\n\n```py\nfrom math import sqrt\nimport torch\nimport torch.nn as nn\n\n# Define the SelfAttention module\nclass SelfAttention(nn.Module):\n    def __init__(self, dim_in, dim_k, dim_v):\n        super(SelfAttention, self).__init__()\n        self.dim_in = dim_in\n        self.dim_k = dim_k\n        self.dim_v = dim_v\n        self.linear_q = nn.Linear(dim_in, dim_k, bias=False)\n        self.linear_k = nn.Linear(dim_in, dim_k, bias=False)\n        self.linear_v = nn.Linear(dim_in, dim_v, bias=False)\n        self._norm_fact = 1 / sqrt(dim_k)\n\n    def forward(self, x):\n        batch, n, dim_in = x.shape\n        assert dim_in == self.dim_in\n\n        q = self.linear_q(x)\n        k = self.linear_k(x)\n        v = self.linear_v(x)\n\n        dist = torch.bmm(q, k.transpose(1, 2)) * self._norm_fact\n        dist = torch.softmax(dist, dim=-2)\n\n        att = torch.bmm(dist, v)\n        return dist, att\n\nif __name__ == \"__main__\":\n    n_q, n_k, n_v = 2, 4, 4\n    d_q, d_k, d_v = 128, 128, 64\n    batch = 1\n\n    q = torch.randn(batch, n_q, d_q)\n    k = torch.randn(batch, n_k, d_k)\n    v = torch.randn(batch, n_v, d_v)\n    mask = torch.zeros(batch, n_q, n_k).bool()\n\n    # Create SelfAttention instance with the same parameters\n    attention = SelfAttention(dim_in=d_q, dim_k=d_k, dim_v=d_v)\n    dist, output = attention(q)\n\n    print(dist)\n    print(output)\n\n```\n\n```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass SelfAttention(nn.Module):\n    def __init__(self, embed_dim, num_heads=8, dropout=0.1):\n        super().__init__()\n        self.embed_dim = embed_dim\n        self.num_heads = num_heads\n        self.head_dim = embed_dim // num_heads\n        assert self.head_dim * num_heads == embed_dim, \"embed_dim must be divisible by num_heads\"\n        \n        self.q_proj = nn.Linear(embed_dim, embed_dim)\n        self.k_proj = nn.Linear(embed_dim, embed_dim)  \n        self.v_proj = nn.Linear(embed_dim, embed_dim)\n        self.dropout = nn.Dropout(dropout)\n        self.out_proj = nn.Linear(embed_dim, embed_dim)\n        \n    def forward(self, x):\n        # x shape: (batch_size, seq_len, embed_dim)\n        batch_size, seq_len, embed_dim = x.shape\n        \n        # Project input into Q, K, V\n        q = self.q_proj(x)\n        k = self.k_proj(x)\n        v = self.v_proj(x)\n        \n        # Reshape Q, K, V for multi-head attention\n        q = q.reshape(batch_size, seq_len, self.num_heads, self.head_dim).transpose(1, 2)\n        k = k.reshape(batch_size, seq_len, self.num_heads, self.head_dim).transpose(1, 2)\n        v = v.reshape(batch_size, seq_len, self.num_heads, self.head_dim).transpose(1, 2)\n        \n        # Compute attention scores\n        scores = torch.matmul(q, k.transpose(-2, -1)) / torch.sqrt(torch.tensor(self.head_dim).float())\n        \n        # Apply softmax and dropout\n        attn = F.softmax(scores, dim=-1)\n        attn = self.dropout(attn)\n        \n        # Compute output\n        out = torch.matmul(attn, v)\n        \n        # Reshape and project output\n        out = out.transpose(1, 2).reshape(batch_size, seq_len, embed_dim)\n        out = self.out_proj(out)\n        \n        return out\n```\n\n\n\n## ScaledDotProductAttention\n\n```python\nfrom math import sqrt\n\nimport numpy as np\nimport torch\nimport torch.nn as nn\n\n# refer:https://zhuanlan.zhihu.com/p/366592542\nclass ScaledDotProductAttention(nn.Module):\n    \"\"\" Scaled Dot-Product Attention \"\"\"\n\n    def __init__(self, scale):\n        super().__init__()\n\n        self.scale = scale  # Initialize the scaling factor\n        self.softmax = nn.Softmax(dim=2)  # Initialize softmax function along the last dimension (sequence length)\n\n    def forward(self, q, k, v, mask=None):\n        # Compute the dot product of query and key matrices\n        u = torch.bmm(q, k.transpose(1, 2))  # Shape: (batch_size, n_q, n_k)\n\n        # Scale the dot product by the square root of the dimension of the key vectors\n        u = u / self.scale  # Apply scaling factor\n\n        # Apply masking to prevent attending to certain positions\n        if mask is not None:\n            u = u.masked_fill(mask, -np.inf)  # Replace masked positions with negative infinity\n\n        # Apply softmax to normalize attention scores along the last dimension\n        attn = self.softmax(u)  # Shape: (batch_size, n_q, n_k)\n\n        # Compute the weighted sum of value vectors using the attention scores\n        output = torch.bmm(attn, v)  # Shape: (batch_size, n_q, d_v)\n\n        return attn, output  # Return attention scores and the output\n\n\nif __name__ == \"__main__\":\n    n_q, n_k, n_v = 2, 4, 4\n    d_q, d_k, d_v = 128, 128, 64\n    batch = 1  # Define the batch size\n\n    q = torch.randn(batch, n_q, d_q)\n    k = torch.randn(batch, n_k, d_k)\n    v = torch.randn(batch, n_v, d_v)\n    mask = torch.zeros(batch, n_q, n_k).bool()\n\n    attention = ScaledDotProductAttention(scale=np.power(d_k, 0.5))\n    attn, output = attention(q, k, v, mask=mask)\n\n    print(attn)\n    print(output)\n```\n\n## MultiHeadAttention\n\n```python\nimport numpy as np\nimport torch\nimport torch.nn as nn\n\nfrom ScaledDotProductAttention import ScaledDotProductAttention\n\n\nclass MultiHeadAttention(nn.Module):\n    \"\"\" Multi-Head Attention \"\"\"\n\n    def __init__(self, n_head, d_k_, d_v_, d_k, d_v, d_o):\n        super().__init__()\n\n        self.n_head = n_head\n        self.d_k = d_k# 每个注意力头的键向量维度\n        self.d_v = d_v\n\n        self.fc_q = nn.Linear(d_k_, n_head * d_k)#用于将原始的键向量（维度 d_k_）转换为多头的键向量（维度 n_head * d_k）。\n        self.fc_k = nn.Linear(d_k_, n_head * d_k)\n        self.fc_v = nn.Linear(d_v_, n_head * d_v)\n\n        self.attention = ScaledDotProductAttention(scale=np.power(d_k, 0.5))\n\n        self.fc_o = nn.Linear(n_head * d_v, d_o)\n\n    def forward(self, q, k, v, mask=None):\n\n        n_head, d_q, d_k, d_v = self.n_head, self.d_k, self.d_k, self.d_v\n\n        batch, n_q, d_q_ = q.size()\n        batch, n_k, d_k_ = k.size()# 原始键向量的维度\n        batch, n_v, d_v_ = v.size()\n        print(\"1:\",q.size(), k.size(), v.size())\n        q = self.fc_q(q) # 1.单头变多头\n        k = self.fc_k(k)\n        v = self.fc_v(v)\n        print(q.size(), k.size(), v.size())\n        q = q.view(batch, n_q, n_head, d_q).permute(2, 0, 1, 3).contiguous().view(-1, n_q, d_q)\n        k = k.view(batch, n_k, n_head, d_k).permute(2, 0, 1, 3).contiguous().view(-1, n_k, d_k)\n        v = v.view(batch, n_v, n_head, d_v).permute(2, 0, 1, 3).contiguous().view(-1, n_v, d_v)\n        print(\"3:\", q.size(), k.size(), v.size())\n        if mask is not None:\n            mask = mask.repeat(n_head, 1, 1)\n        attn, output = self.attention(q, k, v, mask=mask) # 2.当成单头注意力求输出\n        # 重新形状为 (batch, n_q, n_head * d_v)。\n        output = output.view(n_head, batch, n_q, d_v).permute(1, 2, 0, 3).contiguous().view(batch, n_q, -1) # 3.Concat\n        output = self.fc_o(output) # 4.仿射变换得到最终输出\n\n        return attn, output\n\n\nif __name__ == \"__main__\":\n    n_q, n_k, n_v = 2, 4, 4\n    d_q_, d_k_, d_v_ = 128, 128, 64\n    batch = 1  # Define the batch size\n    q = torch.randn(batch, n_q, d_q_)\n    k = torch.randn(batch, n_k, d_k_)\n    v = torch.randn(batch, n_v, d_v_)\n    mask = torch.zeros(batch, n_q, n_k).bool()\n\n    mha = MultiHeadAttention(n_head=8, d_k_=128, d_v_=64, d_k=256, d_v=128, d_o=128)\n    attn, output = mha(q, k, v, mask=mask)\n\n    print(attn.size())\n    print(output.size())\n```\n\n## CrossAttention\n\n```python\nimport tensorflow as tf\nclass CrossAttention:\n    def __init__(self, embed_dim, num_heads):\n        self.embed_dim = embed_dim\n        self.num_heads = num_heads\n\n    def split_heads(self, x, batch_size):\n        \"\"\"Split the last dimension into (num_heads, depth).\"\"\"\n        x = tf.reshape(x, (batch_size, -1, self.num_heads, self.embed_dim // self.num_heads))\n        return tf.transpose(x, perm=[0, 2, 1, 3])\n\n    def scaled_dot_product_attention(self, q, k, v):\n        \"\"\"Calculate the attention weights.\"\"\"\n        matmul_qk = tf.matmul(q, k, transpose_b=True)\n\n        # Scale matmul_qk\n        dk = tf.cast(tf.shape(k)[-1], tf.float32)\n        scaled_attention_logits = matmul_qk / tf.sqrt(dk)\n\n        # Softmax is normalized on the last axis (seq_len_k) so that the scores add up to 1.\n        attention_weights = tf.nn.softmax(scaled_attention_logits, axis=-1)\n\n        output = tf.matmul(attention_weights, v)\n        return output\n\n    def __call__(self, bid, volume):\n        batch_size = tf.shape(bid)[0]\n\n        q = tf.layers.dense(bid, self.embed_dim)\n        k = tf.layers.dense(volume, self.embed_dim)\n        v = tf.layers.dense(volume, self.embed_dim)\n\n        q = self.split_heads(q, batch_size)  # (batch_size, num_heads, seq_length_q, depth)\n        k = self.split_heads(k, batch_size)  # (batch_size, num_heads, seq_length_k, depth)\n        v = self.split_heads(v, batch_size)  # (batch_size, num_heads, seq_length_v, depth)\n\n        scaled_attention = self.scaled_dot_product_attention(q, k, v)\n\n        scaled_attention = tf.transpose(scaled_attention, perm=[0, 2, 1, 3])\n        original_size_attention = tf.reshape(scaled_attention, (batch_size, -1, self.embed_dim))\n\n        return original_size_attention\n\n\n# Parameters\nembed_dim = 32\nnum_heads = 4\n\n# Create cross attention\ncross_attention = CrossAttention(embed_dim, num_heads)\n\n# Dummy data\nbatch_size = 8\nseq_length = 10\n\nbid = tf.random_normal((batch_size, seq_length, embed_dim))\nvolume = tf.random_normal((batch_size, seq_length, embed_dim))\n\n# Forward pass\noutput = cross_attention(bid, volume)\n\nwith tf.Session() as sess:\n    sess.run(tf.global_variables_initializer())\n    output_val = sess.run(output)\n    print(\"Bid data:\")\n    print(bid)\n    print(\"\\nVolume data:\")\n    print(volume)\n    print(\"\\nOutput data:\")\n    print(output_val)\n\n    print(output_val.shape)\n\n```\n\n","tags":["加密文章tag"],"categories":["Algorithm"]},{"title":"others","url":"/2024/09/19/others/","content":"\n# 其他\n\n| 模拟   | [8. 字符串转换整数 (atoi)](https://leetcode.cn/problems/string-to-integer-atoi/) |            | 不用longlong                                                 |                                                              |\n| ------ | ------------------------------------------------------------ | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n|        | [12. 整数转罗马数字](https://leetcode.cn/problems/integer-to-roman/) |            | [贪心](https://leetcode.cn/problems/integer-to-roman/solutions/87905/tan-xin-ha-xi-biao-tu-jie-by-ml-zimingmeng)<br />直接打表 |                                                              |\n|        | [13. 罗马数字转整数](https://leetcode.cn/problems/roman-to-integer/) |            | 模拟<br />打表                                               |                                                              |\n|        | [468. 验证IP地址](https://leetcode.cn/problems/validate-ip-address) |            | 条件比较多                                                   |                                                              |\n| 栈     | [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks) |            | 两个栈实现                                                   |                                                              |\n|        | [155. 最小栈](https://leetcode.cn/problems/min-stack/)       | **HOT100** | 不使用辅助栈                                                 |                                                              |\n|        | [394. 字符串解码](https://leetcode.cn/problems/decode-string/) | **HOT100** | dfs or 栈                                                    |                                                              |\n| 计算器 | [227. 基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii/)<br />[面试题 16.26. 计算器](https://leetcode.cn/problems/calculator-lcci/) |            | 包含符号 `+ - * /`<br />[仅本题](https://leetcode.cn/problems/basic-calculator-ii/solutions/91271/chai-jie-fu-za-wen-ti-shi-xian-yi-ge-wan-zheng-ji-) | 一系列栈解法[参考](https://leetcode.cn/problems/basic-calculator-ii/solutions/648832/shi-yong-shuang-zhan-jie-jue-jiu-ji-biao-c65k/comments/826208)<br />**`+ - \\* / ^ % ( )`**<br />可处理负数 |\n|        | [224. 基本计算器](https://leetcode.cn/problems/basic-calculator/) |            | **`+ - ( )`**<br />有负数                                    | [dfs通用](https://leetcode.cn/problems/basic-calculator-ii/solutions/91271/chai-jie-fu-za-wen-ti-shi-xian-yi-ge-wan-zheng-ji-/comments/330884)<br />+ - * / ( ) |\n|        | [849 · 基础计算器 III](https://www.lintcode.com/problem/849/note)<br />[772. 基本计算器 III](https://leetcode.cn/problems/basic-calculator-iii) |            | 包含符号 `+ - * / ( )`                                       |                                                              |\n|        |                                                              |            |                                                              |                                                              |\n| 规律   | [31. 下一个排列](https://leetcode.cn/problems/next-permutation/) | **HOT100** | [参考](https://leetcode.cn/problems/next-permutation/solutions/80560/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-) | 上一个排列：大于改小于                                       |\n| 数学   | [50. Pow(x, n)](https://leetcode.cn/problems/powx-n)         |            | 快速幂（迭代or递归）                                         |                                                              |\n|        | [2550. 猴子碰撞的方法数](https://leetcode.cn/problems/count-collisions-of-monkeys-on-a-polygon/) |            | 反向思维+快速幂                                              |                                                              |\n|        | [29. 两数相除](https://leetcode.cn/problems/divide-two-integers/) |            | 倍增+二分                                                    |                                                              |\n|        | [69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)       |            | 二分<br />[牛顿迭代](https://leetcode.cn/problems/sqrtx/solutions/1408932/by-zhang-jian-qi-shi-kaxt) | 保留小数后k位(二分or[牛顿](https://www.cnblogs.com/z-sm/p/5020754.html)  ) |\n| 位运算 | [136. 只出现一次的数字](https://leetcode.cn/problems/single-number/) | **HOT100** | 位运算异或                                                   |                                                              |\n|        | [2571. 将整数减少到零需要的最少操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-an-integer-to-0/) | 阿里面试   | [位运算](https://leetcode.cn/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/2120204/ji-yi-hua-sou-suo-by-endlesscheng-cm6l) or [dfs](https://leetcode.cn/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/2984367/ju-yi-fan-san-2571-jiang-zheng-shu-jian-0r8og) |                                                              |\n|        | [260. 只出现一次的数字 III](https://leetcode.cn/problems/single-number-iii/) |            | [位运算异或](https://leetcode.cn/problems/single-number-iii/solutions/2484352/tu-jie-yi-zhang-tu-miao-dong-zhuan-huan-np9d2) | C++ 不需要防止溢出，用 `unsigned int` 计算异或和即可。       |\n|        | [137. 只出现一次的数字 II](https://leetcode.cn/problems/single-number-ii/) |            | [位运算异或+优化](https://leetcode.cn/problems/single-number-ii/solutions/2482832/dai-ni-yi-bu-bu-tui-dao-chu-wei-yun-suan-wnwy) |                                                              |\n|        | [1829. 每个查询的最大异或值](https://leetcode.cn/problems/maximum-xor-for-each-query/) |            | 异或                                                         |                                                              |\n|        | [2595. 奇偶位数](https://leetcode.cn/problems/number-of-even-and-odd-bits/) |            | [mask](https://leetcode.cn/problems/number-of-even-and-odd-bits/solutions/2177848/er-jin-zhi-ji-ben-cao-zuo-pythonjavacgo-o82o2) |                                                              |\n|        | [2683. 相邻值的按位异或](https://leetcode.cn/problems/neighboring-bitwise-xor/) |            | 规律                                                         |                                                              |\n|        | [338. 比特位计数](https://leetcode.cn/problems/counting-bits/) |            | [dp](https://leetcode.cn/problems/counting-bits/solutions/725047/yang-cheng-tui-dao-de-xi-guan-by-xiaohu9-g0mi) |                                                              |\n|        | [540. 有序数组中的单一元素](https://leetcode.cn/problems/single-element-in-a-sorted-array) |            | 全数组二分，注意边界（官解）<br />[二分，分成两组](https://leetcode.cn/problems/single-element-in-a-sorted-array/solutions/1193809/er-fen-cha-zhao-liang-liang-fen-zu-by-nz-lycd)<br/> |                                                              |\n|        | [LCR 169. 招式拆解 II](https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/) |            | hash                                                         |                                                              |\n|        | [470. 用 Rand7() 实现 Rand10()](https://leetcode.cn/problems/implement-rand10-using-rand7/) |            | [搞成7进制](https://leetcode.cn/problems/implement-rand10-using-rand7/solutions/978985/gong-shui-san-xie-k-jin-zhi-zhu-wei-shen-zmd4)<br />独立随机事件+古典概 | (randX() - 1)*Y + randY()                                    |\n|        | [7. 整数反转](https://leetcode.cn/problems/reverse-integer/) |            | [注意边界](https://leetcode.cn/problems/reverse-integer/solutions/755611/zheng-shu-fan-zhuan-by-leetcode-solution-bccn) |                                                              |\n|        | [400. 第 N 位数字](https://leetcode.cn/problems/nth-digit/)  |            | 规律（官解）                                                 | 确定所求数位的所在数字的位数<br />确定所求数位所在的数字<br />确定所求数位在 *n**u**m* 的哪一数位 |\n|        | [LCR 162. 数字 1 的个数](https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/)<br />[233. 数字 1 的个数](https://leetcode.cn/problems/number-of-digit-one/) |            | [数位统计](https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solutions/229751/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2)<br />数位dp（还没写 |                                                              |\n| 投票   | [169. 多数元素](https://leetcode.cn/problems/majority-element/) | **HOT100** | [投票](https://leetcode.cn/problems/majority-element/solutions/2362000/169-duo-shu-yuan-su-mo-er-tou-piao-qing-ledrh) or hash |                                                              |\n|        | [229. 多数元素 II](https://leetcode.cn/problems/majority-element-ii/) |            | [投票](https://leetcode.cn/problems/majority-element-ii/solutions/123170/liang-fu-dong-hua-yan-shi-mo-er-tou-piao-fa-zui-zh) |                                                              |\n| 高精度 | [415. 字符串相加](https://leetcode.cn/problems/add-strings)  |            | 大数相加                                                     | 变形：[相减](https://leetcode.cn/circle/discuss/zVtfxd/view/b3QFhK/) |\n|        | [43. 字符串相乘](https://leetcode.cn/problems/multiply-strings/) |            | 大数相乘<br />官解1.字符串存储<br />2.数组存                 |                                                              |\n\n##   [69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)\n\n二分保留6位小数\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=100086;\ndouble n=0.0;\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n\tcin>>n;\n\tdouble l=0, r=10000;\n\twhile(r-l>1e-9)\n\t{\n\t\tdouble mid=(l+r)/2;\n\t\tif(mid*mid>=n)r=mid;\n\t\telse l=mid;\n\t}\n\tprintf(\"%.6lf\\n\",sqrt(n));\n\tprintf(\"%.6lf\\n\",l);\n\treturn 0;\t\n}\n```\n\n\n\n## [224. 基本计算器](https://leetcode.cn/problems/basic-calculator/)\n\n### 栈\n\n所有情况\n\n```c++\n\"-2*(5+5*2)/3+(6/2+8)\"\n -2*((-5)+5*2)/3+(6/2+8)\n1-(     -2)\n```\n\n```c++\nclass Solution {\npublic:\n    stack<char> opers;\n    stack<long long> nums;\n    void replace(string& s){\n        int pos = s.find(\" \");\n        while (pos != -1) {\n            s.replace(pos, 1, \"\");\n            pos = s.find(\" \");\n        }\n    }\n    unordered_map<char,int> oper_pri = {\n            {'+',1},\n            {'-',1},\n            {'*',2},\n            {'/',2},\n            {'%',2},\n            {'^',3}\n    };        \n    void cal()\n    {\n        long long b = nums.top(); nums.pop();\n        long long a = nums.top(); nums.pop();\n        char oper = opers.top(); opers.pop();\n        long long res=0;\n        switch (oper) \n        {\n            case '+':   res = a + b; break;\n            case '-':   res = a - b; break;\n            case '*':   res = a * b; break;\n            case '/':   res = a / b; break;\n            case '%':   res = a % b; break;\n            case '^':   res = pow(a,b); break;\n        }\n        nums.push(res);\n    }\n    int calculate(string s) {\n        long long num=0;\n        replace(s);// 将所有的空格去掉\n        int n=s.size();\n        int res=0;\n        nums.push(0);//edge case -2* ... 为了防止第一个数为负数，先往 nums 加个 0\n        for(int i=0;i<n;i++)\n        {\n           if(s[i]>='0'&&s[i]<='9')\n           {\n                int l = i;\n                while(i+1<n && '0'<=s[i+1] && s[i+1]<='9')i++;\n                nums.push(stoll(s.substr(l,i-l+1)));\n           }\n           else if(s[i]==' ') continue;\n           else if(s[i]=='(')\n           {\n                opers.push('(');\n                if(s[i+1]=='-')//edge case:(-5 ....\n                {\n                    i++;\n                    nums.push(0);\n                    opers.push('-');\n                }\n           }\n           else if(s[i]==')')\n           {\n               \n                while(opers.top()!='(')cal();\n                opers.pop();\n            }\n           \n           else \n           {\n               \n                while(!opers.empty() && opers.top()!='(' && oper_pri[opers.top()] >= oper_pri[s[i]])\n                {\n                    cal();\n                }\n                opers.push(s[i]);\n\n           }\n        }\n        while(!opers.empty() && opers.top()!='(') cal();\n        \n        return nums.top();\n    }\n};\n```\n\n### dfs\n\n+- * / ( )\n\n```c++\nclass Solution {\npublic:\n    /**\n     * @param s: the expression string\n     * @return: the answer\n     */\n    int dfs(string& s,int &i)\n    {\n        char preSign = '+';\n        int res=0;\n        stack<int> nums;\n        int n=s.size();\n        int num=0;\n        for(;i<s.size();i++)\n        {\n           if(s[i]>='0'&&s[i]<='9')num=num*10+s[i]-'0';\n           \n           else if(s[i]=='(')\n           {\n                i++;\n                num=dfs(s,i);\n                i++;// 结束后指向)\n                \n           }\n           if((!(s[i]>='0'&&s[i]<='9')&&s[i]!=' ')||i>=n-1)\n           {\n                switch(preSign)\n                {\n                    case '+':\n                        nums.push(num);\n                        break;\n                    case '-':\n                        nums.push(-num);\n                        break;\n                    case '*':\n                        nums.top()*=num;\n                        break;\n                    default:\n                        nums.top()/=num;\n                        break;\n\n                }\n                preSign=s[i];\n                num=0;\n           }\n           if(s[i]==')')\n           {\n                break;\n           }\n           \n        }\n        while (!nums.empty())\n        {\n            res += nums.top();\n            nums.pop();\n        }\n        return res;\n    }\n    int calculate(string s) {\n        int i=0;\n        return dfs(s,i);\n    }\n};\n```\n\n","tags":["加密文章tag"],"categories":["Algorithm"]},{"title":"Binary Search","url":"/2024/09/19/Binary-Search/","content":"\n\n|      | [74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/) | HOT100     | 两次二分 or 排除法 or 转成一维数组                           |                                                              |\n| ---- | ------------------------------------------------------------ | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n|      | [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/) |            | 排除法+二分                                                  | 二分（变种能做，改一下return true）变种：矩阵有重复值，要找到横纵坐标和最小的目标值 |\n|      | [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/) | **HOT100** | 板子                                                         |                                                              |\n|      | [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/) | **HOT100** | 二分（[和最后一位比较](https://leetcode.cn/problems/search-in-rotated-sorted-array/solutions/) |                                                              |\n|      | [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/) | **HOT100** | 二分（[分类讨论](https://leetcode.cn/problems/search-in-rotated-sorted-array/solutions/1987503/by-endlesscheng-auuh)）<br />[两次二分](https://leetcode.cn/problems/search-in-rotated-sorted-array/solutions/1987503/by-endlesscheng-auuh)（先153 |                                                              |\n|      | [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/) | **HOT100** | [解法3&4](https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/8999/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2)<br />解法三能解决第k位（二分递归or迭代）<br />解法四找分割点 |                                                              |\n|      | [162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/) |            | [注意](https://leetcode.cn/problems/find-peak-element/solutions/1987497/by-endlesscheng-9ass)<br />*nums*[*i*]<=*nums*[*i*+1] l=mid<br />r的范围是n-2 |                                                              |\n|      | [852. 山脉数组的峰顶索引](https://leetcode.cn/problems/peak-index-in-a-mountain-array/) |            | 162简化版（只有一个峰值），一个code                          |                                                              |\n|      | [1095. 山脉数组中查找目标值](https://leetcode.cn/problems/find-in-mountain-array/) |            | 找到峰值分别搜，注意边界                                     |                                                              |\n|      | [1300. 转变数组后最接近目标值的数组和](https://leetcode.cn/problems/sum-of-mutated-array-closest-to-target/) |            | 二分or前缀和                                                 |                                                              |\n\n## [1782. 统计点对的数目](https://leetcode.cn/problems/count-pairs-of-nodes/)\n\n官解+官解评论\n\n```cpp\nstruct pairHash {\n    template<typename T, typename U>\n    size_t operator()(const pair<T, U> &p) const {\n        return hash<T>()(p.first) ^ hash<U>()(p.second);\n    }\n\n    template<typename T, typename U>\n    bool operator()(const pair<T, U> &p1, const pair<T, U> &p2) const {\n        return p1.first == p2.first && p1.second == p2.second;\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countPairs(int n, vector<vector<int>>& edges, vector<int>& queries) {\n        vector<int> d(n + 1);\n        unordered_map<pair<int, int>, int, pairHash, pairHash> counter;\n        for(auto&e: edges) {\n            d[e[0]]++;\n            d[e[1]]++;\n            int a = min(e[0], e[1]), b = max(e[0], e[1]);\n            counter[{a, b}]++;\n        }\n        vector<int> sd;\n        for(int i = 1; i <= n; i++) sd.push_back(d[i]);\n        sort(sd.begin(), sd.end());\n        int q = queries.size();\n        vector<int> ans(q);\n        for(int index = 0; index < q; index++) {\n            int cnt = queries[index];\n            int s1 = 0, s2 = 0, s3 = 0;\n            for(auto&[edge, dab]: counter) {\n                int a = edge.first, b = edge.second;\n                if(d[a] + d[b] - dab > cnt) s1++;\n                if(d[a] + d[b] > cnt) s2++;\n            }\n            for(int i = 0; i < n; i++) {\n                int j = upper_bound(sd.begin() + i + 1, sd.end(), cnt - sd[i]) - sd.begin();\n                s3 += n - j;\n            }\n            ans[index] = s1 + (s3 - s2);\n        }\n        return ans;\n    }\n};\n```\n\n## 2560.\n\n[description](https://leetcode.cn/problems/house-robber-iv/)\n\n[refer1](https://leetcode.cn/problems/house-robber-iv/solution/dao-ge-shua-ti-er-fen-fa-dong-tai-gui-hu-la3m/)\n\n[refer2](https://leetcode.cn/problems/house-robber-iv/solution/er-fen-da-an-dp-by-endlesscheng-m558/)\n\n```c++\nclass Solution {\npublic:\n    int check(int mid,int k,vector<int>& nums)\n    {\n        int dp0=0,dp1=0;\n        // dp0表示dp[i-1]，dp1表示dp[i]\n        // 计算窃取不相邻房屋能窃取的房屋个数count，可以使用动态规划。\n        // 动规定义：\n        // dp[i]：表示在前i个房间窃取金额不超过c的最大房屋个数\n        // 动规方程：\n        // 分类讨论：\n        // 当nums[i - 1] > c 时：\n        // dp[i] = dp[i - 1];\n        // 当nums[i - 1] <= c 时:\n        // 分类讨论：\n        // 不选第i个房屋：dp[i] = dp[i - 1];\n        // 选第i个房屋，前提是金额不超过c： dp[i] = dp[i - 2] + 1\n        // 故： dp[i] = Math.max(dp[i-1], dp[i-2] + 1)\n        for(int x:nums)\n        {\n            if(x>mid)dp0=dp1;\n            else\n            {\n                int tmp=dp1;//dp[i-2]\n                dp1=max(dp0+1,dp1);\n                dp0=tmp;\n            }\n            if(dp1>=k)return 1;\n        }\n        return 0;\n        \n    }\n    int minCapability(vector<int>& nums, int k) {\n        // # 有能力窃取时：\n        // # 当前位置不窃取：从前一房屋的两状态中取最大值\n        // # 当前位置窃取：前一房屋只能不窃取\n        // # 没有能力窃取时：\n        // # 当前位置不窃取：从前一房屋的两状态中取最大值\n        // # 当前位置无法窃取，方法数为 0\n        int l=*min_element(nums.begin(),nums.end())-1;\n        int r=*max_element(nums.begin(),nums.end())+1;\n        int m;\n        while(l+1<r)\n        {\n            int mid = l+ (( r - l )>> 1);\n            // debug(mid);\n            \n            if(check(mid,k,nums))\n            {\n                r=mid;\n            }\n            else\n            {\n                l=mid;\n            }\n            // debug(l);\n            // debug(r);\n        }\n        return r;\n    }\n};\n```\n\n## 2439.\n\n[description](https://leetcode.cn/problems/minimize-maximum-of-array/)\n\n```c++\nclass Solution {\npublic:\n    int check(int mid,vector<int>& nums)\n    {\n        long long have=0;\n        for(int x:nums)\n        {\n            if(x>mid)\n            {\n                if(have<(x-mid))return 0;\n                else\n                {\n                    have-=(x-mid);\n                }\n            }\n            else\n            {\n                have+=(mid-x);\n            }\n            \n        }\n        return 1;\n        \n    }\n    int minimizeArrayValue(vector<int>& nums) {\n        int l=*min_element(nums.begin(),nums.end())-1;\n        int r=*max_element(nums.begin(),nums.end())+1;\n        while(l+1<r)\n        {\n            int mid=l+((r-l)>>1);\n            if(check(mid,nums))\n            {\n                r=mid;\n            }\n            else\n            {\n                l=mid;\n            }\n        }\n        return r;\n    }\n};\n```\n\n## **2513.**\n\n[refer1](https://leetcode.cn/problems/minimize-the-maximum-of-two-arrays/solution/wsm-by-73zp-f7va/)\n\n[refer2](https://leetcode.cn/problems/minimize-the-maximum-of-two-arrays/solution/er-fen-da-an-by-endlesscheng-y8fp/)\n\n### 二分\n\n```c++\nclass Solution {\npublic:\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\n        long long t = lcm((long long)divisor1, (long long)divisor2);\n        long long l = uniqueCnt1 + uniqueCnt2-1, r = 2 * l+1 ;\n        while (l + 1 < r) \n        {\n            long long x = (l + r) >> 1;\n            if ((x - x / divisor1 < uniqueCnt1) || (x - x / divisor2 < uniqueCnt2) || (x - x / t < uniqueCnt1 + uniqueCnt2)) \n            {\n                l = x ;\n            } \n            else \n            {\n                r = x;\n            }\n        }\n        return r;\n    }\n};\n```\n\n### 数学\n\n```c++\nclass Solution {\npublic:\n// Function to calculate gcd\n    int gcd(int a, int b) {\n        if (a == b) {\n            return a;\n        }\n        return a > b ? gcd(b, a - b) : gcd(a, b - a);\n    }\n\n    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\n        // Calculate the maximum number of items required for set 1 (size of set 1 plus the number of items that cannot be chosen in set 1)\n        int max1 = uniqueCnt1 + (uniqueCnt1 - 1) / (divisor1 - 1);\n        // Calculate the maximum number of items required for set 2 (size of set 2 plus the number of items that cannot be chosen in set 2)\n        int max2 = uniqueCnt2 + (uniqueCnt2 - 1) / (divisor2 - 1);\n        // Calculate the least common multiple of the two numbers\n        long long lcm = 1LL * divisor2 / gcd(divisor1, divisor2) * divisor1;\n        // Calculate the maximum number of items required for the least common multiple of the two numbers (sum of all items in both sets plus the number of items that cannot be chosen in both sets)\n        int max3 = (int)(uniqueCnt1 + uniqueCnt2 + (uniqueCnt1 + uniqueCnt2 - 1) / (lcm - 1));\n        // Return the maximum of all the maximums\n        return max(max3, max(max1, max2));\n    }\n    \n};\n```\n\n## 2517.\n\n[description](https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/submissions/)\n\n[refer](https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/solution/by-lcfgrn-73ui/)\n\n```c++\nclass Solution {\npublic:\n    int check(int mid,int k,vector<int>& nums)\n    {\n        int cur=0,cnt=0;\n        for(int x:nums)\n        {\n            if(cur<=x)\n            {\n                cur=x+mid;\n                cnt++;\n            }\n            if(cnt==k)return 1;\n        }\n        return 0;\n        \n    }\n    int maximumTastiness(vector<int>& nums, int k) {\n        sort(nums.begin(),nums.end());\n        int l=0,r=*max_element(nums.begin(),nums.end())-*min_element(nums.begin(),nums.end())+1;\n        while(l+1<r)\n        {\n            int mid=l+((r-l)>>1);\n            if(check(mid,k,nums))\n            {\n                l=mid;\n            }\n            else\n            {\n                r=mid;\n            }\n        }\n        return l;\n    }\n};\n```\n\n## [2616. 最小化数对的最大差值](https://leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/)\n\n## [2861. 最大合金数](https://leetcode.cn/problems/maximum-number-of-alloys/)\n\n## [2187. 完成旅途的最少时间](https://leetcode.cn/problems/minimum-time-to-complete-trips/)\n\n## [2226. 每个小孩最多能分到多少糖果](https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/)\n\n二分，注意上界r=sum/k+1;\n\n## [3281. 范围内整数的最大得分](https://leetcode.cn/problems/maximize-score-of-numbers-in-ranges/)\n\n## **4-2 子序列的平均值**\n\n给定一个长度为*n*的非负序列*A*，请你找出一个长度不小于*L*的子段（子段是序列A中一些连续的元素构成的集合），使得子段中数值的平均值最大。最终输出这个最大的平均值。\n\n### 输入格式:\n\n第一行两个整数*n*,*L*(1<=*L*<=*n*<=100,000)\n\n以下*n*行，每行一个非负整数，表示序列*A*中每个元素的值。\n\n### 输出格式:\n\n一个整数，**欲求的最大平均值乘以1000后的结果（注意不要四舍五入，直接输出）**。\n\n### 输入样例:\n\n```in\n10 6\n6 \n4\n2\n10\n3\n8\n5\n9\n4\n1\n```\n\n### 输出样例:\n\n```out\n6500\n```\n\n```c++\n#include<bits/stdc++.h>\n#define debug(a) cout<<#a<<\"=\"<<a<<endl\n#define ll long long\nusing namespace std;\ndouble a[100010];\ndouble b[100010];\ndouble sum[100010];\n\nint n, L;\n\nint check(double mid)\n{\n\tdouble mins;\n\tfor(int i = 1; i <= n; i ++ )\n\t{//求i到j的和应该是sum[j]-sum[i-1] \n\t\tb[i - 1] = a[i - 1] - mid;\n\t\tsum[i] = sum[i - 1] + b[i - 1];\n\t} \t//前缀和处理 \n\tmins = 1e9;\n\tfor(int i = L; i <= n; i ++ )\n\t{\n\t\t\n\t\tmins = min(mins, sum[i - L]);\n\t\tif(sum[i] - mins >= 0)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tcin >> n >> L;\n\tdouble minn = 1e9, maxx = 0;\n\tfor(int i = 0; i < n; i ++ )\n\t{\n\t\tcin>>a[i];\n\t\tminn = min(a[i], minn);\n\t\tmaxx = max(a[i], maxx); \t\n\t}\n\t\n\tdouble l = minn;\n\tdouble r = maxx;\n\t\n\twhile(r - l > 1e-5)\n\t{\n\t\tdouble mid = l+ (( r - l ) / 2);\n\t\tif(check(mid))\n\t\t{  //满足条件说明平均数可以更大 \n\t\t\tl = mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr = mid;\n\t\t}\n\t}\n\tl += 1e-5;\n\tprintf(\"%d\", int(l*1000));\n\treturn 0;\n}\n```\n\n## [373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/)\n\n堆\n\n### [二分](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/solutions/1209848/gong-shui-san-xie-duo-lu-gui-bing-yun-yo-pgw5)\n\n```c++\n#define debug(a) cout<<#a<<\"=\"<<a<<\" \"\nclass Solution {\npublic:\n    vector<int> nums1, nums2;\n    int n, m;\n    int check1(int x,int k)\n    {\n        int ans = 0;\n        for(int i = 0; i < m && ans < k; i++)\n        {\n            for(int j = 0; j < n && ans < k; j++)\n            {\n                if(nums1[i] + nums2[j] <= x) ans++;\n                else break;\n            }\n        }\n        return ans < k;\n    } \n    int bsearch1(int l, int r,int target)\n    {\n        while (l + 1 < r)\n        {\n            \n            int mid = l+ (( r - l )>> 1);\n    //\t\tdebug(mid);\n    //\t\tdebug(l);\n    //\t\tdebug(r);\n            if (check1(mid,target)) l = mid;    // check()判断mid是否满足性质\n            else r = mid ;\n        }\n        return r;\n    }\n    vector<vector<int>> kSmallestPairs(vector<int>& n1, vector<int>& n2, int k) {\n        nums1 = n1;\n        nums2 = n2;\n        m=nums1.size(),n=nums2.size();\n        vector<vector<int>> ans;\n        int l=nums1[0]+nums2[0]-1,r=nums1[m-1]+nums2[n-1]+1;\n        //找到第一个满足「点对和小于等于 x 的，且数量超过 k 的值 x」。\n        int x=bsearch1(l,r,k);\n        // debug(x);\n        //判定小于等于 x 的点对数量是否大于等于 k 个这一步可直接使用循环来做\n        for(int i = 0; i < m; i++)\n        {\n            for(int j = 0; j < n; j++)\n            {\n                if(nums1[i] + nums2[j] < x)\n                {\n                    ans.push_back( {nums1[i], nums2[j]} );\n                }\n                else break;\n            }\n        }\n        // for(auto x:ans)\n        // {\n        //     debug(x[0]);\n        //     debug(x[1]);\n        //     cout<<endl;\n        // }\n        for(int i=0;i<m && ans.size()<k;i++)\n        {\n            int a=nums1[i],b=x-a;\n            // debug(b);\n            int l=-1,r=n;\n            //找nums2符合值=b的左边界\n            while (l + 1 < r)\n            {\n                \n                int mid = l+ (( r - l )>> 1);\n                if (nums2[mid]<b) l = mid;    // check()判断mid是否满足性质\n                else r = mid ;\n            }\n            if(r<n&&nums2[r]!=b)continue;\n            int left=r;\n            debug(left);\n            //找nums2符合值=b的右边界\n            l=-1,r=n;\n            while (l + 1 < r)\n            {\n                \n                int mid = l+ (( r - l )>> 1);\n                if (nums2[mid]<=b) l = mid;    // check()判断mid是否满足性质\n                else r = mid ;\n            }\n            int right=l;\n            debug(right);\n            for(int p=left;p<=right &&ans.size()<k;p++)\n            {\n                ans.push_back( {a, b} );\n            }\n        }\n        return ans;\n    }\n};\n```\n\n## [786. 第 K 个最小的质数分数](https://leetcode.cn/problems/k-th-smallest-prime-fraction/)\n\n### [二分](https://leetcode.cn/problems/k-th-smallest-prime-fraction/solutions/1127751/gong-shui-san-xie-yi-ti-shuang-jie-you-x-8ymk)\n\n```c++\nclass Solution {\npublic:\n    double eps = 1e-8;\n    vector<int> arr;\n    int n, a, b;\n    int check(double x,int k) \n    {\n        int ans = 0;\n        for (int i = 0, j = 1; j < n; j++) \n        {\n            while ((double)((double)arr[i + 1] * 1.0 / (double)arr[j]) <= x) i++;\n            if ((double)((double)arr[i] * 1.0 / (double)arr[j]) <= x) ans += i + 1;\n            if (abs((double)((double)arr[i] * 1.0 / (double)arr[j]) - x) < eps) \n            {\n                a = arr[i];\n                b = arr[j];\n            }\n        }\n        return ans>=k;\n    }\n    vector<int> kthSmallestPrimeFraction(vector<int>&_arr, int k) \n    {\n        arr = _arr;\n        n = arr.size();\n        double l = 0, r = 1;\n        while (r - l > eps) \n        {\n            double mid = (l + r) / 2;\n            if (check(mid,k)) r = mid;\n            else l = mid;\n        }\n        return {a, b};\n    }\n};\n```\n\n##   [719. 找出第 K 小的数对距离](https://leetcode.cn/problems/find-k-th-smallest-pair-distance/)\n\n## [378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)\n\n##   [668. 乘法表中第k小的数](https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/)\n\n","tags":["加密文章tag"],"categories":["Algorithm"]},{"title":"graph","url":"/2024/09/19/graph/","content":"# 图论\n\n|                  | [797. 所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/) |                                                              | dfs([建图](https://programmercarl.com/kamacoder/0098.%E6%89%80%E6%9C%89%E5%8F%AF%E8%BE%BE%E8%B7%AF%E5%BE%84.html)) <br />bfs入队出队为路径 |      |\n| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ---- |\n| 并查集           | [1971. 寻找图中是否存在路径](https://leetcode.cn/problems/find-if-path-exists-in-graph/) |                                                              | dfs，bfs，并查集                                             |      |\n|                  | [684. 冗余连接](https://leetcode.cn/problems/redundant-connection) |                                                              | [并查集](https://leetcode.cn/problems/redundant-connection-ii/solutions/417164/685-rong-yu-lian-jie-iibing-cha-ji-de-ying-yong-xi) |      |\n|                  | [685. 冗余连接 II](https://leetcode.cn/problems/redundant-connection-ii/) |                                                              | [三种情况](https://leetcode.cn/problems/redundant-connection-ii/solutions/417164/685-rong-yu-lian-jie-iibing-cha-ji-de-ying-yong-xi) |      |\n| 岛屿问题（网格） | [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/) | **HOT100**                                                   | dfs bfs [并查集（含模板）](https://leetcode.cn/problems/number-of-islands/solutions/2349128/dao-yu-wen-ti-jing-dian-dfs-bfs-bing-cha-jgce)<br /> |      |\n|                  | [695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)<br />[LCR 105. 岛屿的最大面积](https://leetcode.cn/problems/ZL6zAn/) |                                                              | dfs bfs 并查集                                               |      |\n|                  | [463. 岛屿的周长](https://leetcode.cn/problems/island-perimeter/) |                                                              | 迭代                                                         |      |\n|                  | [860 · 不同岛屿的个数](https://www.lintcode.com/problem/860)<br />[694. 不同岛屿的数量](https://leetcode.cn/problems/number-of-distinct-islands) |                                                              | [bfs+dfs](https://blog.csdn.net/qq_21201267/article/details/107419494)<br />记录一个岛屿所有点相对于左上角的点的相对位置； |      |\n|                  | [1254. 统计封闭岛屿的数目](https://leetcode.cn/problems/number-of-closed-islands/) | [dfs写法二](https://leetcode.cn/problems/number-of-closed-islands/solutions/2312616/liang-chong-si-lu-xian-wai-hou-nei-chu-j-b1e4)（也可在for循环外面判断）<br/>bfs<br />[dfs思路1](https://leetcode.cn/problems/number-of-closed-islands/solutions/2312616/liang-chong-si-lu-xian-wai-hou-nei-chu-j-b1e4)<br />[并查集](https://leetcode.cn/problems/number-of-closed-islands/solutions/2312631/python3javacgotypescript-yi-ti-shuang-ji-ttoe) | 并查集的坑：未遍历到的节点size肯定是1，已经遍历的size>=1，新节点合并只会合并到已有的树上。<br />`if(s[y]<s[x])` |      |\n|                  | [827. 最大人工岛](https://leetcode.cn/problems/making-a-large-island/) | [dfs思路](https://leetcode.cn/problems/making-a-large-island/solutions/2808887/jian-ji-gao-xiao-ji-suan-dao-yu-de-mian-ab4h7) or [并查集](https://leetcode.cn/problems/making-a-large-island/solutions/1830996/by-ac_oier-1kmp) | 先算面积，再枚举0                                            |      |\n|                  | [815. 公交路线](https://leetcode.cn/problems/bus-routes/)    | 每日一题                                                     | [bfs](https://leetcode.cn/problems/bus-routes/solutions/2916806/tu-jie-bfspythonjavacgojsrust-by-endless-t7oc) |      |\n| 多源bfs          | [994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/) | **HOT100**                                                   |                                                              |      |\n| 双向bfs          | [127. 单词接龙](https://leetcode.cn/problems/word-ladder/)   |                                                              | [双向](https://leetcode.cn/problems/word-ladder/solutions/831894/gong-shui-san-xie-ru-he-shi-yong-shuang-magjd/comments/1040291)<br />直接bfs[思路](https://leetcode.cn/problems/word-ladder/solutions/831894/gong-shui-san-xie-ru-he-shi-yong-shuang-magjd/comments/1040291) |      |\n|                  | [126. 单词接龙 II](https://leetcode.cn/problems/word-ladder-ii/) |                                                              | [bfs存图+dfs找序列](https://leetcode.cn/problems/word-ladder-ii/solutions/277612/yan-du-you-xian-bian-li-shuang-xiang-yan-du-you--2) |      |\n| 拓扑             | [207. 课程表](https://leetcode.cn/problems/course-schedule/) | **HOT100**                                                   | 拓扑 or dfs判断是否有环                                      |      |\n|                  | [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/) |                                                              | 拓扑 or dfs                                                  |      |\n\n##   [860 · 不同岛屿的个数](https://www.lintcode.com/problem/860)\n\n### bfs\n\n```c++\nclass Solution {\npublic:\n    /**\n     * @param grid: a list of lists of integers\n     * @return: return an integer, denote the number of distinct islands\n     */\n    int dir[4][2]={{0,-1},{-1,0},{0,1},{1,0}};\n    int ans=0;\n    set<vector<pair<int, int>>> s;\n    void bfs(vector<vector<int>>& matrix,int x,int y, vector<vector<int>>& dp)\n    {\n        int dx=0,dy=0;\n\t\tint m=matrix.size();\n\t\tint n=matrix[0].size();\n        queue<pair<int, int>> que;\n        vector<pair<int, int>> path;\n        que.push({x, y});\n        while(que.size())\n        {\n            auto t = que.front();\n            que.pop();\n            for(int i=0;i<4;i++)\n            {\n                dx=t.first+dir[i][0];\n                dy=t.second+dir[i][1];\n                path.push_back({dx-x,dy-y});\n                if(dx<m&&dx>=0&&dy<n&&dy>=0&&!dp[dx][dy]&&matrix[dx][dy]==1)\n                {\n                    que.push({dx,dy});\n                    dp[dx][dy]=1;\n                }\n            }\n        }\n        s.insert(path);\n    }\n    int numberofDistinctIslands(vector<vector<int>> &matrix) {\n        // write your code here\n        int m=matrix.size();\n\t\tint n=matrix[0].size();\n        vector<vector<int>>dp(m,vector<int>(n,0));\n        for(int i=0;i<m;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                if(!dp[i][j]&&matrix[i][j]==1)\n                {\n                    dp[i][j]=1;\n                    bfs(matrix,i,j,dp);\n                   \n                }\n            }\n        }\n        return s.size();\n    }\n};\n```\n\n### dfs\n\n```c++\nclass Solution {\npublic:\n    /**\n     * @param grid: a list of lists of integers\n     * @return: return an integer, denote the number of distinct islands\n     */\n    int dir[4][2]={{0,-1},{-1,0},{0,1},{1,0}};\n    int ans=0;\n    set<vector<pair<int, int>>> s;\n    void dfs(vector<vector<int>>& matrix,int x,int y, vector<vector<int>>& dp,int sx,int sy,vector<pair<int,int>>& path)\n    {\n        int dx=0,dy=0;\n\t\tint m=matrix.size();\n\t\tint n=matrix[0].size();\n        path.push_back({x-sx,y-sy});\n        for(int i=0;i<4;i++)\n        {\n            dx=x+dir[i][0];\n            dy=y+dir[i][1];\n            if(dx<m&&dx>=0&&dy<n&&dy>=0&&!dp[dx][dy]&&matrix[dx][dy]==1)\n            {\n                dp[dx][dy]=1;\n                dfs(matrix,dx,dy,dp,sx,sy,path);\n            }\n        }\n    }\n    int numberofDistinctIslands(vector<vector<int>> &matrix) {\n        // write your code here\n        int m=matrix.size();\n\t\tint n=matrix[0].size();\n        vector<vector<int>>dp(m,vector<int>(n,0));\n        for(int i=0;i<m;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                if(!dp[i][j]&&matrix[i][j]==1)\n                {\n                    dp[i][j]=1;\n                    vector<pair<int,int>> path;\n                    dfs(matrix,i,j,dp,i,j,path);\n                    s.insert(path);\n                }\n            }\n        }\n        return s.size();\n    }\n};\n```\n\n## (并查集板子)[1254. 统计封闭岛屿的数目](https://leetcode.cn/problems/number-of-closed-islands/)\n\n```c++\n// 并查集模板类\nclass UnionFind {\npublic:\n    UnionFind(int n) {\n        p = vector<int>(n);\n        s = vector<int>(n, 1);\n        iota(p.begin(), p.end(), 0);\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return ;\n        if(s[y]<s[x])\n        {\n            p[y]=x;\n            s[x]+=s[y];\n        }\n        else\n        {\n            p[x]=y;\n            s[y]+=s[x];\n        }\n    }\n\n    int find(int x) {\n        if (p[x] != x) p[x] = find(p[x]);\n        return p[x];\n    }\n\nprivate:\n    vector<int> p, s;\n};\n\nclass Solution {\npublic:\n    int closedIsland(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        UnionFind uf(m * n + 1);\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (i == 0 || i == m - 1 || j == 0 || j == n - 1) {\n                    uf.unite(i * n + j, m * n);\n                }\n                if (matrix[i][j] == 0) {\n                    if(i>0&&matrix[i-1][j]==0) uf.unite(i * n + j, (i - 1) * n + j);\n                    if(j>0&&matrix[i][j-1]==0)uf.unite(i*n+j,i*n+j-1);\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                ans += matrix[i][j] == 0 && uf.find(i * n + j) == i * n + j;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n## 图板子[1971. 寻找图中是否存在路径](https://leetcode.cn/problems/find-if-path-exists-in-graph/)\n\n### 并查集\n\n```c++\n// 并查集模板类\nclass UnionFind {\npublic:\n    UnionFind(int n) {\n        p = vector<int>(n);\n        s = vector<int>(n, 1);\n        iota(p.begin(), p.end(), 0);\n    }\n    bool isSame(int u, int v) {\n        u = find(u);\n        v = find(v);\n        return u == v;\n    }\n    void merge(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return ;\n        if(s[y]<s[x])\n        {\n            p[y]=x;\n            s[x]+=s[y];\n        }\n        else\n        {\n            p[x]=y;\n            s[y]+=s[x];\n        }\n    }\n    //迭代\n\t/*int find(int x) {\n        while (x != p[x]) \n        {\n            int parents = p[x];\n            if (parents) x = p[x] = parents; // 跳 父节点，连 父父节点\n            else x = p[x];\n        }\n        return x;\n    }*/\n    int find(int x) {\n        if (p[x] != x) p[x] = find(p[x]);\n        return p[x];\n    }\n\nprivate:\n    vector<int> p, s;\n};\nclass Solution {\npublic:\n\n    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {\n        \n        UnionFind uf(n + 1);\n        for(auto e:edges)\n        {\n            uf.merge(e[0],e[1]);\n        }\n        if(uf.isSame(source,destination))return true;\n        return false;\n    }\n};\n```\n\n### bfs\n\n```c++\nclass Solution {\npublic:\n    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {\n        vector<bool> vis(n);\n        vector<vector<int>> g(n);\n        for (auto& e : edges) {\n            int a = e[0], b = e[1];\n            g[a].emplace_back(b);\n            g[b].emplace_back(a);\n        }\n        queue<int> que;\n        que.emplace(source);\n        vis[source] = true;\n        while (!que.empty()) \n        {\n            int t = que.front();\n            que.pop();\n            if (t == destination) break;\n            for (int next: g[t]) \n            {\n                if (!vis[next]) \n                {\n                    que.emplace(next);\n                    vis[next] = true;\n                }\n            }\n        }\n        return vis[destination];\n    }\n};\n```\n\n### dfs\n\n```c++\nclass Solution {\npublic:\n    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {\n        vector<bool> vis(n);\n        vector<vector<int>> g(n);\n        for (auto& e : edges) {\n            int a = e[0], b = e[1];\n            g[a].emplace_back(b);\n            g[b].emplace_back(a);\n        }\n        function<bool(int)> dfs = [&](int i) -> bool {\n            if (i == destination) return true;\n            vis[i] = true;\n            for (int& j : g[i]) {\n                if (!vis[j] && dfs(j)) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        return dfs(source);\n    }\n};\n```\n\n","tags":["加密文章tag"],"categories":["Algorithm"]},{"title":"Autobidding","url":"/2024/07/26/Autobidding/","content":"## Autobidding with Constraints\nVCG是在二价上衍生的，所以如果二价不是AIC，那么VCG也不是AIC\n\n价值最大化出价者在真实拍卖中的最优出价策略\n\nTheorem 1. Bidding strategy $b(i)$ gives a solution which has value at least OPT minus value of $2|C|$ impressions and violates each constraint by at most $2|C|$ 1 impressions if and only the auction is truthful.\n最近，有一系列研究聚焦于在线广告中受自动出价（例如目标每次行动成本出价者和目标广告支出回报率出价者）驱动的价值最大化出价者。Aggarwal 等人（2019 年）描述了价值最大化出价者在真实拍卖中的最优出价策略，并表明在最坏情况下，VCG 拍卖的福利可能只有最优社会福利的二分之一。Balseiro 等人（2021b）；Deng 等人（2022 年，2021 年）展示了如何在有价值最大化出价者的拍卖中使用提升和保留价格来提高福利效率。Balseiro 等人（2021a，2022a）描述了在各种信息结构下，有或没有预算约束的价值最大化者的收益最优单阶段拍卖。除此之外，还有其他相关工作研究略有不同的出价模型，例如 Babaioff 等人（2021 年）；Goel 等人（2019 年，2014 年）；Golrezaei 等人（2021 年）研究具有投资回报率约束的效用最大化者，以及 Fadaei 和 Bichler（2016 年）；Wilkens 等人（2017 年，2016 年）研究具有每次拍卖目标约束的价值最大化出价者。\n一些设置参考：\n定义 2.第一价格节奏均衡 （FPPE） 是一个 BFPM 元组 （ $(\\alpha, x)$ ），每个出价者 i 的节奏乘数 $\\alpha_{i}$ ，出价者 i 和好 j 的分数分配 $x_{i j}$，具有以下附加属性：•（无需不必要的pacing）如果对于每个投标人$i\\in N$，有$\\sum_{j\\in M}x_{ij}p_{j}\\lt B_{i}$，那么$\\alpha_{i}=1$。\n### 摘要：\n本文探讨了在线广告领域中自动出价（Autobidding）的重要性，并将其视为广告商优化广告活动的关键工具。作者提出了在一般仿射成本约束下进行性能出价的基本问题，并为多槽诚实拍卖中的一般出价问题设计了最优的单一代理出价策略。主要贡献是展示了出价与拍卖设计之间的紧密联系，即出价公式是最优的当且仅当底层拍卖是诚实的。此外，研究了当所有广告商采用最优自动出价时的系统视图，证明了在一般情况下，所有广告商的出价代理之间存在均衡。主要结果表明，在任何数量的一般仿射约束下，广告商在出价代理均衡中获得的总价值（转化次数）不少于通过不考虑任何拍卖激励或提供任何广告商保证的集中式广告分配方案所能生成的总价值的1/2。\n\n### 要点：\n- 提出了设计最优出价算法的问题，研究了出价与底层拍卖的互动。\n- 证明了在多广告商采用自动出价的情况下，存在一个系统均衡。\n- 证明了“无序的代价”（Price of Anarchy）界限，即在均衡状态下，广告商获得的总价值至少是集中式分配方案的一半。\n\n### 实验方法：\n- 本文通过理论分析和数学建模来探讨自动出价策略。\n- 使用线性规划和对偶性来推导出最优出价公式。\n- 利用乘法权重更新（MWU）方法来计算出价公式并据此出价。\n- 通过扩展液态福利（liquid welfare）的定义，并使用收费论证来证明“无序的代价”结果。\n\n### 不足：\n- 文章主要关注理论分析，并未提供实验验证或实际应用案例。\n- 对于自动出价策略在实际广告系统中的表现和效果缺乏实证研究。\n\n### 展望：\n- 未来的研究可以探索自动出价策略在不同广告平台和不同市场条件下的实际效果。\n\n- 可以进一步研究如何结合机器学习技术来优化自动出价策略，以适应不断变化的市场环境。\n\n- 考虑在更复杂的拍卖设置中，如多物品拍卖或有多种类型的广告位时，自动出价策略的表现和优化问题。\n\n  \n\n$$\n\\max\\sum_{i,s}x_{is}ctr_{is}v_{i}\n$$\n$$\n\\forall c, \\sum_{i,s}x_{is}ctr_{is}cpc_{is}\\leq B_{c}+\\sum_{i,s}x_{is}ctr_{is}v_{ic}\n$$\n$$\n\\forall i,\\sum_sx_{is}\\leq1\n$$\n$$\n\\forall i,s,x_{is}\\in\\{0,1\\}\n$$\n\n## [KDD2021 | USCB:展示广告约束出价问题的通用解决方案 (qq.com)](https://mp.weixin.qq.com/s/OCInQGXKeYXOsThlSOAZ_g)\n\nhttps://mp.weixin.qq.com/s/XxYJYZ4VR5bQBYtJEtpQsw\n\nhttps://mp.weixin.qq.com/s/p4LdXKM3KCIU5cMg77olxg\n\n[证明过程（对偶）](https://mp.weixin.qq.com/s/c3OU5Mdb6-YIk0MOmRsG4w)\n\n## Incentive Compatibility in the Auto-bidding World\n\n\n\n**声明 5.4**：在连续查询模型中，如果每次查询的拍卖是真实的，那么统一出价策略是每个自动出价代理的最优策略。\n\n这些声明是论文中理论分析的重要组成部分，它们为证明主要定理提供了基础。\n\n### 2\n\n**定理 2.1**：对于预算设置（当所有广告商都受预算限制）和tCPA设置（当所有广告商都受tCPA限制），我们有SPA不是AIC的。也就是说，有一些情况下，广告商通过误报其约束可以获得好处。\n\n**Theorem 2.1.** For the budget setting (when all advertisers are budgeted-constrained) and for the tCPA-setting (when all advertisers are tCPA-constrained), we have that SPA is not AIC. That is, there are some instances where an advertiser benefits by misreporting its constraint.\n$$\n\\text{Remark 3.1 (Uniform Bidding). If the per-query action is truthful, then uniform bidding is the}\\\\\\textit{optimal policy for the autobidder. Thus, b}_a(q)=\\mu+v_a(q)\\text{ for some }\\mu>0.\\textit{ We formally prove this in Claim 5.4}\n$$\n\n### 3\n\n**备注 3.1**（统一投标）。如果每个查询拍卖是真实的，那么统一竞价是自动投标者的最优策略。因此，对于某个μ > 0，ba(q) = μ·va(q)。我们在权利要求5.4中正式证明了这一点。\n\n**备注 3.2**（价值函数信息）因此，我们的模型通过实验捕获了自动投标者在他们对市场有足够的了解后的行为。Therefore, our model captures how auto-bidders behave once they have learned enough about the market through experimentation.\n\n**定义 3.3（自动出价激励兼容性，AIC）**：如果对于每一个子博弈完美均衡（SPE），我们有 Va(Ba; Ba) ≥ Va(B′ a; Ba) 和 Va(Ta; Ta) ≥ Va(T′ a; Ta) 对于每一个 Ba, B′ a, Ta, T′ a，那么拍卖规则被称为自动出价激励兼容（AIC）。\n\n**声明 3.1（统一出价）**：如果每次查询的拍卖是真实的（如SPA），那么统一出价是自动出价代理的最优策略。因此，ba(q) = µ · va(q) 对于某个 µ > 0。我们在声明 5.4 中正式证明了这一点。\n\n**声明 3.2（价值函数信息）**：在我们的模型中，自动出价者拥有对其代理的查询价值函数的了解，这意味着每个自动出价者对他们面临的出价格局有很好的了解。在实践中，自动出价者已经在多轮拍卖中进行了互动，在那里他们进行实验和学习。因此，经过足够多轮的实验后，每个自动出价者对他们的出价格局有了很好的了解。因此，我们的模型捕捉了自动出价者在通过实验了解了市场后的行为。这个假设在自动出价文献中相当标准（参见例如，Aggarwal 等人（2019年）；Feng 等人（2023年））。\n\n### 4\n\n**定理 4.1**：假设至少有两个受预算限制的广告商或两个受tCPA限制的广告商；那么FPA不是AIC的。\n\nTheorem 4.1. Suppose there are at least two budget-advertisers or two tCPA-advertisers; then FPA is not AIC.\n\n**定理 4.2**：当FPA被限制只能使用统一出价策略时，FPA是AIC的。\n\nTheorem 4.2. FPA restricted to uniform bidding is AIC.\n\n**引理4.4：**\n\n![](le4.4(1).png)\n\n![](le4.4(2).png)\n\n\n\n**声明 4.3**：在其他自动出价者固定的情况下，存在一个乘数 µa ≥ 0，使得以下出价策略是最优的：\n\n\n\nba(q) =[\\begin{cases} \\mu_a v_a(q) & \\text{if } \\mu_a v_a(q) \\geq \\max_{a' \\neq a} b_{a'}(q) \\ 0 & \\text{otherwise} \\end{cases} ] \n\n这个结果无论广告商是受预算限制还是受tCPA限制都成立。\n\n**推论4.6：**如果FPA和两个预算广告的自动嵌入不是AIC，那么使用相同的查询集和两个tcpa -广告器进行自动嵌入也不是AIC。\n\n只要解 r 相对于预算和目标的比率是单调的，那么拍卖对于给定估值是 AIC。\n\n**定义 4.12（统一出价均衡）**：自动出价代理子博弈的统一出价均衡对应于出价乘数 µ1, ..., µN，使得每个自动出价代理 a 选择的统一出价策略 µa 在所有可行的统一出价策略中最大化问题（12），并且如果广告商 a 的约束不是紧的，则 µa 获得其最大可能值。\n\n**引理 4.13**（Conitzer 等人（2022a）中定理 1 的内涵）。给定一个具有一般约束的Autobiding实例，如(13)所示，存在唯一的统一竞价均衡，所有广告商的竞价乘数在所有可行的统一竞价配置文件中都是最大的。\n\n**Lemma 4.13** (Extension of Theorem 1 in Conitzer et al. (2022a)). Given an instance of Autobidding with general constraints as in (13), there is a unique uniform bidding equilibrium, and the bid multipliers of all advertisers are maximal among all feasible uniform bidding profiles.\n\n**备注 4.14**：康茨等人。(2022a) 显示了 FPA 中预算的单调性属性，收入和福利的投标均衡均匀。相反，在我们的工作中，我们专注于每个广告商的单调性。\n\n**Remark 4.14.** Conitzer et al . (2022a) show monotonicity properties of budgets in FPA with uniform bidding equilibrium for the revenue and welfare. Instead, in our work, we focus on monotonicity for each advertiser.\n\n**定理 5.5**（拍卖等价结果）：假设自动出价代理在SPA中使用统一出价策略，并且类似地，在FPA中使用如声明4.3中定义的简单出价策略。那么，在任何子博弈均衡中，SPA的拍卖结果（分配和定价）与FPA相同。\n\n![](th5.5.png)\n\n**定理 5.6**：假设至少有两个受预算限制的广告商或两个受tCPA限制的广告商；那么，即使在连续查询模型中，SPA也不是AIC的。\n\n**Theorem 5.6.** Suppose that there are at least two budget-advertisers or two tCPA-advertisers; then, even for the continuous-query model, SPA is not AIC.\n\n**定理 5.7**：给定两个广告商，让µ1和µ2是自动出价代理子博弈中的均衡出价乘数。还假设h(q) = v1(q) / v2(q)是递增的。那么：\n\n1. \n\n   如果广告商受预算B1和B2的限制，那么µ1 = B2 * E[z1(z≥r)] / E[z1(z ≤ r)]，并且µ2 = µ1 * r，其中r是以下隐式函数的解： r * E[1[z ≥ r)] / E[z1(z ≤ r)] = B1 / B2。\n\n2. \n\n   如果广告商受目标T1和T2的tCPA限制，我们有µ1 = T1 * E[1(z≤r)] / E[1(z≥r)]，并且µ2 = µ1 * r，其中r是以下隐式函数的解： r * E[1(z ≥ r)] / E[z1(z ≥ r)] * E[1(z ≤ r)] / E[z1(z ≤ r)] = T1 / T2。\n\n3. \n\n   如果进一步，v2在q上是非递减的，并且h是凹函数，并且广告商要么都是受预算限制，要么受tCPA限制，那么SPA是AIC的。\n\n   ![](th5.7.png)\n\n**定理 5.8**：考虑一个满足假设5.1的诚实拍卖（x, p）。如果有至少两个受预算限制的广告商或两个受tCPA限制的广告商，那么这个诚实拍卖不是AIC的。\n\nTheorem 5.8. Consider a truthful auction (x, p) satisfying Assumption 5.1. If there are at least two budget-advertisers or two tCPA-advertisers, then the truthful auction is not AIC.\n\n**定理 5.9**：考虑一个满足假设5.1的诚实拍卖（x, p），并假设有要么两个受预算限制的广告商，要么两个受tCPA限制的广告商。让µ1和µ2是自动出价代理在子博弈均衡中使用的出价乘数。进一步假设h(q) = v1(q) / v2(q)是递增的。那么：\n\n1. \n\n   如果广告商受预算B1和B2的限制，那么µ1 = B1 * E[p1(rz,1)]，并且µ2 = r * µ1，其中r是以下隐式函数的解： E[rp1(z / r, 1)] / E[zp1(r / z, 1)] = B1 / B2。\n\n2. \n\n   如果广告商受目标T1和T2的tCPA限制，我们有µ1 = T1 * E[zg(z / r)] / E[rp1(z / r)]，并且µ2 = µ1 * r，其中r是以下隐式函数的解： E[x1( r / z, 1)] / E[zx1(z / r, 1)] * E[rp1(z / r, 1)] / E[zp1( r / z, 1)] = T1 / T2。\n\n![](th5.9.png)\n\n[Arxiv20, UESTC/Baidu, Bin Li] Incentive mechanism design for ROI-constraint (多物品，ROI private, 用控制方法保证IC，无性能保证)\n## Budget Pacing in Repeated Auctions: Regret and Efficiency without Convergence\n- 假设每个代理使用梯度下降算法（也可以认为是一种PID算法）来控制budget花费的\n速度，考虑value maximizer，结论对一类core auction（包括一、二价）均成立\n- 证明对参竞个体来说使用此算法的收益regret上界（benchmark是相较于最好的控制\n预算花费速度的pacing multiplier）\n- 当每个代理都使用此算法时，近似达到1/2的最优社会福利，不要求策略收敛到均衡\n- 对于二价拍卖，当每个代理的regret都比较小时（不使用文章中的算法），并不一定\n说明整体的福利是高的，可能会arbitrarily bad\n- Regret上界证明由SGD证明改编，1/2的bound与前一类不考虑动态的工作中的1/2\n的证明思路有相似之处\n### 研究背景\n- **在线广告市场的发展**：在线广告在市场中占比重大，广告通过拍卖分配，广告商面临复杂决策，需分配预算并制定出价策略。\n- **预算管理服务的重要性**：平台提供自动化预算管理服务，通过预算调整帮助广告商控制支出，调整参数以匹配目标预算，降低进入门槛，平台更易管理预算。\n### 研究问题\n在几乎所有广告商支出由自动出价代理控制且同时学习调整出价的情况下，整体市场结果如何，以及这在多大程度上取决于底层拍卖的细节。\n### 主要贡献\n- **提出算法及证明**：提出基于梯度的预算调整算法（Algorithm 1），证明当所有代理使用该算法时，预期液体福利至少是最优预期液体福利的一半，且不依赖于算法收敛到均衡。\n- **个体遗憾保证**：分析算法在满足单调性价比（MBB）条件的拍卖中的个体性能，证明代理总价值相对于完美调整序列具有一定的遗憾界，在随机环境中，相对于最佳固定调整乘数具有$O(T^{3/4})$的遗憾界。\n### 模型与预备知识\n1. **分配问题**：重复拍卖，卖家有单单位商品出售，多个代理参与，每个代理每轮有价值，价值独立同分布且可能相关，可行分配集向下封闭。\n2. **拍卖与预算**：每轮使用拍卖机制，代理观察价值后出价，拍卖有分配和支付规则，代理有固定预算，目标支出率定义为预算与时间的比值，代理使用动态出价策略。\n3. **核心拍卖**：结果适用于核心拍卖，包括第一价格、第二价格和广义第二价格拍卖等，核心拍卖需满足个体理性和特定的福利最大化条件。\n4. **单调性价比**：拍卖机制满足单调性价比，即增加出价导致分配增加时，单位新分配的支付增加至少等于所需的最小出价。\n5. **代理目标**：定义价值最大化和效用最大化两种代理目标，本文主要关注价值最大化，即最大化总价值并受预算和出价约束。\n6. **液体福利**：衡量福利的指标，考虑非准线性代理效用，定义为代理对分配的最大支付意愿，目标是最大化平台的预期液体福利。\n### 算法与定义\n1. **预算调整算法**：基于随机梯度下降，代理维护调整乘数，根据乘数和价值确定出价，每轮根据支出更新乘数，算法不会过早耗尽预算且出价不超过价值。\n2. **广义调整算法**：满足不超价出价、乘数为0时出价为价值等条件的可测出价算法。\n3. **完美调整序列**：每轮预期支出等于目标支出率的调整乘数序列，用于衡量个体遗憾。\n### 实验设计\n1. **数据来源**：使用2022年4月7天内从Bing广告平台收集的活动和拍卖数据，包含预算、出价、点击概率等信息。\n2. **模拟过程**：对参与拍卖次数少于1000次的活动保留原始出价，其他活动模拟算法执行生成新出价，计算目标支出率和步长，使用估计的点击率和简化拍卖规则模拟拍卖结果，计算总遗憾。\n### 研究结果\n1. **理论结果**：算法在不依赖收敛的情况下实现了较好的整体市场效率和个体性能保证，液体福利至少是最优的一半，个体遗憾界在不同环境下有不同表现。\n2. **实验结果**：模拟实验表明，算法在多玩家同时学习环境中，遗憾率小于$T^{3/5}$，后悔值随拍卖次数增加近似线性增长，估计第二价格拍卖的后悔率为$O(T^{0.58})$，第一价格拍卖为$O(T^{0.55})$。\n### 未来研究方向\n1. 探索能否将结果扩展到其他算法，满足个体和整体保证，如改进个体遗憾界同时保持液体福利保证。\n2. 研究所有代理是否能同时实现零遗憾，以及在非真实拍卖中改进遗憾界，特别是在随机和对抗环境中的表现。\n## Budget Pacing in Repeated Auctions: Regret and Efficiency without Convergence\n- 假设每个代理使用梯度下降算法（也可以认为是一种PID算法）来控制budget花费的\n速度，考虑value maximizer，结论对一类core auction（包括一、二价）均成立\n![alt text](image.png)\n- 证明对参竞个体来说使用此算法的收益regret上界（benchmark是相较于最好的控制\n预算花费速度的pacing multiplier）\n- 当每个代理都使用此算法时，近似达到1/2的最优社会福利，不要求策略收敛到均衡\n- 对于二价拍卖，当每个代理的regret都比较小时（不使用文章中的算法），并不一定\n说明整体的福利是高的，可能会arbitrarily bad\n- Regret上界证明由SGD证明改编，1/2的bound与前一类不考虑动态的工作中的1/2\n的证明思路有相似之处\n### 研究背景\n- **在线广告市场的发展**：在线广告在市场中占比重大，广告通过拍卖分配，广告商面临复杂决策，需分配预算并制定出价策略。\n- **预算管理服务的重要性**：平台提供自动化预算管理服务，通过预算调整帮助广告商控制支出，调整参数以匹配目标预算，降低进入门槛，平台更易管理预算。\n### 研究问题\n在几乎所有广告商支出由自动出价代理控制且同时学习调整出价的情况下，整体市场结果如何，以及这在多大程度上取决于底层拍卖的细节。\n### 主要贡献\n- **提出算法及证明**：提出基于梯度的预算调整算法（Algorithm 1），证明当所有代理使用该算法时，预期液体福利至少是最优预期液体福利的一半，且不依赖于算法收敛到均衡。\n- **个体遗憾保证**：分析算法在满足单调性价比（MBB）条件的拍卖中的个体性能，证明代理总价值相对于完美调整序列具有一定的遗憾界，在随机环境中，相对于最佳固定调整乘数具有$O(T^{3/4})$的遗憾界。\n### 模型与预备知识\n1. **分配问题**：重复拍卖，卖家有单单位商品出售，多个代理参与，每个代理每轮有价值，价值独立同分布且可能相关，可行分配集向下封闭。\n2. **拍卖与预算**：每轮使用拍卖机制，代理观察价值后出价，拍卖有分配和支付规则，代理有固定预算，目标支出率定义为预算与时间的比值，代理使用动态出价策略。\n3. **核心拍卖**：结果适用于核心拍卖，包括第一价格、第二价格和广义第二价格拍卖等，核心拍卖需满足个体理性和特定的福利最大化条件。\n4. **单调性价比**：拍卖机制满足单调性价比，即增加出价导致分配增加时，单位新分配的支付增加至少等于所需的最小出价。\n5. **代理目标**：定义价值最大化和效用最大化两种代理目标，本文主要关注价值最大化，即最大化总价值并受预算和出价约束。\n6. **液体福利**：衡量福利的指标，考虑非准线性代理效用，定义为代理对分配的最大支付意愿，目标是最大化平台的预期液体福利。\n### 算法与定义\n1. **预算调整算法**：基于随机梯度下降，代理维护调整乘数，根据乘数和价值确定出价，每轮根据支出更新乘数，算法不会过早耗尽预算且出价不超过价值。\n2. **广义调整算法**：满足不超价出价、乘数为0时出价为价值等条件的可测出价算法。\n3. **完美调整序列**：每轮预期支出等于目标支出率的调整乘数序列，用于衡量个体遗憾。\n### 实验设计\n1. **数据来源**：使用2022年4月7天内从Bing广告平台收集的活动和拍卖数据，包含预算、出价、点击概率等信息。\n2. **模拟过程**：对参与拍卖次数少于1000次的活动保留原始出价，其他活动模拟算法执行生成新出价，计算目标支出率和步长，使用估计的点击率和简化拍卖规则模拟拍卖结果，计算总遗憾。\n### 研究结果\n1. **理论结果**：算法在不依赖收敛的情况下实现了较好的整体市场效率和个体性能保证，液体福利至少是最优的一半，个体遗憾界在不同环境下有不同表现。\n2. **实验结果**：模拟实验表明，算法在多玩家同时学习环境中，遗憾率小于$T^{3/5}$，后悔值随拍卖次数增加近似线性增长，估计第二价格拍卖的后悔率为$O(T^{0.58})$，第一价格拍卖为$O(T^{0.55})$。\n### 未来研究方向\n1. 探索能否将结果扩展到其他算法，满足个体和整体保证，如改进个体遗憾界同时保持液体福利保证。\n2. 研究所有代理是否能同时实现零遗憾，以及在非真实拍卖中改进遗憾界，特别是在随机和对抗环境中的表现。\n\n\n## Autobidders with Budget and ROI Constraints: Efficiency, Regret, and Pacing Dynamics\n![alt text](image-1.png)\n![alt text](image-2.png)\n- budget-pacing multiplier $\\mu_{t}^{B^{*}}$ is any $\\mu \\in[0, \\frac{\\bar{v}}{\\rho}-1]$ with $Z_{t}^{B}(\\mu)=\\rho,$ or o if no such μ exists. \n- ROI-pacing multiplier $\\mu_{t}^{R^{*}}$ is any $\\mu \\in[0, \\gamma-1]$ wih $Z_{t}^{R}(\\mu)=\\rho_{t}(\\mu)$ or o if no such μ exists. \n- pacing multiplier $$\\mu_{t}^{*}:=max \\{\\mu_{t}^{B^{*}}, \\mu_{t}^{R^{*}} \\} ≥0$$\nThus, our notion of regret is defined as follows: $Reg(T) \\triangleq \\sum_{t \\in[T]} V_{t}(\\mu_{t}^{*})-\\sum_{t \\in[T]} V_{t}(\\mu_{t})$\n\n\n1. **遗憾值基准定义（Defn 14）**\n   - 首先定义了价值优化乘数（value - optimizing multipliers），包括预算pacing乘数\\(\\mu_{t}^{B*}\\)和ROI pacing乘数\\(\\mu_{t}^{R*}\\)。这些乘数是基于每轮的情况来定义的，用于确定出价策略。\n   - 遗憾值\\(Reg(T)\\)被定义为\\(Reg(T)\\triangleq\\sum_{t\\in[T]}V_{t}(\\mu_{t}^{*}) - \\sum_{t\\in[T]}V_{t}(\\mu_{t})\\)，其中\\(V_{t}(\\mu_{t})\\)表示在第\\(t\\)轮使用乘数\\(\\mu_{t}\\)时的价值函数，\\([T]\\)表示从1到\\(T\\)的轮次集合。这个定义是为了在复杂的对抗环境下，避开标准基准导致的“花或省困境”（spend - or - save dilemma），从而能够合理地衡量算法与最优策略之间的差距。\n\n4. **遗憾值界定的证明思路（Theorem 16）**\n   - 证明算法2的遗憾值是有界的。证明过程主要是将算法2的更新规则解释为对辅助函数\\(H_{t}^{R}\\)和\\(H_{t}^{B}\\)应用随机梯度下降（SGD）。\n   - 然而，这个过程面临一些挑战。例如，在多约束情况下，更新规则比较复杂，并且辅助函数具有一些特殊性质，如ROI辅助函数\\(H_{t}^{R}\\)不是凸函数等。通过巧妙地处理这些问题，比如处理只有较大乘数有反馈的情况，最终得出遗憾值\\(Reg(T)\\)的上界为\\(Reg(T)\\leq O\\left(\\sqrt{T}\\left(\\log T+\\sum_{t = 1}^{T} \\sigma_{t}^{R}+\\sum_{t = 1}^{T} \\sigma_{t}^{B}\\right)\\right)\\)，其中\\(\\sigma_{t}^{R}\\)和\\(\\sigma_{t}^{B}\\)是与ROI和预算约束相关的随机变量的标准差。这表明算法2能够在双约束环境下有效地控制个体遗憾值，使其不会无限制地增长。\n5. **平稳随机环境下的推论（Corollary 19）**\n   - 在平稳随机环境下（即拍卖的价值、成本等相关参数是平稳分布的情况），进一步分析算法的性能。\n   - 得出推论\\(\\lim_{T\\rightarrow\\infty}\\frac{Reg(T)}{T}=0\\)，这意味着在这种较为理想的环境中，算法2相对于最佳固定出价的遗憾值是渐进式的。即随着轮次\\(T\\)的增加，个体遗憾值与轮次\\(T\\)的比值趋近于零，表明算法能够更好地收敛，在长期运行中能够有效地优化出价策略，使其性能接近最优固定出价策略。","tags":["paper","Autobidding"],"categories":["research"]},{"title":"template","url":"/2024/06/25/template/","content":"[TOC]\n\n[zguolee/WDAlgorithmsNote: 王道考研机试指南(第二版)——题目链接 (github.com)](https://github.com/zguolee/WDAlgorithmsNote)\n\n## 快速排序 785\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=1000086;\nint a[INF],n,m,res=0; \n//2\n//1 2\nvoid qsort(int a[],int l,int r)\n{\n\tif(l>=r)return;\n\tint i=l-1,j=r+1,x=a[(l+r)>>1];\n\twhile(i<j)\n\t{\n\t\tdo i++;while(x>a[i]);\n\t\tdo j--;while(x<a[j]);\n\t\tif(i<j)swap(a[i],a[j]);\n\t}\n\t//cout<<i<<\" \"<<j<<endl;\n\tqsort(a,l,j);//不能写i \n\tqsort(a,j+1,r);\n}\nvoid qsort2(int a[],int l,int r)\n{\n\tif(l>=r)return;\n\tint i=l,j=r,x=a[(l+r)>>1];\n\twhile(1)\n\t{\n\t\twhile(x>a[i]) i++;\n\t\twhile(x<a[j]) j--;\n\t\tif(i<j)\n\t\t{\n\t\t\tswap(a[i],a[j]);\n\t\t\ti++;j--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout<<i<<\" \"<<j<<endl;\n\tqsort(a,l,j);//不能写i \n\tqsort(a,j+1,r);\n}\n    void qsort(vector<int>& nums,int low, int high)\n    {\n        if(low>=high)return;\n        int randin=low+rand()%(high-low+1);\n        swap(nums[randin],nums[low]);\n        int pivot=nums[low];\n        int l=low,r=high;\n        while(l<r)\n        {\n            while(l<r&&nums[r]>pivot)r--;\n            if(l<r)nums[l++] = nums[r];     \n            while(l<r&&nums[l]<pivot)l++;\n            if(l<r)nums[r--] = nums[l]; \n\t\t\t5 4\n\t\t\t2 4 1 5 3    \n        }\n        nums[l]=pivot;\n        qsort(nums,low,l-1);\n        qsort(nums,l+1,high);\n    }\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<n;i++)cin>>a[i];\n\tqsort(a,0,n-1);\n\tfor(int i=0;i<n;i++)cout<<a[i]<<\" \";\n\treturn 0;\t\n}\n```\n\n### 786.第k个数\n\n类似题：\n\n#### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)\n\n#### [剑指 Offer II 076. 数组中的第 k 大的数字](https://leetcode.cn/problems/xx4gT2/)\n\n```c++\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define debug(a) cout<<#a<<\"=\"<<a<<endl\nusing namespace std;\nconst int N=100010;\nint ncnt,n,k;\nint a[N],flag=0;\nint part(int a[],int low,int high)\n{\n\tint randin=low+rand()%(high-low+1);\n\tswap(a[randin],a[low]);\n\tint pivot=a[low];\n\tint l=low,r=high;\n\twhile(l<r)\n\t{\n\t\twhile(l<r&&a[r]>pivot)r--;\n\t\tif(l<r)\n\t\t{\n\t\t\ta[l]=a[r];\n\t\t\tl++;\n\t\t}\n\t\twhile(l<r&&a[l]<pivot)l++;\n\t\tif(l<r)\n\t\t{\n\t\t\ta[r]=a[l];\n\t\t\tr--;\n\t\t} \n\t}\n\ta[l]=pivot;\n//\tfor(int i=0;i<n;i++)\n//\t\t{\n//\t\t\tcout<<\" \"<<a[i]<<endl;\n//\t\t}\n//\tdebug(l);\n\treturn l;\n}\nint main()\n{\n\tcin>>n>>k;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tint low=0,high=n-1;\n\tk--;\n\twhile(low<high)\n\t{\n\t\tint pivot=part(a,low,high);\n//\t\tdebug(pivot);\n\t\tif(pivot==k)\n\t\t{\n\t\t\tcout<<a[pivot]<<endl;\n\t\t\tflag=1;\n\t\t\tbreak;\n\t\t}\n\t\telse if(pivot<k)\n\t\t{\n\t\t\tlow=pivot+1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\thigh=pivot-1;\n\t\t}\n//\t\tdebug(high);\n//\t\tfor(int i=0;i<n;i++)\n//\t\t{\n//\t\t\tcout<<\" \"<<a[i]<<endl;\n//\t\t}\n\t\t\n\t}\n\tif(!flag)cout<<a[low]<<endl;\n\treturn 0;\n}\n```\n\n法二：堆排序\n\n```c++\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#define debug(a) cout<<#a<<\"=\"<<a<<endl\nusing namespace std;\nconst int N=100010;\nint ncnt,n,k;\nint a[N],flag=0;\nint getk(int a[])\n{\n\tpriority_queue<int>q;\n\tfor(int i=0;i<k;i++)\n\t{\n\t\tq.push(a[i]);\n\t}\n\tfor(int i=k;i<n;i++)\n\t{\n\t\tint t=q.top();\n\t\tif(a[i]<q.top())\n\t\t{\n\t\t\tq.pop();\n\t\t\tq.push(a[i]);\n\t\t}\n\t}\n\treturn q.top();\n}\nint main()\n{\n\tcin>>n>>k;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tcout<<getk(a)<<endl;\n\treturn 0;\n}\n```\n\n\n\n## 归并排序  787\n\n```c++\nvoid msort(int a[],int l,int r)\n{\n\tif(l>=r)return;\n\tint mid=(l+r)>>1;\n\tmsort(a,l,mid);msort(a,mid+1,r);\n\tint i=l,j=mid+1,k=0;\n\twhile(i<=mid&&j<=r)\n\t{\n\t\tif(a[i]<=a[j])tmp[k++]=a[i++];\n\t\telse tmp[k++]=a[j++];\n\t}\n\twhile(i<=mid)tmp[k++]=a[i++];\n\twhile(j<=r)tmp[k++]=a[j++];\n\tfor(int i=l,j=0;i<=r;i++,j++)a[i]=tmp[j];\n}\n```\n\n### 788. 逆序对的数量\n\n```c++\nvoid msort(int a[],int l,int r)\n{\n\tif(l>=r)return;\n\tint mid=(l+r)>>1;\n\tmsort(a,l,mid);msort(a,mid+1,r);\n\tint i=l,j=mid+1,k=0;\n\twhile(i<=mid&&j<=r)\n\t{\n\t\tif(a[i]<=a[j])tmp[k++]=a[i++];\n\t\telse \n\t\t{\n\t\t\ttmp[k++]=a[j++];\n\t\t\tres+=(mid-i+1);//456 123,i=0,mid=2\n\t\t}\n\t}\n\twhile(i<=mid)tmp[k++]=a[i++];\n\twhile(j<=r)tmp[k++]=a[j++];\n\tfor(int i=l,j=0;i<=r;i++,j++)a[i]=tmp[j];\n}\n//return res\n```\n\n## 整数二分\n\n#### left <= right\n\n```c++\n\t*   int right = nums.length - 1;\n     * 循环条件\n     *   left <= right\n     * 右边取值\n     *   right = mid - 1\n     * 左边取值\n     *   left = mid + 1\n     * 查询条件\n     *   >= target值, 则 nums[mid] >= target时, 都减right = mid - 1\n     *   >  target值, 则 nums[mid] >  target时, 都减right = mid - 1\n     *   <= target值, 则 nums[mid] <= target时, 都加left = mid + 1\n     *   <  target值, 则 nums[mid] <  target时, 都加left = mid + 1\n     * 结果\n     *   求大于(含等于), 返回left\n     *   求小于(含等于), 返回right\n     * 示例(求> 或 >=)\n     *     private int search(int[] nums, int target) {\n     *         int left = 0;\n     *         int right = nums.length - 1;\n     *         while (left <= right){\n     *             int mid = (right - left) / 2 + left;\n     *             if (nums[mid] 查询条件 target){\n     *                 right = mid - 1;\n     *             } else {\n     *                 left = mid + 1;\n     *             }\n     *         }\n     *         return left(根据查询条件确认);\n     *     }\n     * 核心思想: 要找某个值, 则查找时遇到该值时, 当前指针(例如right指针)要错过它, 让另外一个指针(left指针)跨过他(体现在left <= right中的=号), 则找到了\n     */\n```\n\n示例代码：\n\n```c++\n\n    /**\n     * 找数组中第一个 >= 目标值的索引\n     * 没找到则返回数组长度值\n     * 思路:\n     *   大于等于都满足, 则不能取right值, 只能取与left相关的\n     *   由于可以最大值都没有 >= 目标值, 故left要在遍历过程中达到 left > right\n     *   故循环结束条件 left <= right\n     *   left要大于right, 则nums[mid] >= target时 right = mid - 1, 是right降到小于目标值的位置, 然后left跨过去\n     *   left 固定必须为 mid + 1\n     * 没找到则返回数组长度值\n     */\n    public static int searchGeTarget(int[] nums, int target){\n        int left = 0;\n        int right = nums.length - 1;\n        while (left <= right){\n            int mid = (right - left) / 2 + left;\n            if (nums[mid] >= target){\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n\n    /**\n     * 找数组中第一个 > 目标值的索引\n     * 没找到则返回数组长度值\n     */\n    public static int searchGtTarget(int[] nums, int target){\n        int left = 0;\n        int right = nums.length - 1;\n        while (left <= right){\n            int mid = (right - left) / 2 + left;\n            if (nums[mid] > target){\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n\n    /**\n     * 找数组第一个 <= 目标值的索引(4,4,4,4)的右边界\n     * 没有则返回-1\n     */\n    public static int searchLeTarget(int[] nums, int target){\n        int left = 0;\n        int right = nums.length - 1;\n        while (left <= right){\n            int mid = (right - left) / 2 + left;\n            if (nums[mid] > target){\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return right;\n    }\n\n    /**\n     * 找数组第一个 < 目标值的索引(4,4,4,4,5)的右边界5\n     * 没有则返回-1\n     */\n    public static int searchLtTarget(int[] nums, int target){\n        int left = 0;\n        int right = nums.length - 1;\n        while (left <= right){\n            int mid = (right - left) / 2 + left;\n            if (nums[mid] >= target){\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return right;\n    }\n\n```\n\n#### left < right\n\n不同点：\n\n1. 循环条件 left<right\n\n2. return left，因为是以left逐渐逼近答案\n\n3. right=mid\n\n```c++\nbool check(int x) {/* ... */} // 检查x是否满足某种性质\n\n// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：\nint bsearch_1(int l, int r)\n{\n    while (l < r)\n    {\n         int mid = l+((r-l )>> 1);\n        if (check(mid)) r = mid;    // check()判断mid是否满足性质\n        else l = mid + 1;\n    }\n    return l;\n}\n// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：\nint bsearch_2(int l, int r)\n{\n    while (l < r)\n    {\n        int mid = l + r + 1 >> 1;\n        if (check(mid)) l = mid;\n        else r = mid - 1;\n    }\n    return l;\n}\n```\n\n### 789. 数的范围\n\n对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。\n\n> [二分](https://blog.csdn.net/WJPnb1/article/details/126360962?spm=1001.2014.3001.5502)\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=100086;\nint a[INF],n,x,t,w,m,res=0,maxx; \nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\twhile(m--)\n\t{\n\t\tcin>>x;\n\t\tint l=0,r=n-1;\n\t\twhile(l<r)//left\n\t\t{\n\t\t\tint mid=l+r>>1;\n\t\t\tif(a[mid]>=x)\n\t\t\t{\n\t\t\t\tr=mid;\n\t\t\t}\n\t\t\telse l=mid+1;\n\t\t\t//cout<<a[mid]<<\" \"<<mid<<endl;\n\t\t}\n\t\tif(a[l]!=x)\n\t\t{\n\t\t\tcout<<\"-1 -1\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout<<l<<\" \";\n\t\tl=0,r=n-1;\n\t\twhile(l<r)//right\n\t\t{\n\t\t\tint mid=l+r+1>>1;\n\t\t\tif(a[mid]<=x)\n\t\t\t{\n\t\t\t\tl=mid;\n\t\t\t}\n\t\t\telse r=mid-1;\n\t\t\t//cout<<a[mid]<<\" \"<<mid<<endl;\n\t\t}\n\t\tcout<<l<<endl;\n\t}\n\treturn 0;\t\n}\n```\n\n> [题解参考]: https://www.acwing.com/solution/content/3338/\n\n#### 法二\n\n```c++\n#include <bits/stdc++.h>\n#define debug(a) cout<<#a<<\"=\"<<a<<endl\nusing namespace std;\nconst int INF=100086;\nint a[INF],n,x,t,w,m,res=0,maxx; \n\nint check1(int mid,int target)\n{\n\tif(a[mid]<target)\n\t{\n\t\treturn 1;\n\t}\n\treturn 0;\n} \nint check2(int mid,int target)\n{\n\tif(a[mid]<=target)\n\t{\n\t\treturn 1;\n\t}\n\treturn 0;\n} \nint bsearch1(int l, int r,int target)\n{\n    while (l + 1 < r)\n    {\n    \t\n        int mid = l+ (( r - l )>> 1);\n//\t\tdebug(mid);\n//\t\tdebug(l);\n//\t\tdebug(r);\n        if (check1(mid,target)) l = mid;    // check()判断mid是否满足性质\n        else r = mid ;\n    }\n    if(a[r]==target)\n    \treturn r;\n    else \n    {\n    \treturn -1;\n\t}\n}\nint bsearch2(int l, int r,int target)\n{\n    while (l + 1 < r)\n    {\n        int mid = l+ (( r - l )>> 1);\n        if (check2(mid,target)) l = mid;    // check()判断mid是否满足性质\n        else r = mid ;\n    }\n    if(a[l]==target)\n    \treturn l;\n    else \n    {\n    \treturn -1;\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\twhile(m--)\n\t{\n\t\tcin>>x;\n\t\tint l=-1,r=n;\n\t\tint ans1=bsearch1(-1,n,x);\n\t\tif(ans1==-1)\n\t\t{\n\t\t\tcout<<\"-1 -1\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout<<ans1<<\" \";\n\t\tl=-1,r=n;\n\t\tint ans2=bsearch2(-1,n,x);\n\t\tcout<<ans2<<endl;\n\t}\n\treturn 0;\t\n}\n```\n\n\n\n### 790. 数的三次方根\n\n```c++\ndouble n=0.0;\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n\tcin>>n;\n\tdouble l=-10000, r=10000;\n\twhile(r-l>1e-9)\n\t{\n\t\tdouble mid=(l+r)/2;\n\t\tif(mid*mid*mid>=n)r=mid;\n\t\telse l=mid;\n\t}\n\tprintf(\"%.6lf\\n\",l);\n    //cout<<fixed<<setprecision(6)<<l;\n\treturn 0;\t\n}\n```\n\n## 前缀和与差分\n\n### 795. 前缀和（一维）\n\n```c++\nint main()\n{\n    int n,m,x;\n    cin>>n>>m;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>x;\n        sum[i]=x+sum[i-1];\n    }\n    while(m--)\n    {\n        int l,r;\n        cin>>l>>r;\n        cout<<sum[r]-sum[l-1]<<endl;\n    }\n    return 0;\n}\n```\n\n### [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)\n\n### 796.子矩阵的和（二维）\n\n```c++\nint main() \n{\n\tcin>>r>>c>>q;\n\tfor(int i=1;i<=r;i++)\n\t{\n\t\tfor(int j=1;j<=c;j++)\n\t\t{\n\t\t\tcin>>ma[i][j];\n\t\t\ts[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+ma[i][j];\n\t\t}\n\t}\n\twhile(q--)\n\t{\n\t\tint x1=0,y1=0,x2=0,y2=0;\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\tcout<<s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1]<<endl;\n\t}\n    return 0;\n}   \n\n```\n\n### 797. 差分（一维）\n\n表示将序列中[l,r]之间的每个数加上 c。\n\n```c++\nvoid insert(int l,int r,int c)\n{\n\tb[l]+=c;\n\tb[r+1]-=c;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)cin>>a[i];\n\tfor(int i=1;i<=n;i++)insert(i,i,a[i]);\n\twhile(m--)\n\t{\n\t\tint l=0,r=0,c=0;\n\t\tcin>>l>>r>>c;\n\t\tinsert(l,r,c);\n\t}\n\tfor(int i=1;i<=n;i++)b[i]+=b[i-1];\n\tfor(int i=1;i<=n;i++)cout<<b[i]<<\" \";\n\treturn 0;\t\n}\n```\n\n### 798.差分矩阵（二维）\n\n```c++\nvoid insert(int i1,int j1,int i2,int j2,int c)\n{\n\tb[i1][j1]+=c;\n\tb[i2+1][j1]-=c;\n\tb[i1][j2+1]-=c;\n\tb[i2+1][j2+1]+=c;\n\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n\tcin>>n>>m>>q;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tcin>>a[i][j];\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tinsert(i,j,i,j,a[i][j]);\t\n\t\t}\n\t}\n\t\t\n\twhile(q--)\n\t{\n\t\tint l1=0,r1=0,l2,r2,c=0;\n\t\tcin>>l1>>r1>>l2>>r2>>c;\n\t\tinsert(l1,r1,l2,r2,c);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tb[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tcout<<b[i][j]<<\" \";\t\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\t\n}\n```\n\n## 位运算\n\n```\n求n的第k位数字: n >> k & 1\n返回n的最后一位1：lowbit(n) = n & -n\n```\n\n### 801. 二进制中1的个数\n\n```c++\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tres=0;\n\t\tcin>>a[i];\n\t\twhile(a[i])a[i]-=lowbit(a[i]),res++;\n\t\tcout<<res<<\" \";\n\t}\n\t\n\treturn 0;\t\n}\n使用lowbit操作，进行，每次lowbit操作截取一个数字最后一个1后面的所有位，每次减去lowbit得到的数字，直到数字减到0，就得到了最终1的个数，\n```\n\n## 区间和 802\n\n我们首先进行 n 次操作，每次操作将某一位置 x上的数加 c。\n\n接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r] 之间的所有数的和。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=1000086;\nint a[INF],s[INF],n,m,res;\nvector<pair<int, int > >add,query;\nvector<int > all;\nint find(int x)\n{\n\tint l=0,r=all.size()-1;\n\twhile(l<r)\n\t{\n\t\tint mid=l+r>>1;\n\t\tif(all[mid]>=x)r=mid;\n\t\telse l=mid+1;\n\t}\n\treturn r+1;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint x=0,c=0;\n\t\tcin>>x>>c;\n\t\tadd.push_back({x,c});\n\t\tall.push_back(x);\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint l=0,r=0;\n\t\tcin>>l>>r;\n\t\tquery.push_back({l,r});\n\t\tall.push_back(l);\n\t\tall.push_back(r);\n\t}\n\tsort(all.begin(),all.end());\n\tall.erase(unique(all.begin(),all.end()),all.end());\n\tfor(int i=0;i<add.size();i++)\n\t{\n\t\tint x=find(add[i].first);\n\t\ta[x]+=add[i].second;\n\t}\n\tfor(int i=1;i<=all.size();i++)s[i]=a[i]+s[i-1];\n\tfor(int i=0;i<query.size();i++)\n\t{\n\t\tint l=find(query[i].first),r=find(query[i].second);\n\t\tcout<<s[r]-s[l-1]<<endl;\n\t\t\n\t}\n\treturn 0;\t\n}\n```\n\n[参考题解]: https://www.acwing.com/solution/content/13511/\n\n<img src=\"D:\\wyh\\大学\\信息\\acwing\\AcWing 802. 画个图辅助理解_ - AcWing_files\\38626_05e3618e9b-8021.png\" style=\"zoom:50%;\" />\n\n## 区间和并 803\n\n给定 n 个区间 [l,r]，要求合并所有有交集的区间。\n\n注意如果在端点处相交，也算有交集。\n\n输出合并完成后的区间个数。\n\n```c++\nvector< pair< int, int > >segs;\n\nvoid merge(vector<pair<int, int > >&segs)\n{\n\tvector<pair<int, int > >res;\n\tsort(segs.begin(),segs.end());\n\tint st=-2e9,ed=-2e9;//处理第一个数\n\tfor(auto seg:segs)\n\t{\n\t\tif(ed<seg.first)\n\t\t{\n\t\t\tif(st!=-2e9)res.push_back({st,ed});\n\t\t\tst=seg.first,ed=seg.second;\n\t\t}\n\t\telse ed=max(ed,seg.second);\n\t} \n\tif(st!=-2e9)res.push_back({st,ed});\n\tsegs=res;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint l=0,r=0;\n\t\tcin>>l>>r;\n\t\tsegs.push_back({l,r});\n\t}\n\tmerge(segs);\n\tcout<<segs.size()<<endl;\n\treturn 0;\t\n}\n```\n\n## 单链表 826\n\n```c++\nint head, e[N],ne[N],idx,m;\nvoid init()\n{\n\thead=-1;\n\tidx=0;\n} \nvoid insert(int a)\n{\n\te[idx]=a;\n\tne[idx]=head;\n\thead=idx++;\n}\n//k后插入 \nvoid insertk(int k,int x)\n{\n\te[idx]=x;\n\tne[idx]=ne[k];\n\tne[k]=idx++;\n}\nvoid remove(int k)\n{\n\tne[k]=ne[ne[k]];\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n\tcin>>m;\n\tinit();\n\twhile(m--)\n\t{\n\t\tchar s;\n\t\tcin>>s;\n\t\tif(s=='H')\n\t\t{\n\t\t\tint x=0;\n\t\t\tcin>>x;\n\t\t\tinsert(x);\n\t\t}\n\t\telse if(s=='D')\n\t\t{\n\t\t\tint k=0;\n\t\t\tcin>>k;\n\t\t\tif(!k)head=ne[head];\n\t\t\tremove(k-1);\n\t\t}\n\t\telse if(s=='I')\n\t\t{\n\t\t\tint x=0,k=0;\n\t\t\tcin>>k>>x;\n\t\t\tinsertk(k-1,x);\n\t\t}\n\t}\n\tfor(int i=head;i!=-1;i=ne[i])\n\t{\n\t\tcout<<e[i]<<' ';\n\t}\n\tcout<<endl;\n\treturn 0;\t\n}\n```\n\n## 双链表 827\n\n```c++\nint e[N],l[N],r[N],idx,m;\nvoid init()\n{\n\t//0左端点，1右端点 \n\tr[0]=1,l[1]=0;\n\tidx=2;\n} \n//k后插入 \nvoid insert(int k,int x)\n{\n\te[idx] = x;\n    l[idx] = k;\n    r[idx] = r[k]; //todo 这边的 k 不加 1 ， 输入的时候 k+1 就好\n    l[r[k]] = idx;\n    r[k] = idx;\n    idx++;\n}\nvoid remove(int k)\n{\n\tr[l[k]] = r[k];\n    l[r[k]] = l[k];\n\t\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n\tcin>>m;\n\tinit();\n\twhile(m--)\n\t{\n\t\tint k=0,x=0;\n\t\tstring s;\n\t\tcin>>s;\n\t\tif(s==\"R\")\n\t\t{\n\t\t\t\n\t\t\tcin>>x;\n\t\t\tinsert(l[1],x);\n\t\t}\n\t\telse if(s==\"L\")\n\t\t{\n\t\t\t\n\t\t\tcin>>x;\n\t\t\tinsert(0,x);\n\t\t}\n\t\telse if(s==\"D\")\n\t\t{\n\t\t\t\n\t\t\tcin>>k;\n\t\t\tremove(k+1);\n\t\t}\n\t\telse if(s==\"IL\")\n\t\t{\n\t\t\t\n\t\t\tcin>>k>>x;\n\t\t\tinsert(l[k+1],x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\n\t\t\tcin>>k>>x;\n\t\t\tinsert(k+1,x);\n\t\t}\n\t}\n\tfor(int i=r[0];i!=1;i=r[i])\n\t{\n\t\tcout<<e[i]<<' ';\n\t}\n\n\treturn 0;\t\n}\n```\n\n## 单调栈 830\n\n输出每个数左边第一个比它小的数，如果不存在则输出 −1\n\n```c++\n\twhile (n--)\n\t{\n        int x; cin >> x ;\n        while (tt && st[tt] >= x ) tt--;\n        if (tt) cout << st[tt] << ' ';\n        else cout << \"-1 \";\n        st[++ tt] = x;\n    }\n```\n\n## [括号匹配](https://noobdream.com/DreamJudge/Issue/page/1296/)\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=100086;\nstack<int >sta;\nstring s;\nint n,x=0,m;\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n\twhile(getline(cin,s))\n\t{\n\t\tvector<char >res(s.size(),' ');\n\t\tfor(int i=0;i<s.size();i++)\n\t\t{\n\t\t\tif(s[i]=='(')\n\t\t\t{\n\t\t\t\tsta.push(i);\n\t\t\t}\n\t\t\telse if(s[i]==')')\n\t\t\t{\n\t\t\t\tif(sta.size())\n\t\t\t\t{\n\t\t\t\t\tsta.pop();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tres[i]='?';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(sta.size())\n\t\t{\n\t\t\tres[sta.top()]='$';\n\t\t\tsta.pop();\n\t\t}\n\t\tcout<<s<<endl;\n\t\tfor(int i=0;i<s.size();i++)\n\t\t{\n\t\t\tcout<<res[i];\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\t\n}\n```\n\n\n\n## 滑动窗口  154\n\n```c++\nvoid maxSlidingWindow() \n{\n\ttt=-1,hh=0;\n        for(int i=0;i<n;i++)\n        {\n            //判断对头是否滑出\n            if(hh<=tt&&k+q[hh]-1<i)\n            {\n                hh++;\n            }\n            while(hh<=tt&&nums[q[tt]]<=nums[i])\n            {\n                tt--;\n            }\n            q[++tt]=i;\n            if(i>=k-1)\n            {\n                cout<<nums[q[hh]]<<\" \";\n            }\n        }\n        \n}\n```\n\n## KMP字符串 831\n\n第一行输入整数 N，表示字符串 P 的长度。第二行输入字符串 P。\n\n第三行输入整数 M，表示字符串 S 的长度。第四行输入字符串 S。\n\n```c++\nstring p,s; \nvoid getnext()\n{\n\tne[0]=-1;\n\tint j=-1;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\twhile(j>=0&&p[i]!=p[j+1])\n\t\t{\n\t\t\tj=ne[j];\n\t\t}\n\t\tif(p[i]==p[j+1])\n\t\t{\n\t\t\tj++;\n\t\t}\n\t\tne[i]=j;\n//\t\tcout<<i<<\": \"<<ne[i]<<endl;\n\t}\n}\nvoid kmp()\n{\n\tint j=-1;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\twhile(j>=0&&s[i]!=p[j+1])\n\t\t{\n\t\t\tj=ne[j];\n\t\t}\n\t\tif(s[i]==p[j+1])j++;\n\t\tif(j==n-1)\n\t\t{\n\t\t\tcout<<i-j<<\" \";\n\t\t\tj=ne[j];\n\t\t}\n\t}\n}\n```\n\n## 字典树 Trie\n\n### 835. Trie字符串统计\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100086;\nint son[N][26],cnt[N],idx,n;\n\nvoid insert(string s)\n{\n\tint p=0;\n\tfor(int i=0;i<s.size();i++)\n\t{\n\t\tint u=s[i]-'a';\n\t\tif(!son[p][u])son[p][u]=++idx;\n\t\tp=son[p][u];\n\t}\n\tcnt[p]++;\n}\nint query(string s)\n{\n\tint p=0;\n\tfor(int i=0;i<s.size();i++)\n\t{\n\t\tint u=s[i]-'a';\n\t\tif(!son[p][u])return 0;\n\t\tp=son[p][u];\n\t}\n\treturn cnt[p];\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n\tcin>>n;\n\twhile(n--)\n\t{\n\t\tchar op;\n\t\tstring s1\n\t\tcin>>op;\n\t\tif(op=='I')\n\t\t{\n\t\t\tcin>>s1;\n\t\t\tinsert(s1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcin>>s1;\n\t\t\tcout<<query(s1)<<endl;\n\t\t}\n\t}\n    return 0;\n}\n\n```\n\n### 143. 最大异或对\n\n在给定的 N 个整数 中选出两个进行 xor（异或）运算，得到的结果最大是多少？\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100086;\nint son[3000000][2],cnt[N],idx,n;\nint a[N];\nvoid insert(int x)\n{\n\tint p=0;\n\tfor(int i=30;~i;i--)\n\t{\n\t\tint u=x>>i&1;\n\t\tif(!son[p][u])son[p][u]=++idx;\n\t\tp=son[p][u];\n\t\t//cout<<u<<endl;\n\t}\n}\nint query(int x)\n{\n\tint p=0,res=0;\n\tfor(int i=30;~i;i--)\n\t{\n\t\tint u=x>>i&1;\n\t\tif(son[p][!u])\n\t\t{\n\t\t\tp=son[p][!u];\n\t\t\tres+=1<<i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp=son[p][u];\n\t\t}\t\n\t}\n\treturn res;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i];\n\t\tinsert(a[i]);\n\t}\n\tint ans=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tans=max(query(a[i]),ans);\n//\t\tcout<<ans<<endl;\n\t}\n\tcout<<ans<<endl;\n    return 0;\n}\n\n```\n\n## 并查集\n\n### KY34 Is It A Tree?\n\n```c++\n// 参考题解\n#include <iostream>\nusing namespace std;\nconst int MAX = 10000;\nint father[MAX];\nint height[MAX];\nint inDegree[MAX];\nbool visited[MAX];\n\nvoid Initial () { // 初始化\n    for (int i = 0; i < MAX; ++i) {\n        father[i] = i;\n        height[i] = 0;\n        visited[i] = false;\n        inDegree[i] = 0;\n    }\n}\n\nbool IsTree() { // 判断是否符合树的定义\n    int part = 0, root = 0, isTree = true;\n\n    for (int i = 0; i < MAX; ++i) {\n        if (!visited[i])\n            continue;\n\n        if (inDegree[i] == 0)\n            root++;\n\n        if (father[i] == i)\n            part++;\n\n        if (inDegree[i] > 1)\n            return false; // 如果某个节点的入度大于1，直接返回false\n    }\n    if (root != 1 || part != 1) { // 一棵树应该只有一个节点的入度等于0\n        isTree = false;\n    }\n    if (root == 0 && part == 0) { // 空树也是树...\n        isTree = true;\n    }\n    return isTree;\n}\n\nint Find(int x) { // 查找根结点\n    if (x != father[x]) {\n        father[x] = Find(father[x]); // 路径压缩\n    }\n    return father[x];\n}\n\nvoid Union(int x, int y) { // 合并集合\n    x = Find(x);\n    y = Find(y);\n\n    if (x != y) \n    {\n            father[x] = y;\n    }\n    \n}\n\nint main() {\n    int a, b, k = 1;\n    Initial();\n    while (cin >> a >> b) {\n        if (a == -1 && b == -1)\n            break;\n        else if (a == 0 && b == 0) {\n\n            if (IsTree()) {\n                cout << \"Case \" << k++ <<\" is a tree.\" << endl;\n            } else {\n                cout << \"Case \" << k++ <<\" is not a tree.\" << endl;\n            }\n            Initial(); // 这里别忘记\n        } else {\n            Union(a, b);\n            visited[a] = true;\n            visited[b] = true;\n            inDegree[b]++;\n        }\n    }\n    return 0;\n}\n```\n\n```c++\n//思路和上面一致\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=10086;\nint a,b,n,m,res=0,maxx;\nint p[INF],s[INF],flag=0; //存储每个点的祖宗节点\nint ind[INF],vis[INF];\n// 返回x的祖宗节点\n//注意root的入度为0\nint find(int x)\n{\n    if (p[x] != x) p[x] = find(p[x]);\n    return p[x];\n}\nint istree()\n{\n    int root=0,cnt=0,panduan=1;\n    // if(flag)return 0;\n    for(int i=0;i<INF;i++)\n    {\n        if(!vis[i])continue;\n        if(!ind[i])root++;\n        if(p[i]==i)cnt++;\n        // cout<<\" \"<<ind[i]<<endl;\n        if(ind[i]>1)return 0;\n         \n    }\n    // cout<<root<<\" \"<<cnt<<endl;\n     \n    if(root != 1 || cnt != 1)panduan=0;\n    if(root==0&&cnt==0)panduan=1;\n    return panduan;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int k=1;\n    for(int i=0;i<INF;i++)\n    {\n        p[i]=i;\n        vis[i]=0;\n        ind[i]=0;\n        // s[i]=1;\n    }\n    while(cin>>a>>b)\n    {\n      if(a==-1&&b==-1)break;\n      else if(a==0&&b==0)\n      {\n        if(istree())\n        {\n            cout << \"Case \" << k++ <<\" is a tree.\" << endl;\n        }\n        else\n        {\n            cout << \"Case \" << k++ <<\" is not a tree.\" << endl;\n        }\n        for(int i=0;i<INF;i++)\n        {\n            p[i]=i;\n            vis[i]=0;\n            ind[i]=0;\n        // s[i]=1;\n        }\n        flag=0;\n      }\n      else\n      {\n        int x=find(a),y=find(b);\n        if(x==y)\n        {\n            // flag=1;\n            //  continue;\n        }\n        else\n        {\n            p[x]=y;\n        }\n        vis[a]=1;\n        vis[b]=1;\n        ind[b]++;\n      } \n    }\n    return 0;  \n}\n```\n\n### 240. 食物链\n\n动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。\n\nA吃B， B吃C，C吃A。\n\n现有N个动物，以1－N编号。\n\n每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。\n\n有人用两种说法对这N个动物所构成的食物链关系进行描述：\n\n第一种说法是”1 X Y”，表示X和Y是同类。\n\n第二种说法是”2 X Y”，表示X吃Y。\n\n此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。\n\n当一句话满足下列三条之一时，这句话就是假话，否则就是真话。\n\n1） 当前的话与前面的某些真的话冲突，就是假话；\n2） 当前的话中X或Y比N大，就是假话；\n3） 当前的话表示X吃X，就是假话。\n\n你的任务是根据给定的N和K句话，输出假话的总数。\n\n输入格式\n第一行是两个整数N和K，以一个空格分隔。\n\n以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。\n\n若D=1，则表示X和Y是同类。\n\n若D=2，则表示X吃Y。\n\nhttps://www.acwing.com/solution/content/113385/\n\n<img src=\"D:\\wyh\\大学\\信息\\image-20230705221555787.png\" alt=\"image-20230705221555787\" style=\"zoom:50%;\" />\n\n```c++\n输入样例：\n100 7\n1 101 1 \n2 1 2\n2 2 3 \n2 3 3 \n1 1 3 \n2 3 1 \n1 5 5\n输出样例：\n3\n```\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100010;\n\nint n, m,res;\nint p[N], d[N],k,d1,x,y;\nstring op;\nint find(int x)\n{\n\t// 要先回溯把到父节点的距离，变成到根节点的距离，所以要先find，处理x的父节点。\n    // 这个find语句执行完以后，p[x]到根节点的距离都更新了。\n\tif(p[x]!=x)\n\t{\n\t\tint t=find(p[x]);\n\t\td[x]+=d[p[x]];\n\t\tp[x] = t;\n\t}\n\treturn p[x];\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>n>>k;\n    int res=0;\n    for(int i=0;i<n;i++)\n    {\n    \tp[i]=i;\n\t}\n    while(k--)\n    {\n    \tcin>>d1>>x>>y;\n    \tif(x>n||y>n)\n    \t{\n    \t\tres++;\n    \t\tcontinue;\n\t\t}\n\t\tint px=find(x),py=find(y);\n\t\tif(d1==1)\n\t\t{\n\t\t\tif(px==py)\n\t\t\t{\n\t\t\t\tif((d[x]-d[y])%3)res++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tp[px]=py;\n\t\t\t\td[px]=d[y]-d[x];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(px==py&&(d[x]-d[y]-1)%3)res++;\n\t\t\telse if(px!=py)\n\t\t\t{\n\t\t\t\tp[px]=py;\n\t\t\t\td[px]=d[y]-d[x]+1;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n    return 0;\n}\n```\n\n问题的核心在于对于任意的X和Y，如何去确定X和Y的关系。\n\n题目说有三类动物，形成了一个环形，A吃B，B吃C，C吃A，这就和数学中的取模很相似，0->1->2->3(3即是0)\n我们采用数组d[i]来代表i节点到父节点的代数，通过dmod3转化为0,1,2三代的关系。\n$$\nd[x] mod 3 == d[y] mod 3\n$$\n 对应X与Y为同类，具体可以是，同为0代，同为1代，同为2代\n$$\n(d[x]+1)mod3==d[y]mod3\n$$\n对应X吃Y，具体可以有三种情况\n$$\n(d[x]+2)mod3==d[y]mod3\n$$\n 对应X被Y吃，同上\n\n至此我们已经判断出X和Y的关系，也能很容易判断真话假话。\n假话：\n\n1. X或Y过界\n2. X和Y都已经出现过（在并查集中），并且当前关系与并查集中的关系不同\n真话：\n1.X和Y未都出现过（需要加入并查集）\n2.X和Y已经出现过，并且当前关系与并查集中的关系一致\n\n### [KY138 Head of a Gang](https://www.nowcoder.com/practice/a31b1ea6c87647bc86e382acaf21c53b?tpId=63&tqId=29585&tPage=2&ru=%2Fkaoyan%2Fretest%2F9001&qru=%2Fta%2Fzju-kaoyan%2Fquestion-ranking)\n\n- 输入一串序列：Name1 Name2 Time表示A和B的通话时间，假定存在通话的人所在圈子大于2个人，认为是一个黑帮，在这个黑帮中，打电话时间最长的是老大\n\n  \n\n```c++\n/*\n这题有点复杂，思路：\n1.先存下所有人的电话总时间，并且将他们分为集合；\n2.遍历集合，得到集合的数量，记录集合标识\n3.对于每个集合，遍历所有人判断他们是否属于这个集合，是则贡献集合的总weight，member++，且随时记录weight最大的人，\n若最后weight>k*2且member>=3，就把这个gang存起来\n4.输出总gang数，按顺序输出集合leader+member\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=100086;\nint a,b,n,m,k,res=0,maxx; \nunordered_map<string, int >wei;\nmap<string,string >p;\nstring op;\n// 返回x的祖宗节点\nstring find(string x)\n{\n    if (p.find(x) != p.end()) \n    {\n        if(p[x]!=x)\n        \tp[x] = find(p[x]);\n    }\n    else\n    {\n        p[x]=x;\n    }\n    return p[x];\n}\nvoid uni(string name1,string name2)\n{\n    string x=find(name1);\n    string y=find(name2);\n    p[x]=y;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n    while(cin>>n>>k)\n    {\n        for(int i=0;i<n;i++)\n        {\n            string name1,name2;\n            int time=0;\n            cin>>name1>>name2>>time;\n            uni(name1,name2);\n            wei[name1]+=time,wei[name2]+=time;\n        }\n        int gangs=0;\n        vector<string>gangld;\n        for(auto& it:p)\n        {\n            if(it.first==it.second)\n            {\n                gangld.push_back(it.second);//可能还不是首领\n            }\n        }\n        vector<pair<string,int>>ganginfo;\n        for(int i=0;i<gangld.size();i++)\n        {\n            int ldwei=0,num=0;\n            int weisum=0;\n            string ldname;\n            for(auto& it:p)\n            {\n                if(find(it.first)==gangld[i])\n                {\n                    if(wei[it.first]>ldwei)\n                    {\n                        ldwei=wei[it.first];\n                        ldname=it.first;\n                    }\n                    weisum+=wei[it.first];\n                    num++;\n                }\n                \n            }\n            if(num>=3&&weisum>k*2)\n            {\n                gangs++;\n                ganginfo.push_back({ldname,num});\n            }\n        }\n        cout<<gangs<<endl;\n        for(int i=0;i<gangs;i++)\n        {\n            cout<<ganginfo[i].first<<\" \"<<ganginfo[i].second<<endl;\n        }\n        p.clear();\n        wei.clear();\n    }\n\treturn 0;\t\n}\n```\n\n## 堆\n\n### 838.堆排序\n\n```c++\nusing namespace std;\nconst int N = 100086;\nint a[N];//保存数组\nint n, m;//n个点，求前m小\nint r ;//堆得右边界\nvoid down(int u)//调整函数\n{\n    //t记录最小点的编号\n    int t = u;\n    //有左儿子，并且左儿子比t节点的值小，更新t\n    if(2 * u <= r && a[2 * u] < a[u]) t = 2 * u;\n    //有右儿子，并且右儿子比t节点的值小，更新t\n    if(2 * u + 1 <= r && a[2 * u + 1] < a[t]) t = 2 * u + 1;\n    //如果待调整点不是最小的\n    if(u != t)\n    {\n        //和最小的交换\n        swap(a[u], a[t]);\n        //递归处理\n        down(t);\n    }\n}\nint main()\n{\n    cin >> n >> m;\n    r = n;//开始时，右边界是数组边界\n    //读入数据\n    for (int i = 1; i <= n; i ++ )\n    {\n        int x;\n        cin >> a[i];\n    }\n    //从第一个非叶节点开始，从右到左，从下到上处理每个节点\n   for(int i = n /2 ; i >= 1; i--)\n   {\n       down(i);\n   }\n    //输出m个最小值\n    while (m -- )\n    {\n        //堆顶保存的最小值，输出堆顶\n        cout << a[1] << \" \";\n        //将堆顶和右边界交换\n        swap(a[1], a[r]);\n        //右边界左移\n        r--;\n        //从新处理堆顶\n        down(1);\n    }\n}\n```\n\n#### 从零计数\n\n```c++\nconst int N = 100086;\nclass Solution {\npublic:\n    int h[N];   //堆\n    int cur_size=0;   //size 记录的是堆当前的数据多少\n    int panduan(int x,int y)\n    {\n        return h[x]>h[y];\n    }\n\n    // 下沉操作\n    void down(int u) {\n        int t = u;\n        if (2 * u + 1 < cur_size && panduan(t, 2 * u + 1))\n            t = 2 * u + 1;\n        if (2 * u + 2 < cur_size && panduan(t, 2 * u + 2))\n            t = 2 * u + 2;\n        if (u != t) {\n            swap(h[u], h[t]);\n            down(t);\n        }\n    }\n\n    // 上浮操作\n    void up(int u) {\n        while (u > 0 && panduan((u - 1) / 2, u)) {\n            swap(h[(u - 1) / 2], h[u]);\n            u = (u - 1) / 2;\n        }\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> res;\n        for (int i = 0; i < n; i++) \n        {\n            h[cur_size++] = nums[i];\n            up(cur_size - 1);\n        }\n        while (n--) \n        {\n            res.push_back(h[0]); // 将堆顶元素加入结果数组\n            swap(h[0], h[--cur_size]); // 将堆顶元素与最后一个元素交换\n            down(0); // 重新调整堆\n        }\n        return res;\n    }\n};\n```\n\n\n\n### 839. 模拟堆\n\n维护一个集合，初始时集合为空，支持如下几种操作：\n\n1. `I x`，插入一个数 xx；\n2. `PM`，输出当前集合中的最小值；\n3. `DM`，删除当前集合中的最小值（数据保证此时的最小值唯一）；\n4. `D k`，删除第 kk 个插入的数；\n5. `C k x`，修改第 kk 个插入的数，将其变为 xx；\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=1e5+10;\nint h[N];   //堆\nint ph[N];  //存放第k个插入点的下标\nint hp[N];  //存放堆中点的插入次序\nint cur_size;   //size 记录的是堆当前的数据多少\n\n//这个交换过程其实有那么些绕 但关键是理解 如果hp[u]=k 则ph[k]=u 的映射关系\n//之所以要进行这样的操作是因为 经过一系列操作 堆中的元素并不会保持原有的插入顺序\n//从而我们需要对应到原先第K个堆中元素\n//如果理解这个原理 那么就能明白其实三步交换的顺序是可以互换 \n//h,hp,ph之间两两存在映射关系 所以交换顺序的不同对结果并不会产生影响\nvoid heap_swap(int u,int v)\n{   \n    swap(h[u],h[v]); \n     swap(hp[u],hp[v]);     \n     swap(ph[hp[u]],ph[hp[v]]);            \n\n}\n\nvoid down(int u)\n{\n    int t=u;\n    if(u*2<=cur_size&&h[t]>h[u*2]) t=u*2;\n    if(u*2+1<=cur_size&&h[t]>h[u*2+1])  t=u*2+1;\n    if(u!=t)\n    {\n        heap_swap(u,t);\n        down(t);\n    }\n}\nvoid up(int u)\n{\n    while(u/2&&h[u/2]>h[u])\n    {\n        heap_swap(u/2,u);\n        u/=2;\n    }\n}\n\nint main()\n{\n    int n;\n    cin>>n;\n    int m=0;      //m用来记录插入的数的个数\n                //注意m的意义与cur_size是不同的 cur_size是记录堆中当前数据的多少\n                //对应上文 m即是hp中应该存的值\n    while(n--)\n    {\n        string op;\n        int k,x;\n        cin>>op;\n        if(op==\"I\")\n        {\n            cin>>x;\n            m++;\n            h[++cur_size]=x;\n            ph[m]=cur_size;\n            hp[cur_size]=m;\n            //down(size);\n            up(cur_size);\n        }\n        else if(op==\"PM\")    cout<<h[1]<<endl;\n        else if(op==\"DM\")\n        {\n            heap_swap(1,cur_size);\n            cur_size--;\n            down(1);\n        }\n        else if(op==\"D\")\n        {\n            cin>>k;\n            int u=ph[k];                //这里一定要用u=ph[k]保存第k个插入点的下标\n            heap_swap(u,cur_size);          //因为在此处heap_swap操作后ph[k]的值已经发生 \n            cur_size--;                    //如果在up,down操作中仍然使用ph[k]作为参数就会发生错误\n            up(u);\n           down(u);\n        }\n        else if(op==\"C\")\n        {\n            cin>>k>>x;\n            h[ph[k]]=x;                 //此处由于未涉及heap_swap操作且下面的up、down操作只会发生一个所以\n            down(ph[k]);                //所以可直接传入ph[k]作为参数\n            up(ph[k]);\n        }\n\n    }\n    return 0;\n}\n```\n\n### STL \n\n```c++\npriority_queue<int,vector<int>,greater<int>> q;//从小到大\n```\n\n### [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)\n\n#### STL两种\n\n```c++\nclass Solution \n{\npublic:\n    static bool cmp(pair<int, int>& m, pair<int, int>& n) \n    {\n        return m.second > n.second;\n    }\n    vector<int> topKFrequent(vector<int>& nums, int k) \n    {\n        unordered_map<int,int>occur;\n\n        for(int i=0;i<nums.size();i++)\n        {\n            occur[nums[i]]++;\n        }\n        // pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp);\n\n        vector<int>ans;\n        for(auto& [num, count] : occur)//前k个元素入队\n        {\n           if(q.size()!=k)\n           {\n               q.emplace(make_pair(num,count));\n           }\n           else\n           {\n               if(q.top().second<count)\n               {\n                   q.pop();\n                   q.emplace(num,count);\n               }\n           }\n        }\n        while(!q.empty())\n        {\n            ans.emplace_back(q.top().first);\n            q.pop();\n        }\n        return ans;\n    }\n};\n```\n\n```c++\nclass frequency\n{\npublic:\n    int num;\n    int freq;\n    frequency(int a, int b):num(a),freq(b){}\n    bool operator<(const frequency &c)const\n    {\n        return freq>c.freq;//小根堆\n    }\n};\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int,int>umap;\n        for(int x:nums)umap[x]++;\n        priority_queue<frequency> q;\n        vector<int>ans;\n        for(auto& x:umap)\n        {\n            if(q.size()!=k)q.push({x.first,x.second});\n            else\n            {\n                auto t=q.top();\n                if(t.freq<x.second)\n                {\n                    q.pop();\n                    q.push({x.first,x.second});\n                }\n            }\n        }\n        while(!q.empty())\n        {\n            ans.push_back(q.top().num);\n            q.pop();\n        }\n        return ans;\n    }\n};\n```\n\n\n\n### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)\n\n```c++\nconst int N=1e5+10;\n\nclass Solution {\npublic:\n    vector<int> nums;\n    int h[N];   //堆\n    int cur_size=0;   //size 记录的是堆当前的数据多少\n    int panduan(int x,int y)\n    {\n        return h[x]>h[y];\n    }\n    void down(int u)\n    {\n        int t=u;\n        if(u*2<=cur_size&&panduan(t,u*2)) t=u*2;\n        if(u*2+1<=cur_size&&panduan(t,u*2+1))  t=u*2+1;\n        if(u!=t)\n        {\n            swap(h[u],h[t]);\n            down(t);\n        }\n    }\n    //第二种\n    void down2(int u) {\n        int t = u;\n        while (u * 2 <= cur_size || u * 2 + 1 <= cur_size) {\n            int left_child = u * 2;\n            int right_child = u * 2 + 1;\n            \n            // 找出左右子节点中较小（或较大）的那个节点\n            if (left_child <= cur_size && panduan(t, left_child))\n                t = left_child;\n            if (right_child <= cur_size && panduan(t, right_child))\n                t = right_child;\n            \n            // 如果父节点与较小（或较大）的子节点不一致，则交换它们，并继续向下调整\n            if (u != t) {\n                swap(h[u], h[t]);\n                u = t;\n            } else {\n                break; // 如果已经满足堆性质，则退出循环\n            }\n        }\n    }\n    void up(int u)\n    {\n        while(u/2&&panduan(u/2,u))\n        {\n            swap(h[u/2],h[u]);\n            u/=2;\n        }\n    }\n    int findKthLargest(vector<int>& _nums, int k) {\n        nums=_nums;\n        for(int i =0; i< k; i++)\n        {\n            //q.push(nums[i]);\n            h[++cur_size]=nums[i];\n            up(cur_size);\n        }\n        for(int i=k;i<nums.size();i++)\n        {\n            int t=h[1];\n            if(nums[i]>t)\n            {\n                //q.pop();\n                swap(h[1],h[cur_size]);\n                cur_size--;\n                down(1);\n                //q.push(nums[i]);\n                h[++cur_size]=nums[i];\n                up(cur_size);;\n            }\n        }\n        return h[1];\n    }\n};\n```\n\n#### STL\n\n```C++\nclass Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n        //优先队列\n        priority_queue<int,vector<int>,greater<int>> q;\n        for(int i =0; i< k; i++)//前k个元素入队\n        {\n            q.push(nums[i]);\n        }\n        //将数组剩下的元素入队,则top就是第k个元素\n        //如果使用大根堆，则需要n个\n        for(int i = k;i < nums.size();i++)\n        {\n            int t = q.top();//取最顶上的元素\n            if(nums[i] > t)\n            {\n                q.pop();\n                q.push(nums[i]);\n            }\n            //q.top现在是前i个元素的第k个最大元素\n        }\n        return q.top();\n    }\n};\n```\n\n\n\n### KY196 复数集合\n\n一个复数（x+iy）集合，两种操作作用在该集合上：   1、Pop 表示读出集合中复数模值最大的那个复数，如集合为空 输出 empty ，不为空就输出最大的那个复数并且从集合中删除那个复数，再输出集合的大小SIZE；   2 Insert a+ib 指令（a，b表示实部和虚部），将a+ib加入到集合中 ，输出集合的大小SIZE；   最开始要读入一个int n，表示接下来的n行每一行都是一条命令。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=1e5+10;\nclass complexx\n{\npublic:\n    int real;\n    int imag;\n    complexx(int a, int b):real(a),imag(b){}\n    bool operator<(const complexx &c)const\n    {\n        \n        int yre=c.real;\n        int yim=c.imag;\n        if(real*real+imag*imag==yim*yim+yre*yre)\n        {\n            return imag>c.imag;\n        }\n        else\n        {\n            return real*real+imag*imag<yim*yim+yre*yre;\n        }\n    }\n};\n\nint main()\n{\n    int n;\n    while(cin>>n)\n    {\n        priority_queue<complexx> q;\n        while(n--)\n        {\n            string op;\n            cin>>op;\n            if(op==\"Pop\")\n            {\n                if(q.empty())\n                {\n                    cout<<\"empty\"<<endl;\n                }\n                else\n                {\n                    complexx cc=q.top();\n                    q.pop();\n                    cout<<cc.real<<\"+i\"<<cc.imag<<endl;\n\n                    cout<<\"SIZE = \"<<q.size()<<endl;\n                }\n            }\n            else\n            {\n                int a=0,b=0;\n                scanf(\"%d+i%d\",&a,&b);\n                q.push(complexx(a,b));\n                cout<<\"SIZE = \"<<q.size()<<endl;\n            }\n        }\n    }\n    return 0;\n}\n```\n\n手写堆\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=1e5+10;\npair<int,int>h[N];   //堆\nint cur_size;   //size 记录的是堆当前的数据多少\nint panduan(int x,int y)\n{\n    int xim=h[x].first;\n    int xre=h[x].second;\n    int yim=h[y].first;\n    int yre=h[y].second;\n    if(xim*xim+xre*xre==yim*yim+yre*yre)\n    {\n        return xre>yre;\n    }\n    else\n    {\n        return xim*xim+xre*xre<yim*yim+yre*yre;\n    }\n    \n}\n\nvoid down(int u)\n{\n    int t=u;\n    if(u*2<=cur_size&&panduan(t,u*2)) t=u*2;\n    if(u*2+1<=cur_size&&panduan(t,u*2+1))  t=u*2+1;\n    if(u!=t)\n    {\n        swap(h[u],h[t]);\n        down(t);\n    }\n}\n//down递推版\nvoid down(int u) {\n    int t = u;\n    while (u * 2 <= cur_size || u * 2 + 1 <= cur_size) {\n        int left_child = u * 2;\n        int right_child = u * 2 + 1;\n        \n        // 找出左右子节点中较小（或较大）的那个节点\n        if (left_child <= cur_size && panduan(t, left_child))\n            t = left_child;\n        if (right_child <= cur_size && panduan(t, right_child))\n            t = right_child;\n        \n        // 如果父节点与较小（或较大）的子节点不一致，则交换它们，并继续向下调整\n        if (u != t) {\n            swap(h[u], h[t]);\n            u = t;\n        } else {\n            break; // 如果已经满足堆性质，则退出循环\n        }\n    }\n}\n\nvoid up(int u)\n{\n    while(u/2&&panduan(u/2,u))\n    {\n        swap(h[u/2],h[u]);\n        u/=2;\n    }\n}\n\nint main()\n{\n    int n;\n    while(cin>>n)\n    {\n        while(n--)\n        {\n            string op;\n            cin>>op;\n            if(op==\"Pop\")\n            {\n                if(!cur_size)\n                {\n                    cout<<\"empty\"<<endl;\n                }\n                else\n                {\n                    cout<<h[1].first<<\"+i\"<<h[1].second<<endl;\n                    \n                    swap(h[1],h[cur_size]);\n                    cur_size--;\n                    down(1);\n                    cout<<\"SIZE = \"<<cur_size<<endl;\n                }\n            }\n            else\n            {\n                int a=0,b=0;\n                scanf(\"%d+i%d\",&a,&b);\n                h[++cur_size]={a,b};\n                up(cur_size);\n                cout<<\"SIZE = \"<<cur_size<<endl;\n            }\n        }\n    }\n    return 0;\n}\n```\n\n## 散列表\n\n### 840.模拟散列表\n\n```c++\n(1) 拉链法\n    int h[N], e[N], ne[N], idx;\n\n    // 向哈希表中插入一个数\n    void insert(int x)\n    {\n        int k = (x % N + N) % N;\n        e[idx] = x;\n        ne[idx] = h[k];\n        h[k] = idx ++ ;\n    }\n\n    // 在哈希表中查询某个数是否存在\n    bool find(int x)\n    {\n        int k = (x % N + N) % N;\n        for (int i = h[k]; i != -1; i = ne[i])\n            if (e[i] == x)\n                return true;\n\n        return false;\n    }\n\n(2) 开放寻址法\n    int h[N];\n\n    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置\n    int find(int x)\n    {\n        int t = (x % N + N) % N;\n        while (h[t] != null && h[t] != x)\n        {\n            t ++ ;\n            if (t == N) t = 0;\n        }\n        return t;\n    }\n\n```\n\n### 841.字符串哈希\n\n请你判断 [l1,r1] 和 [l2,r2] 这两个区间所包含的字符串子串是否完全相同。\n\n```c++\nchar str[N];\n//核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低\n//小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果\nint n,m;\ntypedef unsigned long long ULL;\nULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64\n// 计算子串 str[l ~ r] 的哈希值\nULL get(int l, int r)\n{\n    return h[r] - h[l - 1] * p[r - l + 1];\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n    memset(h, 0x3f, sizeof(h));\n    cin>>n>>m>>str+1;\n    p[0]=1;\n    for(int i=1;i<=n;i++)\n    {\n    \tp[i]=p[i-1]*P;\n    \th[i]=h[i-1]*P+str[i];\n\t}\n    while(m--)\n    {\n    \tint l1=0,r1=0,l2=0,r2=0;\n    \tcin>>l1>>r1>>l2>>r2;\n    \tif(get(l1,r1)==get(l2,r2))cout<<\"Yes\"<<endl;\n    \telse cout<<\"No\"<<endl;\n\t}\n    return 0;\n}\n```\n\n### STL\n\nmap输出第一个和最后一个\n\n```c++\n        auto it=info2.end();\n        it--;\n        cout<< info1.begin()->second<<\" \"<<it->second;\n```\n\nsort\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nstruct P \n{\n    string id;\n    string come;\n    string exit;\n};\nbool cmp1(P p1, P p2)\n{\n    return p1.come < p2.come;\n}\nbool cmp2(P p1, P p2) \n{\n    return p1.exit > p2.exit;\n}\nint main()\n{\n    int m;\n    while(cin>>m) \n    {\n        P p[1000];\n        for(int i = 0; i < m; i++) \n        {\n            cin>>p[i].id>>p[i].come>>p[i].exit;\n        }\n        sort(p, p+m, cmp1);\n        cout<<p[0].id<<\" \";\n        sort(p, p+m, cmp2);\n        cout<<p[0].id<<endl;\n    }\n    return 0;\n}\n```\n\n\n\n\n","tags":["加密文章tag"],"categories":["Algorithm"]},{"title":"tree","url":"/2024/06/04/tree/","content":"# 树\n\n|      | [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/) | **HOT100** | 递归+迭代                                                    | [morris](https://leetcode.cn/problems/binary-tree-inorder-traversal/solutions/96765/dong-hua-yan-shi-94-er-cha-shu-de-zhong-xu-bian-li)<br/>morris 不改结构（类似线索二叉树），官解 |\n| ---- | ------------------------------------------------------------ | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n|      | [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/) |            | 递归+迭代                                                    | morris:和中序只要改if (pre->right == nullptr) {<br/>                    res.push_back(root->val); |\n|      | [145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/) |            | 递归+迭代                                                    | [morris](https://leetcode.cn/problems/binary-tree-postorder-traversal/solutions/431066/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/comments/1768971) 把94中序的左右颠倒 |\n| 层序 | [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/) | **HOT100** | 递归+迭代                                                    |                                                              |\n|  | [429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/) |  | 没啥区别 | |\n|  | [103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)<br />[LCR 151. 彩灯装饰记录 III](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/) |  | 102倒过来 | |\n|      | [107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/) |            | 和102没区别，倒过来就行                                      |                                                              |\n| | [662. 二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/) | | [bfs,注意越界ull](https://leetcode.cn/problems/maximum-width-of-binary-tree/solutions/1776589/er-cha-shu-zui-da-kuan-du-by-leetcode-so-9zp3/comments/1724979) | [dfs](https://leetcode.cn/problems/maximum-width-of-binary-tree/solutions/1778862/by-ac_oier-33er) |\n| | [958. 二叉树的完全性检验](https://leetcode.cn/problems/check-completeness-of-a-binary-tree/) | | 层次遍历，空值也入队，当出队值为空时判断队列剩下元素是否都为空，为则完全二叉树 | dfs 也可，和662类似 |\n| 递归 | [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/) | **HOT100** | [递归](https://leetcode.cn/problems/binary-tree-right-side-view/solutions/2015061/ru-he-ling-huo-yun-yong-di-gui-lai-kan-s-r1nc)+迭代 |                                                              |\n|      | [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/) | **HOT100** | 递归+迭代                                                    |                                                              |\n|      | [559. N 叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/) |            | [递归+迭代](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/solutions/1113062/gong-shui-san-xie-yi-ti-shuang-jie-dfs-b-n956) |                                                              |\n|      | [111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/) |            | 递归（[前序](https://leetcode.cn/problems/minimum-depth-of-binary-tree/solutions/2730984/liang-chong-fang-fa-zi-ding-xiang-xia-zi-0sxz) [后续](https://programmercarl.com/0111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html#思路)）+迭代 |                                                              |\n|      | [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)<br />[LCR 144. 翻转二叉树](https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/) | **HOT100** | 递归+迭代                                                    |                                                              |\n|      | [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/) |            | [后序（递归+迭代）](https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#本题思路)+[前序](https://leetcode.cn/problems/balanced-binary-tree/solutions/8737/balanced-binary-tree-di-gui-fang-fa-by-jin40789108)前序，时间复杂度 ||\n|      | [222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/) |            | [完全二叉树性质](https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html#思路) | 二分+位运算（官解）                                          |\n| | [1325. 删除给定值的叶子节点](https://leetcode.cn/problems/delete-leaves-with-a-given-value/) | | 后序 |  |\n| | [3693 · 克隆 N 叉树](https://www.lintcode.com/problem/3693/description)<br />[1490. 克隆 N 叉树](https://leetcode.cn/problems/clone-n-ary-tree) | | dfs or bfs |  |\n| | [617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/) | | dfs or bfs |  |\n| [一篇文章带你吃透对称性递归(思路分析+解题模板+案例解读)](https://leetcode.cn/problems/subtree-of-another-tree/solutions/791035/yi-pian-wen-zhang-dai-ni-chi-tou-dui-che-sd29) | [100. 相同的树](https://leetcode.cn/problems/same-tree/) | | dfs+迭代 |  |\n|      | [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/) | **HOT100** | [递归+迭代](https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#google_vignette) | 100升级 |\n| | [572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/) |  | 100+每个比对<br />前序+kmp，哈希树（官解思路） | 100升级 |\n| | [LCR 143. 子结构判断](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/) |  | dfs+迭代 | 和572类似，但注意不同 |\n| [路径](https://leetcode.cn/problems/binary-tree-maximum-path-sum/solutions/815690/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-kcb0)<br />非自顶向下： | [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/) | **HOT100** | bfs+dfs |                                                              |\n|  | [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/) | **HOT100** | 543升级版 | [带路径](https://leetcode.cn/problems/binary-tree-maximum-path-sum/solutions/1265711/follow-up-da-yin-lu-jing-by-clong0214-rmfu)<br/> |\n|  | 1245([3686 · N 叉树的直径 - LintCode](https://www.lintcode.com/problem/3686/description)) |  |  |  |\n| | [2246. 相邻字符不同的最长路径](https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/) | | 124升级（微软面试)函数要带引用不然超时 | |\n|  | [687. 最长同值路径](https://leetcode.cn/problems/longest-univalue-path/) |  |  | |\n| 自顶向下： | [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/) ||||\n|  | [112. 路径总和](https://leetcode.cn/problems/path-sum/) |  | bfs+dfs | |\n| | [113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)<br />[LCR 153. 二叉树中和为目标值的路径](https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/) |  | 112 输出路径版 | |\n| | [129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/) | | bfs+dfs 113改改 | |\n| | [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/) | **HOT100** | 双dfs（可打印出所有路径） or  前缀和 | |\n|  | [988. 从叶结点开始的最小字符串](https://leetcode.cn/problems/smallest-string-starting-from-leaf/) |  |  | |\n| 公共祖先 | [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/) | **HOT100** | dfs or 哈希存父节点(官解) | |\n|  | [235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/) |  |  | |\n| 构造 | [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) | **HOT100** | [输出后序](https://sunnywhy.com/sfbj/9/2/336)，[迭代](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/15244/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--22) | |\n|  | [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) |  | 105迭代改为左右更改，从后往前 | |\n| 二叉搜索树 | [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/) | **HOT100** | 中序，中序迭代 | |\n|  | [230. 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/) | **HOT100** | 中序，中序迭代<br />多次查询，记录k（官解bst） | |\n| | [LCR 174. 寻找二叉搜索树中的目标节点](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/) |  | 230倒过来 | |\n| | [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/) | **HOT100** | 先序 | |\n| | [450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/) |  | 递归or迭代 | |\n| | [701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/) | | 递归or迭代 | |\n| | [LCR 155. 将二叉搜索树转化为排序的双向链表](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)<br />426（要vip） | | 中序（[递归](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solutions/896127/tu-wen-bing-mao-zui-tong-su-yi-dong-de-t-0adg)or迭代 | |\n| | [538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)<br />[1038. 从二叉搜索树到更大和树](https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/) | | 反中序（可morris | |\n| 链表 | [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/) |  | [后序、后序迭代](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/solutions/13950/biao-biao-zhun-zhun-de-hou-xu-bian-li-dai-ma-jian-) | |\n| 序列化 | [297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/) | | 前序+bfs | |\n|  | [652. 寻找重复的子树](https://leetcode.cn/problems/find-duplicate-subtrees/) | | 序列化+dfs | |\n| 建图（？） | [863. 二叉树中所有距离为 K 的结点](https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/) | | 用哈希存父节点变成图遍历（bfsor dfs）官解 | |\n\n\n\n## [3686 · N 叉树的直径](https://www.lintcode.com/problem/3686/description)\n\n```c++\n/**\n * Definition for undirected graph.\n * struct UndirectedGraphNode {\n *     int label;\n *     vector<UndirectedGraphNode *> neighbors;\n *     UndirectedGraphNode(int x) : label(x) {};\n * };\n */\n\nclass Solution {\npublic:\n    /**\n     * @param root: the root of the tree\n     * @return: Maximum diameter of the N-ary Tree\n     */\n    int dfs(UndirectedGraphNode * root,int& ans)\n    {\n        if(!root)return 0;\n        int l=0,r=0;\n        for(auto nei:root->neighbors)\n        {\n            int cur=dfs(nei,ans);\n            if(cur>l)\n            {\n                r=l,l=cur;\n            }\n            else if(cur>r)r=cur;\n        }\n        ans=max(l+r+1,ans);\n        return max(l,r)+1;\n    }\n    int diameter(UndirectedGraphNode *root) {\n        // write your code here\n        if(!root)return 0;\n        int ans=0;\n        dfs(root,ans);\n        return ans-1;\n    }\n};\n```\n\n## 二叉树的最近公共祖先(含输入)\n\n```c++\n#include<bits/stdc++.h>\n#define debug(a) cout<<#a<<\"=\"<<a<<endl\n#define ll long long\nusing namespace std;\ntypedef unsigned long long ull;\nconst int N=1e3+10;\nint n,p,q;\nstruct TreeNode \n{\n    int val;\n    int left;\n    int right;\n    TreeNode() : val(0), left(-1), right(-1) {}\n    TreeNode(int x) : val(x), left(-1), right(-1) {}\n//    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\nTreeNode nodes[N];\n\nint lowestCommonAncestor(int root, int p, int q) {\n        if(root==-1||root==p||root==q)return root;\n        int lchild=lowestCommonAncestor(nodes[root].left,p,q);\n        int rchild=lowestCommonAncestor(nodes[root].right,p,q);\n        if(lchild!=-1&&rchild!=-1)\n        {\n            return root;\n        }\n        else if(lchild!=-1)\n        {\n            return lchild;\n        }\n        else if(rchild!=-1)\n        {\n            return rchild;\n        }\n        return -1;\n    }\nint main() \n{\n    int n;\n    scanf(\"%d%d%d\", &n, &p, &q);\n    for (int i = 0; i < n; i++) \n    {\n        scanf(\"%d%d\", &nodes[i].left, &nodes[i].right);\n    }\n    printf(\"%d\", lowestCommonAncestor(0, p, q));\n    return 0;\n}\n```\n\n## 先序中序还原二叉树(后序输出)\n\n```c++\n#include<bits/stdc++.h>\n#define debug(a) cout<<#a<<\"=\"<<a<<endl\n#define ll long long\nusing namespace std;\ntypedef unsigned long long ull;\nconst int N=1e3+10;\nint n;\nstruct TreeNode \n{\n    int val;\n    TreeNode * left;\n    TreeNode * right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    // TreeNode() : val(0), left(-1), right(-1) {}\n    // TreeNode(int x) : val(x), left(-1), right(-1) {}\n   TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\nTreeNode nodes[N];\n\nvector<int> pre, in, post;\n\n    TreeNode * buildTree(int preL, int preR, int inL, int inR) \n    {\n        if (preL > preR) \n        {\n            return nullptr;\n        }\n        TreeNode* root=new TreeNode(pre[preL]);\n        int inIndexOfRoot;\n        for (int i = inL; i <= inR; i++) \n        {\n            if (in[i] == root->val) \n            {\n                inIndexOfRoot = i;\n                break;\n            }\n        }\n        int leftCount = inIndexOfRoot - inL;\n        root->left = buildTree(preL + 1, preL + leftCount, inL, inIndexOfRoot - 1);\n        root->right = buildTree(preL + leftCount + 1, preR, inIndexOfRoot + 1, inR);\n        return root;\n    }\nvoid postOrder(TreeNode * root) \n{\n    if (root == nullptr) \n    {\n        return;\n    }\n    postOrder(root->left);\n    postOrder(root->right);\n    post.push_back(root->val);\n}\nint main() {\n    int n, x;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) \n    {\n        scanf(\"%d\", &x);\n        pre.push_back(x);\n    }\n    for (int i = 0; i < n; i++) \n    {\n        scanf(\"%d\", &x);\n        in.push_back(x);\n    }\n    TreeNode * root = buildTree(0, n - 1, 0, n - 1);\n    postOrder(root);\n    for (int i = 0; i < (int)post.size(); i++) \n    {\n        printf(\"%d\", post[i]);\n        if (i < (int)post.size() - 1) \n        {\n            printf(\" \");\n        }\n    }\n    return 0;\n}\n```\n\n## [3693 · 克隆 N 叉树](https://www.lintcode.com/problem/3693/description)\n\n### dfs\n\n```c++\n/**\n * Definition of NBranchTree:\n * class NBranchTree {\n * public:\n *     int val;\n *     vector<NBranchTree> children;\n *     NBranchTree(int _val) {\n *         this->val = val;\n *     }\n *     NBranchTree(int _val, vector<NBranchTree*> _children) {\n *         val = _val;\n *         children = _children;\n *     }\n * };\n */\n\nclass Solution {\npublic:\n    /**\n     * @param root: The root node of a n-branch tree.\n     * @return: The cloned tree.\n     */\n    NBranchTree* cloneTree(NBranchTree *root) {\n        // --- write your code here ---\n        if(!root)return nullptr;\n        vector<NBranchTree*> chr;\n        for(auto x:root->children)\n        {\n            NBranchTree* child=cloneTree(x);\n            chr.push_back(child);\n        }\n        return new NBranchTree(root->val,chr);\n    }\n};\n```\n\n### bfs\n\n```c++\n/**\n * Definition of NBranchTree:\n * class NBranchTree {\n * public:\n *     int val;\n *     vector<NBranchTree> children;\n *     NBranchTree(int _val) {\n *         this->val = val;\n *     }\n *     NBranchTree(int _val, vector<NBranchTree*> _children) {\n *         val = _val;\n *         children = _children;\n *     }\n * };\n */\n#define debug(a) cout<<#a<<\"=\"<<a<<\" \"\nclass Solution {\npublic:\n    /**\n     * @param root: The root node of a n-branch tree.\n     * @return: The cloned tree.\n     */\n     unordered_map<NBranchTree *,NBranchTree *>umap;\n    NBranchTree* cloneTree(NBranchTree *root) {\n        // --- write your code here ---\n        if(!root)return nullptr;\n        vector<NBranchTree*> chr;\n        queue<NBranchTree*>q;\n\n        q.push(root);\n        NBranchTree* head=nullptr;\n        while(!q.empty())\n        {\n            int size=q.size();\n           \n            for(int i=0;i<size;i++)\n            {\n                NBranchTree* node=q.front();\n                q.pop();\n                NBranchTree* clonenode=new NBranchTree(node->val);\n               \n                // debug(clonenode->val);\n                if(umap.count(node))\n                { \n                    NBranchTree* parent = umap[node];\n                    (parent->children).push_back(clonenode);\n                }\n                else\n                {\n                    head=clonenode;\n                }\n                for(auto x:node->children)\n                {\n                    umap[x]=clonenode;\n                    q.push(x);\n                }\n                \n            }\n        }\n        return head;\n    }\n};\n```\n\n","tags":["加密文章tag"],"categories":["Algorithm"]},{"title":"回溯","url":"/2024/04/16/huisu/","content":"## [2698. 求一个整数的惩罚数](https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/)\n\n```c++\nclass Solution {\npublic:\n    bool demo(int t, int i, const string& str, int target) \n    {\n        if (i >= str.size()) \n        {\n            return t == target;\n        }\n        if (t > target) \n        {\n            return false;\n        }\n        int m=str.size();\n        for (int j = 1; j <= 4; j++) \n        {\n            int k=min(j, m-i);\n            t += stoi(str.substr(i, k));\n            if (demo(t, i + k, str, target)) \n            {\n                // cout<<target<<endl;\n                return true;\n            }\n            t -= stoi(str.substr(i, k) );\n        }\n        return false;\n    }\n    int punishmentNumber(int n) \n    {\n        int res = 0;\n        for (int i = 1; i <= n; i++) \n        {\n            int t1 = i * i;\n            string str = to_string(t1);\n            if (demo(0, 0, str, i)) \n            {\n                res += i * i;\n            }\n        }\n        return res;\n    }\n};\n```\n\n## [491. 递增子序列](https://leetcode.cn/problems/non-decreasing-subsequences/)\n\n[回溯参考](https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html#思路)\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>>res;\n    vector<int>path;\n    \n    void dfs(vector<int>&nums,int sindex)\n    {\n        if(path.size() >= 2)\n            res.push_back(path);\n        if(sindex>=nums.size())return;\n        unordered_map<int,int>used;\n        for(int i=sindex;i<nums.size();i++)\n        {\n            int x=nums[i];\n            if((!path.empty()&&nums[i]<path.back())||used[x]==1)continue;\n            path.push_back(nums[i]);\n            used[x]=1;\n            dfs(nums,i+1);\n            path.pop_back();\n            // used[x]=0;\n        }\n    }\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\n        res.clear();\n        path.clear();\n        dfs(nums, 0);\n        return res;\n        \n    }\n};\n```\n\n二进制优化（官解）\n\n```c++\nclass Solution {\npublic:\n    vector<int> temp;\n    vector<vector<int>> ans;\n    unordered_set<int> s;\n    int n;\n\n    void findSubsequences(int mask, vector<int>& nums) \n    {\n        temp.clear();\n        for (int i = 0; i < n; ++i) \n        {\n            if (mask & 1) \n            {\n                temp.push_back(nums[i]);\n            }\n            mask >>= 1;\n        }\n    }\n\n    bool check() {\n        for (int i = 1; i < temp.size(); ++i) {\n            if (temp[i] < temp[i - 1]) {\n                return false;\n            }\n        }\n        return temp.size() >= 2;\n    }\n\n    int getHash(int base, int mod) {\n        int hashValue = 0;\n        for (const auto &x: temp) {\n            hashValue = 1LL * hashValue * base % mod + (x + 101);\n            hashValue %= mod;\n        }\n        return hashValue;\n    }\n\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\n        n = nums.size();\n        for (int i = 0; i < (1 << n); ++i) {\n            findSubsequences(i, nums);\n            int hashValue = getHash(263, int(1E9) + 7);\n            if (check() && s.find(hashValue) == s.end()) {\n                ans.push_back(temp);\n                s.insert(hashValue);\n            }\n        }\n        // 将set中的数据复制到vector中\n        //vector<vector<int>> result(res.begin(), res.end());\n        // copy(res.begin(), res.end(), result.begin());\n        return ans;\n    }\n};\n```\n\n\n\n## [332. 重新安排行程](https://leetcode.cn/problems/reconstruct-itinerary/)\n\n```c++\n#define debug(a) cout<<#a<<\"=\"<<a<<endl\nclass Solution {\npublic:\n    vector<string>res;\n    unordered_map<string,map<string,int >>umap;\n    int dfs(int m,string s)\n    {\n        if(res.size()==m+1)\n        {\n            return 1;\n        }\n        for(auto& x:umap[s])\n        {\n            if(x.second>0)\n            {\n                res.push_back(x.first);\n                // debug(x.first);\n                x.second--;\n                // debug(x.second);\n                // cout<<endl;\n                if(dfs(m,x.first))return 1;\n                x.second++;\n                res.pop_back();\n            }\n            \n        }\n        return 0;\n    }\n    vector<string> findItinerary(vector<vector<string>>& tickets) \n    {\n        \n        for(auto x:tickets)\n        {\n            umap[x[0]][x[1]]++;\n        }\n        res.push_back(\"JFK\");\n        dfs(tickets.size(),\"JFK\");\n        return res;\n    }\n};\n```\n\n## [679. 24 点游戏](https://leetcode.cn/problems/24-game/)\n\nhttps://leetcode.cn/problems/24-game/solutions/1/java-hui-su-jing-dian-mian-shi-ti-by-air-pj1k\n\n```c++\nconst double TARGET = 24.0;\nconst double P = 1e-6;\nconst double EPISLON =1e-6;\nclass Solution { \npublic:\n    vector<double> calculate(double a, double b) {\n        vector<double> list;\n        list.push_back(a + b);\n        list.push_back(a - b);\n        list.push_back(b - a);\n        list.push_back(a * b);\n        if (abs(b) >= EPISLON) list.push_back(a / b);\n        if (abs(a) >= EPISLON) list.push_back(b / a);\n        return list;\n    }\n        bool helper(vector<double>& nums) \n        {\n        if (nums.size() == 1) return abs(nums[0] - TARGET) < EPISLON;\n        // 每次选择两个不同的数进行回溯\n        for (int i = 0; i < nums.size(); i++) \n        {\n            for (int j = i + 1; j < nums.size(); j++) \n            {\n                // 将选择出来的两个数的计算结果和原数组剩下的数加入 next 数组\n                vector<double> next;\n                for (int k = 0; k < nums.size(); k++) \n                {\n                    if (k != i && k != j) next.push_back(nums[k]);\n                }\n                for (double num : calculate(nums[i], nums[j])) \n                {\n                    next.push_back(num);\n                    if (helper(next)) return true;\n                    next.pop_back(); // backtrack\n                }\n            }\n        }\n        return false;\n    }\n    bool judgePoint24(vector<int>& cards) \n    {\n        if (cards.empty() || cards.size() != 4) return false;\n        vector<double> nums(cards.size());\n        for (int i = 0; i < 4; i++) \n        {\n            nums[i] = (double)cards[i];\n        }\n        return helper(nums);\n    }\n};\n```\n\n输出表达式\n\n```c++\nconst double TARGET = 24.0;\nconst double P = 1e-6;\nclass Solution {\nprivate:\n    struct Pair {\n        double val;\n        string expr;\n        Pair(double v, string e) : val(v), expr(e) {}\n    };\n\npublic:\n    bool judgePoint24(vector<int>& cards) {\n        if (cards.empty() || cards.size() != 4) return false;\n        vector<double> a(4);\n        vector<string> cur, ans;\n        for (int i = 0; i < 4; ++i) {\n            a[i] = cards[i];\n            cur.push_back(to_string(cards[i]));\n        }\n        return solve(a, cur, ans);\n    }\n\nprivate:\n    bool solve(vector<double>& a, vector<string>& cur, vector<string>& ans) \n    {\n        int n = a.size();\n        if (n == 1) \n        {\n            if (abs(TARGET - a[0]) <= P) \n            {\n                ans.push_back(cur[0]);\n                // cout << \"expression=\" << ans[0] << endl;\n                return true;\n            }\n            return false;\n        }\n\n        for (int i = 0; i < n; ++i) \n        {\n            for (int j = i + 1; j < n; ++j) \n            {\n                vector<double> b(n - 1);\n                vector<string> cur2;\n                int index = 0;\n                for (int k = 0; k < n; ++k) \n                {\n                    if (k != i && k != j) \n                    {\n                        b[index++] = a[k];\n                        cur2.push_back(cur[k]);\n                    }\n                }\n                for (Pair p : compute(a, i, j, cur)) \n                {\n                    b[index] = p.val;\n                    cur2.push_back(p.expr);\n                    if (solve(b, cur2, ans)) return true;\n                    cur2.pop_back(); // backtrack reset state\n                }\n            }\n        }\n        return false;\n    }\n\n    vector<Pair> compute(vector<double>& a, int i, int j, vector<string>& cur) {\n        double x = a[i], y = a[j];\n        vector<Pair> ans;\n        ans.emplace_back(x + y,  \"(\" + cur[i] + \"+\" + cur[j] + \")\");\n        ans.emplace_back(x - y,  \"(\" + cur[i] + \"-\" + cur[j] + \")\");\n        ans.emplace_back(y - x,  \"(\" + cur[j] + \"-\" + cur[i] + \")\");\n        ans.emplace_back(x * y,   cur[i] + \"*\" + cur[j]);\n        if (y != 0) {\n            ans.emplace_back(x / y,  \"(\" + cur[i] + \"/\" + cur[j] + \")\");\n        }\n        if (x != 0) {\n            ans.emplace_back(y / x, \"(\" + cur[j] + \"/\" + cur[i] + \")\");\n        }\n        return ans;\n    }\n};\n```\n\n\n\n## 202303-3+STL\n\n```C++\n#include<bits/stdc++.h>\n#define debug(a) cout<<#a<<\"=\"<<a<<endl\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int N=1e5+10; \nconst ll INF=2E18;\nint n,m,k;\nunordered_map<int ,unordered_map<int,set<int>>>nameval;\nunordered_map<int ,set<int>>nameuser;\nset<int>user;\nset<int >atomop(string exp)\n{\n\tint p=0;\n\tset<int >ans;\n\twhile(exp[p]!=':'&&exp[p]!='~')\n\t{\n\t\tp++;\n\t}\n\tint a=stoi(exp.substr(0,p));\n\tint b=stoi(exp.substr(p+1, exp.size()));\n\tif(exp[p]==':')\n\t{\n\t\tans.insert(nameval[a][b].begin(),nameval[a][b].end());\n\t}\n\telse\n\t{\n\t\tans.insert(nameuser[a].begin(),nameuser[a].end());\n\t\tset<int >dead;\n\t\tfor(auto it:nameval[a][b])\n\t\t{\n\t\t\tans.erase(it);\n\t\t}\n\t\t\n\t}\n\treturn ans;\n}\nset<int >exprop(string exp)\n{\n\tset<int >ans;\n\tif(exp[0]>='0'&&exp[0]<='9')\n\t{\n\t\tans=atomop(exp);\n\t\treturn ans;\n\t}\n\telse if(exp[0]=='&')\n\t{\n\t\tint p=1;\n\t\tset<int>ans1,ans2;\n\t\tstack<char>br;\n\t\tbr.push('(');\n\t\twhile(!br.empty())\n\t\t{\n\t\t\tp++;\n\t\t\tif(exp[p]=='(')\n\t\t\t{\n\t\t\t\tbr.push('(');\n\t\t\t}\n\t\t\telse if(exp[p]==')')\n\t\t\t{\n\t\t\t\tbr.pop();\n\t\t\t}\n\t\t}\n\t\tans1=exprop(exp.substr(2,p-2));\n\t\tint q=p+2;\n\t\tbr.push('(');\n\t\twhile(!br.empty())\n\t\t{\n\t\t\tq++;\n\t\t\tif(exp[q]=='(')\n\t\t\t{\n\t\t\t\tbr.push('(');\n\t\t\t}\n\t\t\telse if(exp[q]==')')\n\t\t\t{\n\t\t\t\tbr.pop();\n\t\t\t}\n\t\t}\n\t\tans2=exprop(exp.substr(p+2,q-p-2));\n\t\tfor(auto it:ans1)\n\t\t{\n\t\t\tif(ans2.count(it))\n\t\t\t{\n\t\t\t\tans.insert(it);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tint p=1;\n\t\tset<int>ans1,ans2;\n\t\tstack<char>br;\n\t\tbr.push('(');\n\t\twhile(!br.empty())\n\t\t{\n\t\t\tp++;\n\t\t\tif(exp[p]=='(')\n\t\t\t{\n\t\t\t\tbr.push('(');\n\t\t\t}\n\t\t\telse if(exp[p]==')')\n\t\t\t{\n\t\t\t\tbr.pop();\n\t\t\t}\n\t\t}\n//\t\tdebug(p);\n\t\tans1=exprop(exp.substr(2,p-2));\n\t\tint q=p+2;\n\t\tbr.push('(');\n\t\twhile(!br.empty())\n\t\t{\n\t\t\tq++;\n\t\t\tif(exp[q]=='(')\n\t\t\t{\n\t\t\t\tbr.push('(');\n\t\t\t}\n\t\t\telse if(exp[q]==')')\n\t\t\t{\n\t\t\t\tbr.pop();\n\t\t\t}\n\t\t}\n//\t\tdebug(q);\n\t\tans2=exprop(exp.substr(p+2,q-p-2));\n\t\tans.insert(ans1.begin(),ans1.end());\n\t\tans.insert(ans2.begin(),ans2.end());\n\t\t\n\t}\n\treturn ans;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(NULL);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint dn=0;\n\t\tcin>>dn;\n\t\tint num=0;\n\t\tcin>>num;\n\t\tuser.insert(dn);\n\t\tfor(int j=1;j<=num;j++)\n\t\t{\n\t\t\tint attrname=0;\n\t\t\tcin>>attrname;\n\t\t\tint attrval=0;\n\t\t\tcin>>attrval;\n\t\t\tnameval[attrname][attrval].insert(dn);\n\t\t\tnameuser[attrname].insert(dn);\n\t\t}\n\t}\n\tcin>>m;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tstring exp=\"\";\n\t\tcin>>exp;\n\t\tset<int >ans;\n\t\tans=exprop(exp);\n\t\tfor(auto it:ans)\n\t\t{\n\t\t\tcout<<it<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\t\n\treturn 0;\n}\n```\n\n## 202303-5(15)\n\n```c++\n#include<bits/stdc++.h>\n#define debug(a) cout<<#a<<\"=\"<<a<<endl\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int N=2e5+10; \nconst ll INF=2E18;\nint n, m,st[N],res;\npii a[N];\nset<pii>ans;\nvoid dfs(int u)\n{\n\tif(u==m)\n\t{\n\t\tint l=0,r=0,cnt=0;\n\t\tfor (int i = 0; i <= n; i ++ )\n\t\t{\n\t\t\tif (st[i] != st[i + 1]) \n\t\t\t{\n\t\t\t\tcnt ++ ;\n\t\t\t\tif (st[i] == 0 && st[i + 1] == 1) l = i + 1; // 左端点 \n\t\t\t\tif (st[i] == 1 && st[i + 1] == 0) r = i; // 右端点 \n\t\t\t}\n\t\t} \n\t\tif(cnt==2)\n\t\t{\n\t\t\tif(!ans.count({l,r}))\n\t\t\t{\n\t\t\t\t\n\t\t\t\tans.insert({l,r});\n\t\t\t}\n\t\t}\n\n\t}\n\telse\n\t{\n\t\tdfs(u+1);\n\t\t\n\t\tvector<int>dead;\n\t\tfor(int i=a[u].first;i<=a[u].second;i++)\n\t\t{\n\t\t\tif(!st[i])\n\t\t\t\tdead.push_back(i);\n\t\t}\n\t\tfor(auto x:dead)\n\t\t{\n\t\t\tst[x]=1;\n\t\t}\n\t\tdfs(u+1);\n\t\tfor(auto x:dead)\n\t\t{\n\t\t\tst[x]=0;\n\t\t}\n\t}\n}\nint main()\n{\n    cin>>n>>m;\n    for(int i=0; i<m; i++)\n    {\n    \tcin>>a[i].first>>a[i].second;\n\t}\n\n    int res = 1e8;\n    \n    dfs(0);\n    res=ans.size();\n    printf(\"%d\\n\", res);\n    return 0;\n}\n```\n\n## 202303-4暴力（30）\n\n```c++\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\nconst int N = 65536 + 10; // 2 ^16 \n\nint n, m;\nint st[N];\n\nint trans(string str) // 16 to 10 进制 \n{\n\tint res = 0;\n\t\n\tfor (int i = 0; i <= 3; i ++ )\n\t{\n\t\tchar c = str[i];\n\t\tint num;\n\t\tif (c >= '0' && c <= '9') num = c - '0';\n\t\telse num = c - '0' - 39;\n\t\t\n\t\tres += num * pow(16, 3 - i);\n\t}\n\t\n\treturn res;\n}\n\n// 检查地址是否可用 \nbool check(int l, int r, int id)\n{\n\tint len = 0;\n\tfor (int i = l; i <= r; i ++ )\n\t{\n\t\tif (st[i] && st[i] != id) return false;\n\t\tif (st[i] == id) len ++ ;\n\t}\n\tif (len == r - l + 1) return false;\n\treturn true;\n}\n\n// 为用户分配地址 \nvoid alloc(int a, int b, int id)\n{\n\tfor (int i = a; i <= b; i ++ )\n\t\tst[i] = id;\n}\n\n// 检查 a~b 范围内的所有地址是否完整地分配给了某个用户 \nint check2(int a, int b)\n{\n\tbool flag = true;\n\tfor (int i = a; i < b; i ++ )\n\t{\n\t\tif (st[i] != st[i + 1]) flag = false;\n\t}\n\tif (flag) return st[a];\n\telse return 0;\n}\n\nint main()\n{\n\tcin >> n >> m;\n\t\n\tfor (int i = 0; i < m; i ++ )\n\t{\n\t\tint op;\n\t\tcin >> op;\n\t\t\n\t\tif (op == 1)\n\t\t{\n\t\t\tint id;\n\t\t\tstring l, r;\n\t\t\tcin >> id >> l >> r;\n\t\t\tint a = trans(l), b = trans(r);\n\t\t\t\n\t\t\tif (check(a, b, id))\n\t\t\t{\n\t\t\t\tputs(\"YES\");\n\t\t\t\talloc(a, b, id);\n\t\t\t}\n\t\t\telse puts(\"NO\");\n\t\t}\n\t\t\n\t\telse if (op == 2)\n\t\t{\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tint a = trans(str);\n\t\t\tcout << st[a] << endl;\n\t\t}\n\t\t\n\t\telse\n\t\t{\n\t\t\tstring l, r;\n\t\t\tcin >> l >> r;\n\t\t\tint a = trans(l), b = trans(r);\n\t\t\tcout << check2(a, b) << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n/*\n16 5\n1 1 0001 ffff\n2 0001 \n3 0002 ffff\n1 2 0002 ffff\n1 1 0000 ffff\n*/\n\n```\n\n## 202303-2 \n\n### 二分\n\n```c++\n#include<bits/stdc++.h>\n#define debug(a) cout<<#a<<\"=\"<<a<<endl\n#define ll long long\n\nusing namespace std;\ntypedef pair<int,int> pii;\nbool check(int x, int n, int m, int k, vector<int>& time, vector<int>& source) \n{\n    int need = 0;\n    for (int i = 0; i < n; i++) \n\t{\n        if (time[i] < x) continue;\n        need += (time[i] - x) * source[i];\n    }\n    return need <= m;\n}\n\nint main() \n{\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<int> time(n), source(n);\n    for (int i = 0; i < n; i++) \n\t{\n        cin >> time[i] >> source[i];\n    }\n    int left = k-1, right = *max_element(time.begin(), time.end())+1;\n    int ans = k;\n    while (left +1 < right) \n\t{\n        int mid = (left + right) / 2;\n        if (check(mid, n, m, k, time, source)) \n\t\t{\n            ans = mid;\n            right = mid;\n        } \n\t\telse \n\t\t{\n            left = mid ;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n### umap\n\n```c++\n#include<bits/stdc++.h>\n#define debug(a) cout<<#a<<\"=\"<<a<<endl\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int N=1e5+10; \nconst ll INF=2E18;\nint n,m,k;\nint tim[N],res[N],maxx,ans;\nunordered_map<int,int>umap;\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(NULL);\n\tcin>>n>>m>>k;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>tim[i]>>res[i];\n\t\tmaxx=max(tim[i],maxx);\n\t\tumap[tim[i]]+=res[i];\n\t} \n\tfor(int i=maxx;i>k;i--)\n\t{\n\t\tif(m>umap[i])\n\t\t{\n\t\t\tm-=umap[i];\n\t\t\tumap[i-1]+=umap[i];\n\t\t\tans=i-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n```\n\n## [79. 单词搜索](https://leetcode.cn/problems/word-search/)\n\n注意edge case\n\n1. [[\"a\"]]\n\n​\tb\n\n2. [[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"]]\n\n​\t\"BAAAAAAAAAAAAAA\"\n\n```c++\nint dir[4][2]={{0,-1},{-1,0},{0,1},{1,0}};\n#define debug(a) cout<<#a<<\"=\"<<a<<endl\nclass Solution {\npublic:\n    int dfs(vector<vector<char>>& board, string word, int u,int x,int y,vector<vector<int> >& dp)\n    {\n        int dx=0,dy=0;\n        int m=board.size();\n        int n=board[0].size();\n        if(board[x][y]!=word[u])\n        {\n            return false;\n        }\n        if(u==word.size()-1)\n        {\n            return true;\n        }\n\t\tif(x>=m||y>=n||x<0||y<0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n        // if(u==word.size()-1&&board[x][y]==word[u])return true;//防止只有一个格子\n        for(int i=0;i<4;i++)\n        {\n            dx=x+dir[i][0];\n            dy=y+dir[i][1];\n            \n            if(dx>=0&&dx<m&&dy>=0&&dy<n&&!dp[dx][dy]&&board[dx][dy]==word[u+1])\n            {\n                dp[dx][dy]=1;\n                if(dfs(board,word,u+1,dx,dy,dp))return true;\n                dp[dx][dy]=0;\n            }\n        }\n        return false;\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n        int m=board.size();\n        int n=board[0].size();\n        vector<vector<int>> dp(m,vector<int>(n,0));\n        for(int i=0;i<m;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                dp[i][j]=1;\n                if(dfs(board,word,0,i,j,dp))\n                    return true;\n                dp[i][j]=0;\n            }\n        }\n        return false;\n    }\n};\n```\n\n## [212. 单词搜索 II](https://leetcode.cn/problems/word-search-ii/)\n\n### Trie+dfs\n\nhttps://leetcode.cn/problems/word-search-ii/solutions/1000331/gong-shui-san-xie-yi-ti-shuang-jie-hui-s-am8f\nisend变成存整个word\n代码参考评论第三页\n\n```c++\nint dir[4][2]={{0,-1},{-1,0},{0,1},{1,0}};\nclass Trie {\nprivate:\n    \npublic:\n    Trie* son[26];\n    string s;\n    Trie() {\n\n        for(int i=0;i<26;i++)son[i]=nullptr;\n    }\n    //c++安全性\n    ~Trie()\n    {\n        for(int i = 0; i < 26 ; i++)\n        {\n            if(son[i] != nullptr) delete son[i];\n        }\n    }\n    void insert(string word) {\n        Trie* root=this;\n        for(int i=0;i<word.size();i++)\n        {\n            int u=word[i]-'a';\n            if(root->son[u]==nullptr)root->son[u]= new Trie();\n           root=root->son[u];\n        }\n        root->s=word;\n    }\n    \n};\nclass Solution {\npublic:\n    unordered_map<string, int> mp;\n    // vector<string>ans;\n    unordered_set<string> ans;\n    Trie* root=new Trie();\n    int dp[13][13] = {0};\n    void dfs(vector<vector<char>>& board, Trie * node, int x,int y)\n    {\n        int dx=0,dy=0;\n        int m=board.size();\n        int n=board[0].size();\n        if(node->s!= \"\"){\n            ans.insert(node->s);\n        }\n\t\tif(x>=m||y>=n||x<0||y<0)\n\t\t{\n\t\t\treturn;\n\t\t}\n        // if(u==word.size()-1&&board[x][y]==word[u])return true;//防止只有一个格子\n        for(int i=0;i<4;i++)\n        {\n            dx=x+dir[i][0];\n            dy=y+dir[i][1];\n            \n            if(dx>=0&&dx<m&&dy>=0&&dy<n&&!dp[dx][dy])\n            {\n                int u=board[dx][dy]-'a';\n                if(node->son[u])\n                {\n                    dp[dx][dy]=1;\n                    \n                    dfs(board,node->son[u],dx,dy);\n                    dp[dx][dy]=0;\n                }\n                \n                \n            }\n        }\n\n    }\n\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\n        int m=board.size();\n        int n=board[0].size();\n\n        for(auto w:words)root->insert(w);\n        \n        for(int i=0;i<m;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                int u=board[i][j]-'a';\n                if(root->son[u])\n                {\n                    dp[i][j]=1;\n                \n                    dfs(board,root->son[u],i,j);\n                    \n                    dp[i][j]=0;\n                }\n                \n               \n            }\n        }\n        return vector<string>(ans.begin(), ans.end());\n    }\n};\n```\n\n## [78. 子集](https://leetcode.cn/problems/subsets/)\n\n### dfs\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>>res;\n    vector<int> path;\n    void dfs(vector<int>& nums,int sindex)\n    {\n        res.push_back(path);\n        int n=nums.size();\n        if(path.size()==n)return;\n        for(int i=sindex;i<n;i++)\n        {\n            path.push_back(nums[i]);\n            dfs(nums,i+1);\n            path.pop_back();\n        }\n    }\n    vector<vector<int>> subsets(vector<int>& nums) {\n        dfs(nums,0);\n        return res;\n    }\n};\n```\n\n### 位运算\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>>res;\n    vector<int> path;\n    \n    vector<vector<int>> subsets(vector<int>& nums) {\n        res.clear();\n        int n=nums.size();\n        for(int m=0;m<(1<<n);m++)\n        {\n            path.clear();\n            for(int j=0;j<n;j++)\n            {\n                if(m&(1<<j))\n                {\n                    path.push_back(nums[j]);\n                } \n            }\n           \n            res.push_back(path);\n        }\n        return res;\n    }\n};\n```\n\n## [90. 子集 II](https://leetcode.cn/problems/subsets-ii/)\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>>res;\n    vector<int> path;\n    void dfs(vector<int>& nums,int sindex)\n    {\n        res.push_back(path);\n        int n=nums.size();\n        if(path.size()==n)return;\n        for(int i=sindex;i<n;i++)\n        {\n            if(i>sindex&&nums[i]==nums[i-1])continue;\n            path.push_back(nums[i]);\n            dfs(nums,i+1);\n            path.pop_back();\n        }\n    }\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        dfs(nums,0);\n        return res;\n    }\n};\n```\n\n\n\n## [39. 组合总和](https://leetcode.cn/problems/combination-sum/)\n\nint sum,int target\n\n主要是参数\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>>res;\n    vector<int>path;\n    void dfs(vector<int>& candidates,int sindex,int sum,int target)\n    {\n        if(sum==target)\n        {\n            res.push_back(path);\n            return;\n        }\n        if(sum>target)return;\n        int n=candidates.size();\n        for(int i=sindex;i<n;i++)\n        {\n            sum+=candidates[i];\n            path.push_back(candidates[i]);\n            dfs(candidates,i,sum,target);\n            sum -= candidates[i];\n            path.pop_back();\n        }\n    }\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        dfs(candidates,0,0,target);\n        return res;\n    }\n};\n```\n\n## [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>>res;\n    vector<int> path;\n    void dfs(vector<int>& candidates,int sindex,int sum,int target)\n    {\n        if(sum==target)\n        {\n            res.push_back(path);\n            return;\n        }\n        if(sum>target)return;\n        int n=candidates.size();\n        for(int i=sindex;i<n&&sum + candidates[i] <= target;i++)//这里还有个剪枝\n        {\n            // 剪枝四：如果该元素与左边元素相等，说明该搜索分支重复，直接跳过\n            if (i > sindex && candidates[i] == candidates[i - 1]) {\n                continue;\n            }\n            sum+=candidates[i];\n            path.push_back(candidates[i]);\n            dfs(candidates,i+1,sum,target);\n            sum -= candidates[i];\n            path.pop_back();\n        }\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end());\n        dfs(candidates,0,0,target);\n        return res;\n    }\n};\n```\n\n## [216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>>res;\n    vector<int> path;\n    void dfs(int sindex,int sum,int target,int k)\n    {\n        if(sum==target&&path.size()==k)\n        {\n            res.push_back(path);\n            return;\n        }\n        if(path.size()==k)return;\n        if(sum>target)return;\n        for(int i=sindex;i<=9;i++)\n        {\n            \n            sum+=i;\n            path.push_back(i);\n            dfs(i+1,sum,target,k);\n            sum -= i;\n            path.pop_back();\n        }\n    }\n    vector<vector<int>> combinationSum3(int k, int n) {\n        dfs(1,0,n,k);\n        return res;\n    }\n};\n```\n\n\n\n## [LCR 083. 全排列](https://leetcode.cn/problems/VvJkup/)\n\n[46. 全排列](https://leetcode.cn/problems/permutations/)\n\nused数组\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>>res;\n    vector<int>path;\n    vector<int>used;\n    void dfs(vector<int>& nums)\n    {\n        if(path.size()==nums.size())\n        {\n            res.push_back(path);\n            return;\n        }\n        for(int i=0;i<nums.size();i++)\n        {\n            if(used[i])continue;\n            path.push_back(nums[i]);\n            used[i]=1;\n            dfs(nums);\n            path.pop_back();\n            used[i]=0;\n        }\n    }\n    vector<vector<int>> permute(vector<int>& nums) {\n        used.resize(nums.size());\n        dfs(nums);\n        return res;\n    }\n};\n```\n\n\n\n## [47. 全排列 II](https://leetcode.cn/problems/permutations-ii/)\n\n### [LCR 157. 套餐内商品的排列顺序](https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/)\n\n### [784. 字母大小写全排列](https://leetcode.cn/problems/letter-case-permutation/)\n\n加了去重和sort\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>>res;\n    vector<int>path;\n    vector<int>used;\n    void dfs(vector<int>& nums)\n    {\n        if(path.size()==nums.size())\n        {\n            res.push_back(path);\n            return;\n        }\n        for(int i=0;i<nums.size();i++)\n        {\n            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == 0) {\n                continue;\n            }\n            if(used[i])continue;\n            path.push_back(nums[i]);\n            used[i]=1;\n            dfs(nums);\n            path.pop_back();\n            used[i]=0;\n        }\n    }\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        used.resize(nums.size());\n        dfs(nums);\n        return res;\n    }\n};\n```\n\n\n\n## 排列，组合，子集总结\n\n组合：startindex维持顺序\n\n组合总和：判断`sum==target`返回\n\n排列：used数组\n\n子集：每一种可能都返回，和组合差不多\n\n三种去重都差不多\n\n## [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)\n\n多了个映射\n\n```c++\nclass Solution {\n    vector<string>res;\n    string path;\n    const string umap[10]{\n        \"\",\"\",\n        \"abc\",\n        \"def\",\n        \"ghi\",\n        \"jkl\",\n        \"mno\",\n        \"pqrs\",\n        \"tuv\",\n        \"wxyz\"\n    };\n\npublic:\n    void dfs(string digits,int index)\n    {\n        if(index==digits.size())\n        {\n            res.push_back(path);\n            return;\n        }\n        string letter=umap[digits[index]-'0'];\n        for(auto x:letter)\n        {\n            path+=x;\n            dfs(digits,index+1);\n            path.pop_back(); \n        }\n    }\n    vector<string> letterCombinations(string digits) {\n        res.clear();\n        if(digits.size()==0)\n        {\n            \n            return res;\n        }\n        dfs(digits,0);\n        return res;\n    }\n};\n```\n\n## [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)\n\n### dfs\n\n剪枝\n返回\n中间运算\n\n```c++\nclass Solution {\npublic:\n    vector<string>res;\n    string path;\n    void dfs(int l,int r,int n)\n    {\n        if(l>n||l<r)return;//剪枝\n        if(path.size()==n*2)\n        {\n            res.push_back(path);\n            return;\n        }\n        for(int i=0;i<2;i++)\n        {\n            if(!i)\n            {\n                path+='(';\n                dfs(l+1,r,n);\n                path.pop_back();\n            }\n            else\n            {\n                path+=')';\n                dfs(l,r+1,n);\n                path.pop_back();\n            }\n        }\n\n    }\n    vector<string> generateParenthesis(int n) {\n        dfs(0,0,n);\n        return res;\n    }\n};\n```\n\n### 迭代（dp？）\n\n注意复杂度\n\n```c++\nclass Solution {\npublic:\n    vector<vector<string>>dp={{\"\"},{\"()\"}};\n    vector<string> generateParenthesis(int n) {\n        for(int i=2;i<=n;i++)\n        {\n            dp.push_back({});\n            for(int a=0;a<i;a++)\n            {\n                int b=i-a-1;\n                for(auto dpa:dp[a])\n                {\n                    for(auto dpb:dp[b])\n                    {\n                        dp[i].push_back('('+dpa+')'+dpb);\n                    }\n                }\n            }\n\n        }\n        return dp[n];\n    }\n};\n```\n\n\n\n## [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)（可纯dfs or dp优化）\n\n### 纯dfs\n\nsindex作为分割线\ns.substr(sindex,i-sindex+1) 放入路径\ni+1为下次的分割线\n\n```c++\nclass Solution {\npublic:\n    vector<vector<string>>res;\n    vector<string>path;\n    int isp(string s, int l,int r)\n    {\n        while(l<r)\n        {\n            if(s[l]!=s[r])\n            {\n                return 0;\n            }\n            l++;\n            r--;\n        }\n        return true;\n    }\n    void dfs(string s,int sindex)\n    {\n        \n        int n=s.size();\n        if(sindex>=n)\n        {\n            res.push_back(path);\n            return ;\n        }\n        for(int i=sindex;i<n;i++)\n        {\n            if(isp(s,sindex,i))\n            {\n                path.push_back(s.substr(sindex,i-sindex+1));\n                dfs(s,i+1);\n                path.pop_back();\n            }\n        }\n    }\n    vector<vector<string>> partition(string s) {\n        dfs(s,0);\n        return res;\n    }\n};\n```\n\n### dp优化\n\ndp存的是i到j这段是不是回文串\n\n## [93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)\n\n### 一些string api\n\n```c++\nclass Solution {\npublic:\n    vector<string>res;\n\n    int isvalid(string s, int l, int r)\n    {\n        // 遇到非数字字符不合法,0要特殊处理\n        string str=s.substr(l, r-l+1);\n        if(r<l)return 0;\n        if(s[l]=='0'&&l!=r)return 0;\n        for(auto num:str)\n        {\n            if(num<'0'||num>'9')return 0;\n        }\n        int num=stoi(str);\n        if(num>255)return 0;\n        return 1;\n    }\n    void dfs(string s,int sindex,int point)\n    {\n        \n        int n=s.size();\n        if(point==3)\n        {\n            if(isvalid(s,sindex,n-1))\n            {\n                res.push_back(s);\n            }\n            return;\n        }\n        for(int i=sindex;i<n;i++)\n        {\n            if(isvalid(s,sindex,i))\n            {\n               s.insert(s.begin()+i+1,'.');\n               point++;\n               dfs(s,i+2,point);\n               s.erase(s.begin()+i+1);\n               point--;\n            }\n            else break;//注意结束\n        }\n    }\n    vector<string> restoreIpAddresses(string s) {\n        if(s.size()>12||s.size()<4)return res;\n        dfs(s,0,0);\n        return res;\n    }\n};\n```\n\n## 分割总结\n\n131和93差不多，注意ip要i+2，且这层不符合直接break的剪枝\n\n## [306. 累加数](https://leetcode.cn/problems/additive-number/)\n\n### dfs+高精度\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>>list;\n    //高精度+\n    int check(vector<int>&a,vector<int>&b,vector<int>&c)\n    {\n        vector<int>sum;\n        int carry=0;\n        for(int i=0;i<a.size()||i<b.size();i++)\n        {\n            if(i<a.size())carry+=a[i];\n            if(i<b.size())carry+=b[i];\n            sum.push_back(carry%10);\n            carry/=10;\n        }\n        if(carry)sum.push_back(1);\n        if(sum.size()!=c.size())\n        {\n            return 0;\n        }\n        for(int i=0;i<sum.size();i++)\n        {\n            if(sum[i]!=c[i])return 0;\n        }\n        return 1;\n    }\n    int dfs(int sindex,string num)\n    {\n        if(sindex>=num.size())\n        {\n            if(list.size()>=3)\n            {\n                return 1;\n            }\n            return 0;\n        }\n        //特殊处理0，只能有一个划分\n        int n=num.size();\n        if(num[sindex]=='0')\n        {\n            n=sindex+1;\n        }\n        vector<int >cur;\n        for(int i=sindex;i<n;i++)\n        {\n            cur.insert(cur.begin(),num[i]-'0');//高精度是倒着算的\n            if(list.size()<2||check(list[list.size()-1],list[list.size()-2],cur))\n            {\n                list.push_back(cur);\n                if(dfs(i+1,num))return 1;\n                list.pop_back();\n            }\n        }\n        return 0;\n    }\n    bool isAdditiveNumber(string num) {\n        return dfs(0,num);\n    }\n};\n```\n\n","tags":["加密文章tag"],"categories":["Algorithm"]},{"title":"搜索","url":"/2024/04/16/搜索/","content":"\n## flood fill\n\n### [1097. 池塘计数（poj2386）](https://www.acwing.com/problem/content/description/1099/)\n\n```c++\n//\n// Created by wyh on 2023/7/18.\n//\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<string.h>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1010;\nint dir[8][2]={{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{1,1},{-1,1},{1,-1}};\nchar g[maxn][maxn];\nint ans=0;\nint n=0,m=0;\nvoid dfs(int x,int y)\n{\n    int dx=0,dy=0;\n    for(int i=0;i<8;i++)\n    {\n        dx=x+dir[i][0];\n        dy=y+dir[i][1];\n        if(dx>=0&&dx<n&&dy>=0&&dy<m&&g[dx][dy]=='W')\n        {\n            g[dx][dy]='.';\n            dfs(dx,dy);\n        }\n    }\n\n}\nint main()\n{\n    cin>>n>>m;\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<m;j++)\n        {\n            cin>>g[i][j];\n        }\n    }\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<m;j++)\n        {\n            if(g[i][j]=='W')\n            {\n                dfs(i,j);\n                ans++;\n            }\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n\n```\n\n### [1098.城堡计数](https://www.acwing.com/problem/content/1100/)\n\n#### dfs\n\n```c++\n// 注意需要dfs返回，不能参数计算不然可能漏方向//\n\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<string.h>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1010;\nint dir[4][2]={{0,-1},{-1,0},{0,1},{1,0}};\nint g[maxn][maxn],d[maxn][maxn][4],st[maxn][maxn];\nint ans=0,room=0;\nint n=0,m=0;\nint dfs(int x,int y)\n{\n    int dx=0,dy=0;\n    int cnt=1;\n    for(int i=0;i<4;i++)\n    {\n        dx=x+dir[i][0];\n        dy=y+dir[i][1];\n        if(dx>=0&&dx<n&&dy>=0&&dy<m&&!d[x][y][i]&&!st[dx][dy])\n        {\n\n            st[dx][dy]=1;\n            cnt+=dfs(dx,dy);\n        }\n    }\n    return cnt;\n\n}\nint main()\n{\n    cin>>n>>m;\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<m;j++)\n        {\n            cin>>g[i][j];\n            for(int k=0;k<4;k++)\n            {\n                if(g[i][j]>>k&1)\n                {\n                    d[i][j][k]=1;\n                }\n            }\n        }\n    }\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<m;j++)\n        {\n\n            if(st[i][j])continue;\n            st[i][j]=1;\n            room++;\n            ans=max(ans,dfs(i,j));\n\n        }\n    }\n    cout<<room<<endl;\n    cout<<ans<<endl;\n    return 0;\n}\n\n```\n\n#### bfs\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int INF=100086;\nint e[INF],a[INF],ne[INF],h[INF],q[INF],idx,n,m; \nint  g[60][60],d[60][60];\ntypedef pair<int,int >PII;\nint space,ans;\nint dir[5][3]={{0,-1},{-1,0},{0,1},{1,0}};\nvoid bfs(int x,int y)\n{\n\tqueue<PII>q;\n\tint space1=0;\n\td[x][y]=1;\n\tq.push({x,y});\n\tint dx=0,dy=0;\n\t//cout<<x<<\",\"<<y<<endl;\n\twhile(q.size()>0)\n\t{\n\t\tauto t=q.front();\n\t\tq.pop();\n\t\tint x = t.first, y = t.second ;\n\t\tspace1++;\n\t\tfor(int i=0;i<4;i++)\n\t\t{//cout<<g[x][y]<<\" \"<<(g[x][y]>>i&1)<<endl;\n\t\t    if(!(g[x][y]>>i&1))\n\t\t    {\n\t\t\t    dx=t.first+dir[i][0];\n        \t    dy=t.second+dir[i][1];\n        \t    \n        \t    if(dx>=0&&dx<n&&dy>=0&&dy<m&&!d[dx][dy])\n        \t    {\n        \t\t   // cout<<\" \"<<dx<<\", \"<<dy<<endl;\n        \t\t    d[dx][dy]=1;\n        \t    //\tpprev[dx][dy]=t;\n        \t\t    q.push({dx,dy});\n        \t\t    \n\t\t\t    }\n\t\t    }\n\t\t}\n\t\t\n\t}\n\tspace=max(space,space1);\n\treturn ;\n\t\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\tcin>>n>>m;\n\n\t//memset(d,-1,sizeof(d));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tcin>>g[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tif(!d[i][j])\n\t\t\t{\n\t\t\t\tbfs(i,j);\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\tcout<<space<<endl;\n\treturn 0;\t\n}\n```\n\n### [1106. 山峰和山谷(poi2007)](https://www.acwing.com/problem/content/description/1108/)\n\n#### dfs\n\n```c++\n//\n// Created by wyh on 2023/7/18.\n//\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<string.h>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1010;\nconst int N = 1E3 + 10;\nint g[N][N];\nint vis[N][N];\nint n;\nint isp, isv;\nint dir[8][2]={{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{1,1},{-1,1},{1,-1}};\nvoid dfs(int x, int y)\n{\n    for(int i = 0; i < 8; i ++ )\n    {\n        int dx = x + dir[i][0], dy = y + dir[i][1];\n        if(!(dx>=0&&dx<n&&dy>=0&&dy<n))  continue;\n        if(g[dx][dy] > g[x][y]) isp = 0;\n        else if(g[dx][dy] < g[x][y])    isv = 0;\n        else if(g[dx][dy] == g[x][y]&&vis[dx][dy] == 0)\n        {\n\n            vis[dx][dy] = 1;\n            dfs(dx, dy);\n        }\n    }\n}\nint main()\n{\n    cin >> n;\n    for(int i = 0; i < n; i ++ )\n    {\n        for(int j = 0; j < n; j ++ )\n        {\n            cin >> g[i][j];\n        }\n\n    }\n    int peak = 0, valley = 0;\n    for(int i = 0; i < n; i ++ )\n    {\n        for(int j = 0; j < n; j ++ )\n        {\n            if(vis[i][j])   continue;\n            isp = 1, isv = 1;\n            vis[i][j] = 1;\n            dfs(i, j);\n            if(isp)peak++;\n            if(isv)valley++;\n//            peak += isp;\n//            valley += isv;\n        }\n    }\n    cout << peak << ' ' << valley << endl;\n    return 0;\n}\n\n```\n\n#### bfs\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int INF=1010;\nint d[INF][INF],n,m,ans; \nint g[INF][INF];\ntypedef pair<int,int >PII;\nPII pprev[INF][INF];\nint dir[10][3]={{0,0},{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},\n    {0, 1}, {1, -1}, {1, 0}, {1, 1}};\nvoid bfs(int x,int y,int& isp,int& isv)\n{\n\tint dx=0,dy=0;\n\t//cout<<x<<\",\"<<y<<endl;\n\tqueue<PII >q;\n\tq.push({x,y});\n\td[x][y]=1;\n\twhile(q.size())\n\t{\n\t\tauto t=q.front();\n\t\tq.pop();\n\t\tfor(int i=1;i<=8;i++)\n\t\t{\n\t\t\tdx=t.first+dir[i][0];\n        \tdy=t.second+dir[i][1];\n\t\t\tif(!(dx>=0&&dx<n&&dy>=0&&dy<n))continue;\n\t\t\t\n        \tif(g[dx][dy]==g[t.first][t.second]&&!d[dx][dy])\n        \t{\n        \t\t//cout<<\" \"<<dx<<\", \"<<dy<<endl;\n        \t\t//\tpprev[dx][dy]=t;\n        \t\tq.push({dx,dy});\n\t\t\t\td[dx][dy]=1;\n\t\t\t}\t\n\t\t\tif(g[dx][dy]>g[t.first][t.second])\n\t\t\t{\n\t\t\t\tisp=0;\n\t\t\t\t//d[dx][dy]=1;\n\t\t\t\t//cout<<\" isp\"<<dx<<\",\"<<dy<<endl;\n\t\t\t}\n\t\t\tif(g[dx][dy]<g[t.first][t.second])\n\t\t\t{\n\t\t\t\tisv=0;\n\t\t\t\t//d[dx][dy]=1;\n\t\t\t\t//cout<<\" isv\"<<dx<<\",\"<<dy<<endl;\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n    \tfor(int j=0;j<n;j++)\n    \t\tcin>>g[i][j];\n\tint peak=0,valley=0;\n    for(int i=0;i<n;i++)\n    {\n    \tfor(int j=0;j<n;j++)\n    \t{\n    \t\tif(d[i][j])continue;\n    \t\tint isp=1,isv=1;\n    \t\tbfs(i,j,isp,isv);\n    \t\tif(isp)peak++;\n    \t\tif(isv)valley++;\n\t\t}\n\t}    \t\t\n    \n\tcout << peak << \" \" << valley << endl;\n\t \n\treturn 0;\t\n}\n\n```\n\n## 最短路模型\n\n### [188. 武士风度的牛](https://www.acwing.com/problem/content/190/)\n\n```c++\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<string.h>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int>pii;\nconst int N=1010;\nint dir[8][2]={{1,2},{2,1},{-1,-2},{-2,-1},{1,-2},{2,-1},{-1,2},{-2,1} };\nchar g[N][N];\nint dis[N][N];\nint endx,endy,n,m,ans,sx,sy;\nvoid bfs(int x,int y)\n{\n\tint dx=0,dy=0;\n\tqueue<pii>q;\n\tq.push({x,y});\n\tdis[x][y]=1;\n\twhile(q.size())\n\t{\n\t\tauto t=q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<8;i++)\n\t\t{\n\t\t\tint dx=t.first+dir[i][0];\n\t\t\tint dy=t.second+dir[i][1];\n\t\t\tif(!(dx>=0&&dx<n&&dy>=0&&dy<m))continue;\n\t\t\tif(g[dx][dy]=='*')continue;\n//\t\t\tcout<<dx<<\",\"<<dy<<endl;\n\t\t\tif(dis[dx][dy]!=0)continue;\n\t\t\tdis[dx][dy]=dis[t.first][t.second]+1;\n\t\t\tq.push({dx,dy});\n//\t\t\tcout<<dis[dx][dy]<<endl;\n\t\t\tif(dx==endx&&dy==endy)\n\t\t\t{\n\t\t\t\tans=dis[dx][dy];\n\t\t\t\treturn ;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n    cin>>m>>n;\n    for(int i=0;i<n;i++)\n    {\n    \tfor(int j=0;j<m;j++)\n    \t{\n    \t\tcin>>g[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n    {\n    \tfor(int j=0;j<m;j++)\n    \t{\n    \t\tif(g[i][j]=='K')\n    \t\t{\n    \t\t\tsx=i,sy=j;\n//    \t\t\tcout<<sx<<\",   \"<<sy<<endl;\n//    \t\t\tbreak;\n\t\t\t}\n\t\t\telse if(g[i][j]=='H')\n    \t\t{\n    \t\t\tendx=i;\n    \t\t\tendy=j;\n\t\t\t}\n\t\t}\n\t}\n\tbfs(sx,sy);\n//\tcout<<sx<<\",   \"<<sy<<endl;\n\tcout<<ans-1<<endl;\n    return 0;\n}\n```\n\n### [1100. 抓住那头牛](https://www.acwing.com/problem/content/1102/)\n\n```c++\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nint n,m,k;\nint a[100086];\nint b[100086];\nint zhuan(int i,int x)\n{\n\tif(i==0)return x-1;\n\tif(i==1)return x+1;\n\tif(i==2)return 2*x;\n}\nint bfs()\n{\n\tqueue<int >q;\n//\tunordered_map<string,int >d;\n\tq.push(n);\n\tb[n]=0;\n\ta[n]=1;\n\twhile(q.size())\n\t{\n\t\tint t=q.front();\n\t\tq.pop();\n\t\tif(t==k)return b[k];\n\t\tfor(int i=0;i<3;i++)\n\t\t{\n\t\t\tint xx=zhuan(i,t);\n\t\t\t\n\t\t\tif(xx>=0&&xx<=100000&&!a[xx])\n\t\t\t{\n\t\t\t\tq.push(xx);\n\t\t\t\ta[xx]=1;\n\t\t\t\tb[xx]=b[t]+1;\n\t\t\t}\n//\t\t\tcout<<xx<<','<<yy<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n\tcin>>n>>k;\n\tcout<<bfs()<<endl;\n\treturn 0;\t\n}\n```\n\n## *多源bfs*\n\n### [173. 矩阵距离](https://www.acwing.com/problem/content/description/175/)\n\n```c++\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<string.h>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int>pii;\nconst int N=1010;\nint dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nchar g[N][N];\nint dis[N][N];\nint endx,endy,n,m,ans,sx,sy;\nvoid bfs()\n{\n\tint dx=0,dy=0;\n\tqueue<pii>q;\n\tfor(int x=0;x<n;x++)\n\t{\n\t\tfor(int y=0;y<m;y++)\n\t\t{\n\t\t\tif(g[x][y]=='1')\n\t\t\t{\n\t\t\t\tq.push({x,y});\n\t\t\t\tdis[x][y]=1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\twhile(q.size())\n\t{\n\t\tauto t=q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tint dx=t.first+dir[i][0];\n\t\t\tint dy=t.second+dir[i][1];\n\t\t\tif(!(dx>=0&&dx<n&&dy>=0&&dy<m))continue;\n\t\t\tif(g[dx][dy]=='1')continue;\n//\t\t\tcout<<dx<<\",\"<<dy<<endl;\n\t\t\tif(dis[dx][dy]!=0)continue;\n\t\t\tdis[dx][dy]=dis[t.first][t.second]+1;\n\t\t\tq.push({dx,dy});\n//\t\t\tcout<<dis[dx][dy]<<endl;\n\t\t\t\n\t\t}\n\t}\n}\n\nint main()\n{\n    cin>>n>>m;\n    for(int i=0;i<n;i++)\n    {\n    \tfor(int j=0;j<m;j++)\n    \t{\n    \t\tcin>>g[i][j];\n\t\t}\n\t}\n\t\n\tbfs();\n//\tcout<<sx<<\",   \"<<sy<<endl;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<m;j++)\n    \t{\n    \t\tcout<<dis[i][j]-1<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n    return 0;\n}\n```\n\n## *最小步数模型*\n\n### [1107. 魔板](https://www.acwing.com/problem/content/1109/)\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int INF=110;\nint d[INF][INF],n,m; \nint g[INF][INF];\ntypedef pair<int,int >PII;\nPII pprev[INF][INF];\nunordered_map< string, int >dist;\nunordered_map<string, pair<char, string > >ppre;\nstring move0(string t)\n{\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tswap(t[i],t[7-i]);\n\t}\n\treturn t;\n}\nstring move1(string t)\n{\n\tfor(int i=0;i<3;i++) swap(t[3],t[i]);\n    for(int i=4;i<7;i++) swap(t[i],t[i+1]);\n    return t;\n}\nstring move2(string t)\n{\n\tswap(t[1],t[2]),swap(t[5],t[6]),swap(t[1],t[5]);\n    return t;\n}\nvoid bfs(string start,string end)\n{\n\t//cout<<start<<endl;\n\t//cout<<end<<endl;\n\tqueue<string>q;\n\t\n\tq.push(start);\n\tdist[start]=0;\n\t\n\twhile(q.size()>0)\n\t{\n\t\tauto t=q.front();\n\t\tq.pop();\n\t\tif(t==end)break;\n\t\tstring m[3];\n\t\tm[0]=move0(t);\n\t\tm[1]=move1(t);\n\t\tm[2]=move2(t);\n\t\tfor(int i=0;i<3;i++)\n\t\t{\n\t\t\tstring dm=m[i];\n\t\t\t\n        \tif(dist.count(dm)==0)\n        \t{\n        \t\tdist[dm]=dist[t]+1;\n        \t\tppre[dm]={char(i+'A'),t};\n        \t\tif(dm==end)break;\n        \t\tq.push(dm);\n        \t//\tcout<<dm<<endl;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tcout<<dist[end]<<endl;\n\tstring res;\n\tif(!dist[end])return;\n\twhile(end!=start)\n\t{\n\t\tres+=ppre[end].first;\n\t\tend=ppre[end].second;\n\t}\n\treverse(res.begin(),res.end());\n\tcout<<res<<endl;\n\treturn ;\n\t\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int x=0;\n\tstring start,end;\n\tfor(int i=0;i<8;i++)\n\t{\n\t\tcin>>x;\n\t\tend+=char(x+'0'); \n\t}\n\tfor(int i=0;i<8;i++)\n\t{\n\t\tstart+=char(i+'1');\n\t}\n\tbfs(start,end);\n\t\n\treturn 0;\t\n}\n\n```\n\n## *双端队列广搜*\n\n### [175. 电路维修](https://www.acwing.com/problem/content/177/)\n\nhttps://www.acwing.com/solution/content/21775/\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int INF=510;\nint d[INF][INF],st[INF][INF],n,m; \nchar g[INF][INF];\ntypedef pair<int,int >PII;\nPII pprev[INF][INF];\nint dir[5][3]={{-1,-1},{-1,1},{1,1},{1,-1}};\nint ixy[5][3]={{-1,-1},{-1,0},{0,0},{0,-1}};\n\nint bfs()\n{\n\t\n\tdeque<PII>q;\n\tmemset(d,0x3f,sizeof(d));\n\tmemset(st,0,sizeof(st));\n\tq.push_front({0,0});\n\tchar ch[5]=\"\\\\/\\\\/\";\n\t\n\td[0][0]=0;\n\t\n\twhile(q.size()>0)\n\t{\n\t\tauto t=q.front();\n\t\tq.pop_front();\n\t\tint a=t.first,b=t.second;\n\t\tif(a==n&&b==m)\n\t\t{\n\t\t\treturn d[n][m];\n\t\t}\n\t\tif(st[a][b])continue;\n\t\tst[a][b]=1;\n\t\tfor(int i=0;i<=3;i++)\n\t\t{\n\t\t\tint dx=a+dir[i][0];\n\t\t\tint dy=b+dir[i][1];\n\t\t\tif(dx<0||dx>n||dy<0||dy>m)continue;\n\t\t\tint w=0;\n\t\t\tint cx=a+ixy[i][0];\n\t\t\tint cy=b+ixy[i][1];\n\t\t\tif(g[cx][cy]!=ch[i])\n\t\t\t{\n\t\t\t\tw=1;\n\t\t\t}\n\t\t\tint dw=d[a][b]+w;\n        \tif(dw<d[dx][dy])\n        \t{\n        \t\td[dx][dy]=dw;\n\n        \t    if(w)q.push_back({dx,dy});\n        \t    else q.push_front({dx,dy});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n\t\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t=0;\n    cin>>t;\n    while(t--)\n    {\n    \tcin>>n>>m;\n    \tfor(int i=0;i<n;i++)\n    \t{\n    \t\tfor(int j=0;j<m;j++)\n    \t\t{\n    \t\t\tcin>>g[i][j];\n\t\t\t}\n\t\t}\n\t\tif((n+m)&1)cout<<\"NO SOLUTION\"<<endl;\n\t\telse\n\t\t{\n\t\t\tcout<<bfs()<<endl;\n\t\t}\n\t}\n\t\n\t\n\treturn 0;\t\n}\n\n```\n\n## *双向BFS*\n\n### [190. 字串变换](https://www.acwing.com/problem/content/192/)\n\nhttps://www.acwing.com/solution/content/61327/\n\n```C++\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<string.h>\n#include<cmath>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\ntypedef pair<int,int>pii;\nconst int N=7;\nstring a[N],b[N],sa,sb;\nunordered_map<string,int> qa,qb;\nqueue<string> q1,q2;\nint n,t;\nint extend(queue<string> &q,unordered_map<string,int> &qa,unordered_map<string,int> &qb,string a[],string b[])\n{\n    string t=q.front();\n    q.pop();\n\n    for(int i=0;i<t.size();i++)\n    {\n        for(int j=0;j<n;j++)\n        {\n            if(t.substr(i,a[j].size())==a[j])\n            {\n                string nw=t.substr(0,i)+b[j]+t.substr(i+a[j].size());\n\n                if(qb.count(nw)) return qa[t]+1+qb[nw];\n                if(qa.count(nw)) continue;\n\n                q.push(nw);\n                qa[nw]=qa[t]+1;\n            }\n        }\n    }\n    return 11;\n}\nint bfs(string sa,string sb)\n{\n\tint t=0;\n\tif(sa==sb)return 0;\n\tqa[sa]=0;\n\tq1.push(sa);\n\tqb[sb]=0;\n\tq2.push(sb);\n\twhile(q1.size()&&q2.size())\n\t{\n\t\tif(q1.size()<q2.size())t=extend(q1,qa,qb,a,b);\n\t\telse t=extend(q2,qb,qa,b,a);\n\t\tif(t<=10 )return t;\n\t}\n\treturn 11;\n\t\n}\n\nint main()\n{\n\tcin>>sa>>sb;\n    if(sa == sb)\n\t{\n\t    cout << 0 << '\\n';\n\t    return 0;\n\t}\n\twhile(cin>>a[n]>>b[n])\n\t{\n\t\tn++;\n\t}\n\tint t=bfs(sa,sb);\n\tif(t>10)\n\t{\n\t\tcout<<\"NO ANSWER!\"<<endl;\n\t}\n\telse\n\t{\n\t\tcout<<t<<endl;\n\t}\n    return 0;\n}\n```\n\n## *Astar* \n\n### [178. 第K短路](https://www.acwing.com/problem/content/180/)\n\n[评论](https://www.acwing.com/solution/content/147957/)\n\n```c++\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<string.h>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\ntypedef pair <int,int> PII;\ntypedef pair <int,PII> PIII;\nconst int N=1010,INF=0x3f3f3f3f;\nint dist[N],cnt[N];\nint st[N];\nint n,m;\nint a,b,c;\nint tt,ss,k;\nstruct edge\n{\n    int to;\n    int length;\n    edge(int t,int l):to(t),length(l){}\n};\nvector<PII>graph[N];\nvector<PII>rgraph[N];\nvoid dij()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[tt] = 0;\n    priority_queue<PII, vector<PII>, greater<PII>> heap;\n    heap.push({0, tt});      // first存储距离，second存储节点编号\n\n    while (heap.size())\n    {\n        auto t = heap.top();\n        heap.pop();\n\n        int ver = t.second, distance = t.first;\n\n        if (st[ver]) continue;\n        st[ver] = true;\n\n        for (int i = 0;i<rgraph[ver].size();i++)\n        {\n            int j = rgraph[ver][i].first;\n            int w=rgraph[ver][i].second;\n            if (dist[j] > distance + w)\n            {\n                dist[j] = distance + w;\n                heap.push({dist[j], j});\n            }\n        }\n    }\n    \n}\nint astar()\n{\n\tpriority_queue <PIII,vector <PIII>,greater <PIII>> heap;\n\theap.push({dist[ss],{0,ss}});\n\twhile(heap.size())\n\t{\n\t\tauto t=heap.top();\n\t\theap.pop();\n\t\tint ver=t.second.second,distance=t.second.first;\n\t\tcnt[ver]++;\n\t\tif(cnt[tt]==k)return distance;\n\t\tfor(int i = 0;i<graph[ver].size();i++)\n\t\t{\n\t\t\tint j = graph[ver][i].first;\n\t\t\tint w = graph[ver][i].second;\n\t\t\tif(dist[j]<INF)\n\t\t\t{\n\t\t\t\theap.push({distance+w+dist[j],{distance+w,j}});\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n    cin>>n>>m;\n    for(int i=0;i<m;i++)\n    {\n    \tcin>>a>>b>>c;\n    \tgraph[a].push_back({b, c});\n        rgraph[b].push_back({a, c});\n\t}\n\tcin>>ss>>tt>>k;\n\tif(ss==tt)k++;\n\tdij();\n\tcout<<astar()<<endl;\n    return 0;\n}\n```\n\n### [179. 八数码](https://www.acwing.com/problem/content/description/181/)\n\nhttps://www.acwing.com/solution/content/35528/\n\n```c++\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<string.h>\n#include<cmath>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\ntypedef pair <int,string> PII;\ntypedef pair <int,PII> PIII;\nconst int N=1010,INF=0x3f3f3f3f;\nint dist[N],cnt[N];\nint st[N];\nint n,m;\n\nint dir[4][2]={{-1,0},{1,0},{0,-1},{0,1}};\nstring c,start,x;\n\nint f(string m)\n{\n\tint dt=0;\n\tfor(int i=0;i<9;i++)\n\t{\n\t\tif(m[i]!='x')\n\t\t{\n\t\t\tint t=m[i]-'1';\n\t\t\tdt=dt+abs(i/3-t/3)+abs(i%3-t%3);\n\t\t}\n\t}\n\treturn dt;\n}\nstring bfs()\n{\n\tpriority_queue<PII, vector<PII>, greater<PII>> heap;//小根堆,将元素的估计终点距离从小到大排序\n\tunordered_map<string,int >d;\n\tunordered_map<string,pair<string,char>> last;//存储一个元素由哪种状态,经过哪种操作得来,跟前面几题一样\n\theap.push({f(start),start});\n\tchar op[]=\"udlr\";\n\tstring end=\"12345678x\";//终点\n\td[start]=0;\n\twhile(heap.size())\n\t{\n\t\tauto t=heap.top();\n\t\theap.pop();\n\t\tstring state=t.second;\n\t\tint cnt=d[state];\n\t\tif(t.second==\"12345678x\")break;\n\t\tint pos=state.find('x');\n\t\tint dx=pos/3,dy=pos%3;\n\t\tstring init=state;\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tint xx=dx+dir[i][0];\n\t\t\tint yy=dy+dir[i][1];\n\t\t\tif(xx>=0&&xx<3&&yy>=0&&yy<3)\n\t\t\t{\n\t\t\t\tswap(state[pos],state[xx*3+yy]);\n\t\t\t\tif(!d.count(state)||d[state]>d[init]+1)\n\t\t\t\t{\n\t\t\t\t\td[state]=d[init]+1;\n\t\t\t\t\theap.push({f(state)+d[state],state});\n\t\t\t\t\tlast[state]={init,op[i]};\n\t\t\t\t}\n\t\t\t\tswap(state[pos],state[xx*3+yy]);\n\t\t\t}\n//\t\t\tcout<<xx<<','<<yy<<endl;\n\t\t}\n\t}\n\tstring ans;\n\twhile(end!=start)\n\t{\n\t\tans+=last[end].second;\n\t\tend=last[end].first;\n\t}\n\treverse(ans.begin(),ans.end());//将其反转\n\treturn ans;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\tfor(int i=0;i<9;i++)\n\t{\n\t\tcin>>c;\n\t\tstart+=c;\n\t\tif(c!=\"x\") x+=c;\t\t\n\t}\n\t int res=0;//统计逆序对的数量\n    for(int i=0;i<8;i++)\n    \tfor(int j=i+1;j<8;j++)\n    \t\tif(x[i]>x[j]) \n       \t\t\tres++;\n\n    if(res%2) printf(\"unsolvable\\n\");//如果逆序对为奇数,就不可能抵达终点\n    else\n\tcout<<bfs()<<endl;\n\treturn 0;\t\n}\n\n```\n\n## DFS之连通性模型(flood fill)\n\n### [1112. 迷宫](https://www.acwing.com/problem/content/description/1114/)\n\n```c++\n//\n// Created by wyh on 2023/7/18.\n//\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<string.h>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1010;\nint dir[4][2]={{-1,0},{1,0},{0,-1},{0,1}};\nchar g[maxn][maxn];\nint ans=0,k;\nint n=0,ex,ey,sy,sx;\nint dfs(int x,int y)\n{\n    int dx=0,dy=0;\n    if(x==ex&&y==ey)return 1;\n    for(int i=0;i<4;i++)\n    {\n        dx=x+dir[i][0];\n        dy=y+dir[i][1];\n        if(dx>=0&&dx<n&&dy>=0&&dy<n&&g[dx][dy]!='#')\n        {\n            g[dx][dy]='#';\n            if(dfs(dx,dy))return 1;\n        }\n    }\n    return 0;\n\n}\nint main()\n{\n\tcin>>k;\n\twhile(k--)\n\t{\n\t\tcin>>n;\n\t    for(int i=0;i<n;i++)\n\t    {\n\t        for(int j=0;j<n;j++)\n\t        {\n\t            cin>>g[i][j];\n\t        }\n\t    }\n\t    cin>>sx>>sy>>ex>>ey;\n\t    if(g[sx][sy] == '#' || g[ex][ey] == '#')\n\t    {\n\t    \tcout<<\"NO\"<<endl;\n\t    \tcontinue;\n\t\t}\n\t    if(dfs(sx,sy))cout<<\"YES\"<<endl;\n\t    else cout<<\"NO\"<<endl;\n\t}\n    \n    return 0;\n}\n\n```\n\n### [1113. 红与黑](https://www.acwing.com/problem/content/description/1115/)\n\n```c++\n//\n// Created by wyh on 2023/7/18.\n//\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<string.h>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1010;\nint dir[4][2]={{-1,0},{1,0},{0,-1},{0,1}};\nchar g[maxn][maxn];\nint st[maxn][maxn];\nint ans=0;\nint n=0,m=0;\nint dfs(int x,int y)\n{\n    int dx=0,dy=0;\n    int cnt=1;\n    for(int i=0;i<4;i++)\n    {\n        dx=x+dir[i][0];\n        dy=y+dir[i][1];\n        if(dx>=0&&dx<n&&dy>=0&&dy<m&&g[dx][dy]!='#'&&!st[dx][dy])\n        {\n            st[dx][dy]=1;\n            cnt+=dfs(dx,dy);\n        }\n    }\n\treturn cnt;\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tcin>>m>>n;\n\t\tif(!m&&!n)break;\n\t\tmemset(st,0,sizeof(st));\n\t    for(int i=0;i<n;i++)\n\t    {\n\t        for(int j=0;j<m;j++)\n\t        {\n\t            cin>>g[i][j];\n\t        }\n\t    }\n\t    for(int i=0;i<n;i++)\n\t    {\n\t        for(int j=0;j<m;j++)\n\t        {\n\t            if(g[i][j]=='@')\n\t            {\n\t            \tst[i][j]=1;\n\t                ans=dfs(i,j);\n//\t                break;\n\t            }\n\t        }\n\t    }\n\t    cout<<ans<<endl;\n\t}\n    \n    return 0;\n}\n\n```\n\n## DFS之搜索顺序\n\n### [1116. 马走日](https://www.acwing.com/problem/content/1118/)\n\n```c++\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<string.h>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1010;\nint dir[8][2]={{-1,2},{1,2},{2,-1},{2,1},{-1,-2},{1,-2},{-2,-1},{-2,1}};\n//char g[maxn][maxn];\nint st[maxn][maxn];\nint ans=0;\nint n=0,m=0,k,sx,sy;\nvoid dfs(int x,int y,int t)\n{\n    int dx=0,dy=0;\n    int cnt=1;\n    if(t==n*m)\n    {\n    \tans++;\n    \treturn;\n\t}\n    for(int i=0;i<8;i++)\n    {\n        dx=x+dir[i][0];\n        dy=y+dir[i][1];\n        if(dx>=0&&dx<n&&dy>=0&&dy<m&&!st[dx][dy])\n        {\n            st[dx][dy]=1;\n            dfs(dx,dy,t+1);\n            st[dx][dy]=0;\n        }\n    }\n\t\n}\nint main()\n{\n\tcin>>k;\n\twhile(k--)\n\t{\n\t\tans=0;\n\t\tcin>>n>>m>>sx>>sy;\n//\t\tsx++,sy++;\n//\t\tif(!m&&!n)break;\n\t\tmemset(st,0,sizeof(st));\n\t    st[sx][sy]=1;\n\t    dfs(sx,sy,1);\n\t   \n\t    cout<<ans<<endl;\n\t}\n    \n    return 0;\n}\n\n```\n\n### *[1117. 单词接龙](https://www.acwing.com/problem/content/1119/)*\n\nhttps://www.acwing.com/solution/content/59984/\n\n```c++\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<string.h>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1010;\nint dir[8][2]={{-1,2},{1,2},{2,-1},{2,1},{-1,-2},{1,-2},{-2,-1},{-2,1}};\nint g[maxn][maxn];\nstring word[maxn];\nint used[maxn];\nint ans=0;\nint n=0,m=0,k,sx,sy;\nvoid dfs(string dragon,int last)\n{\n    //法一：\n// \tans=max((int)dragon.size(),ans);\n//\tused[last]++;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(g[last][i]&&used[i]<2)\n\t\t{\n\t\t    ans=max((int)(dragon+word[i].substr(g[last][i])).size(),ans);\n\t\t\tused[i]++;\n\t\t\t\n\t\t\tdfs(dragon + word[i].substr(g[last][i]), i);\n\t\t\tused[i]--;\n\t\t}\n\t}\n//\tused[last]--;\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>word[i];\n\t}\n    char sta;\n    cin>>sta;\n    for(int i=0;i<n;i++)\n    {\n    \tfor(int j=0;j<n;j++)\n    \t{\n    \t\tstring a=word[i],b=word[j];\n    \t\tfor(int k=1;k<min(a.size(),b.size());k++)\n    \t\t{\n    \t\t\tif(a.substr(a.size()-k,k)==b.substr(0,k))\n    \t\t\t{\n    \t\t\t\tg[i][j]=k;\n    \t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(word[i][0]==sta)\n\t\t{\n            //法一这两行不需要\n\t\t    ans=max((int)(word[i]).size(),ans);\n\t\t\tused[i]++;\n\t\t\tdfs(word[i],i);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n    return 0;\n}\n\n```\n\n### *[1118. 分成互质组](https://www.acwing.com/problem/content/description/1120/)*\n\n```c++\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<string.h>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1010;\nint dir[8][2]={{-1,2},{1,2},{2,-1},{2,1},{-1,-2},{1,-2},{-2,-1},{-2,1}};\n//char g[maxn][maxn];\nint a[maxn];\nint ans=100;\nint n=0,m=0,k,sx,sy;\nvector<vector<int> > g;\nint check(int c,int x)\n{\n\tfor(int i=0;i<g[c].size();i++)\n\t{\n\t\tif(__gcd(g[c][i],x)>1)return 0;\n\t}\n\treturn 1;\n}\nvoid dfs(int u)\n{\n\tif(g.size()>ans)return;\n    if(u==n)\n    {\n    \tans=min(ans,(int)g.size());\n    \treturn;\n\t}\n\tfor(int i=0;i<g.size();i++)\n\t{\n\t\tif(check(i,a[u]))\n\t\t{\n\t\t\tg[i].push_back(a[u]);\n\t\t\tdfs(u+1);\n\t\t\tg[i].pop_back();\n\t\t}\n\t}\n\tg.push_back({a[u]});\n\tdfs(u+1);\n\tg.pop_back();\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tdfs(0);\n\tcout<<ans<<endl;\n    return 0;\n}\n```\n\n## DFS之剪枝与优化\n\n### [165. 小猫爬山](https://www.acwing.com/problem/content/description/167/)\n\n```c++\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<string.h>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1010;\nint dir[8][2]={{-1,2},{1,2},{2,-1},{2,1},{-1,-2},{1,-2},{-2,-1},{-2,1}};\n//char g[maxn][maxn];\nint a[maxn];\nint ans=100;\nint n=0,w=0,k,sx,sy;\nvector<vector<int> > g;\nvector<int>sum;\nbool cmp(int a, int b) \n{\n    return a > b;\n}\nvoid dfs(int u)\n{\n\tif(sum.size()>=ans)return;\n    if(u==n)\n    {\n    \tans=min(ans,(int)sum.size());\n    \treturn;\n\t}\n\tfor(int i=0;i<sum.size();i++)\n\t{\n\t\tif(sum[i]+a[u]<=w)\n\t\t{\n// \t\t\tg[i].push_back(a[u]);\n\t\t\tsum[i]+=a[u];\n\t\t\tdfs(u+1);\n// \t\t\tg[i].pop_back();\n\t\t\tsum[i]-=a[u];\n\t\t}\n\t}\n// \tg.push_back({a[u]});\n\tsum.push_back({a[u]});\n\tdfs(u+1);\n// \tg.pop_back();\n\tsum.pop_back();\n}\nint main()\n{\n\tcin>>n>>w;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n    //注意排序的剪枝\n\tsort(a,a+n,cmp);\n\tdfs(0);\n\tcout<<ans<<endl;\n    return 0;\n}\n\n```\n\n### *[166. 数独](https://www.acwing.com/problem/content/description/168/)*\n\n思路\n数独一看就可以暴搜，但一看就会超时，所以考虑剪枝。\n\n优化搜索顺序 ✔ ✔\n可以优先搜索位置上能填的数最少的方格\n\n排除等效冗余 ✖ ✖\n因为整棵搜索树都会搜到，所以不能排除等效冗余\n可行性剪枝 ✔ ✔\n这一步可以放在枚举能放的位置上进行优化\n由于每一行每一列每一个宫格都不能重复，所以我们可以用位运算优化枚举数的过程\n最优化剪枝 ✖ ✖\n这里我们无需考虑答案最小，只需考虑是否有解\n\n改进\n优化搜索顺序，每次优先搜索可选放入数字最少的空白格子，这样它下面搜索时的分支就会少\n假设当前搜索到坐标为（x，y）的这个格子\n\n1. 先解释一下几个数组的含义\n   row【i】表示第i行能放的数有哪些（1-9），是二进制表示的，9个位置上，1代表这个数能放，0代表不能放\n   col【j】表示第j行能放的数有哪些（1-9），二进制表示同上\n   cell【i】【j】----这里把坐标看成是3*3的，（i，j）就指向了一个唯一的小型九宫格，也是二进制表示这个小型九宫格里能放的数有哪些\n   这样我们在（x，y）这个位置上放的数就是满足行，列，小型九宫格都能放的数，取交集\n   row[x]&col[y]&cell[x/3][ y/3 \\]三者取交集—(x/3,y/3)是小型九宫格的位置\n\n想到位运算优化，三个二进制数进行与运算，最后得到的二进制数中为1的位置，代表这个数能放进（x，y）这个空格子里\n\n2. 另一个位运算优化：lowbit（）\n   lowbit()可以用来计算一个二进制数里面有多少个1\n   lowbit举个例子：lowbit（x） x=10001000（二进制） 会返回1000（二进制）\n   因为会返回1000，而不会返回我们想要直到的1在第几位，\n   所以我们有额外开了数组map【】 1000->8->log2 8就是3,这样1000就会返回map【1000】=3\n\n   map【100】=2 \n\n3. 另外我们还需要看一下最后三者交集的二进制数结果里有多少个1，根据1的数目选择数目较少的先进行搜索，达到优化搜索顺序剪枝的目的：\n   用ones【i】记录二进制数i里面有多少个1 (i属于【0,2的9次方-1】)\n\n[](https://www.acwing.com/solution/content/56364/)\n\n```c++\n#include<bits/stdc++.h>\n#define debug(a) cout<<#a<<\"=\"<<a<<endl\n#define ll long long\nconst int N=9;\n\nusing namespace std;\ntypedef pair<int,int> pii;\nint  mapp[1<<N],ones[1<<N];\nint row[N],col[N],ma[3][3];\nstring str;\ninline void init()\n{\n\tfor(int i=0;i<9;i++)\n\t{\n\t\trow[i]=col[i]=(1<<N)-1;\n\t}\n\t\n\tfor(int i=0;i<3;i++)\n\t{\n\t\tfor(int j=0;j<3;j++)\n\t\t{\n\t\t\tma[i][j]=(1<<N)-1;\n\t\t}\n\t}\n}\ninline int lowbit(int x)\n{\n\treturn x&-x;\n}\ninline int get(int x,int y)\n{\n\treturn row[x]&col[y]&ma[x/3][y/3];\n}\nint dfs(int cnt)\n{\n\tif(!cnt)return 1;\n\tint minv=10,x=0,y=0;\n\tfor(int i=0;i<9;i++)\n\t{\n\t\tfor(int j=0;j<9;j++)\n\t\t{\n\t\t\tif(str[i*9+j]=='.')\n\t\t\t{\n\t\t\t\tint t=ones[get(i,j)];\n\t\t\t\tif(t<minv)\n\t\t\t\t{\n\t\t\t\t\tminv=t;\n\t\t\t\t\tx=i;\n\t\t\t\t\ty=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tfor(int i=get(x,y);i;i-=lowbit(i))\n\t{\n\t\tint t=mapp[lowbit(i)];\n\t\trow[x]-=(1<<t);\n\t\tcol[y]-=(1<<t);\n\t\tma[x/3][y/3]-=1<<t;\n\t\tstr[x*9+y]='1'+t;\n\t\tif(dfs(cnt-1))return 1;\n\t\trow[x]+=(1<<t);\n\t\tcol[y]+=(1<<t);\n\t\tma[x/3][y/3]+=1<<t;\n\t\tstr[x*9+y]='.';\n\t}\n\treturn 0;\n}\nint main() \n{\n\tfor(int i=0;i<9;i++)\n\t{\n\t\tmapp[1<<i]=i;\n\t}\n\tfor(int i=0;i<1<<N;i++)\n\t{\n\t\tint s=0;\n\t\tfor(int j=i;j;j-=lowbit(j))s++;\n\t\tones[i]=s;\n\t}\n    while(cin>>str)\n    {\n    \tif(str==\"end\")break;\n    \tinit();\n    \tint cnt=0;\n    \tfor(int i=0,k=0;i<9;i++)\n    \t{\n    \t\tfor(int j=0;j<9;j++,k++)\n    \t\t{\n    \t\t\tif(str[k]!='.')\n    \t\t\t{\n    \t\t\t\tint t=str[k]-'1';\n    \t\t\t\trow[i]-=1<<t;\n    \t\t\t\tcol[j]-=1<<t;\n    \t\t\t\tma[i/3][j/3]-=1<<t;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(cnt);\n\t\tcout<<str<<endl;\n\t}\n    return 0;\n}\n```\n\n### *[167. 木棒](https://www.acwing.com/problem/content/description/169/)*\n\n[code refer](https://www.acwing.com/solution/content/36030/)\n\n[剪枝策略](https://www.acwing.com/solution/content/121003/)\n\n```c++\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<string.h>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int N=1010;\nint len,sum,n,st[N],w[N];\nbool cmp(int a, int b) \n{\n    return a > b;\n}\nint dfs(int u,int s,int start)\n{\n\tif(u*len==sum)return 1;\n\tif(s==len)return dfs(u+1,0,0);//易错\n\tfor(int i=start;i<n;i++)\n\t{\n\t\tif(!st[i]&&s+w[i]<=len)\n\t\t{\n\t\t\tst[i]=1;\n\t\t\tif(dfs(u,s+w[i],i+1))return 1;\n\t\t\tst[i]=0;\n\t\t\tif(!s||s+w[i]==len)return 0;\n\t\t\tint j=i;\n\t\t\twhile(j<n&&w[j]==w[i])j++;\n\t\t\ti=j-1;\n\t\t}\n\t } \n\t return 0;\n}\nint main()\n{\n\twhile(cin>>n&&n)\n\t{\n\t\tmemset(st,0,sizeof(st));\n\t\tsum=0,len=1;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>w[i];\n\t\t\tsum+=w[i];\n\t\t}\n\t\tsort(w,w+n,cmp);\n\t\twhile(1)\n\t\t{\n\t\t\tif(sum%len==0&&dfs(0,0,0))\n\t\t\t{\n\t\t\t\tcout<<len<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen++;\n\t\t}\n\t\t\n\t}\n    return 0;\n}\n\n```\n\n### *[168. 生日蛋糕](https://www.acwing.com/problem/content/170/)*\n\n*https://www.acwing.com/solution/content/4187/*\n\n![image-20230725173137592](D:\\wyh\\大学\\信息\\image-20230725173137592.png)\n\n```c++\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<string.h>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int N = 24, INF = 1e9;\nconst int maxn=1010;\n//char g[maxn][maxn];\nint n=0,m=0;\nint res=INF,cnt;\nint minv[maxn],mins[maxn],hh[maxn],rr[maxn];\nvoid dfs(int u,int v,int s)\n{\n\tif(v+minv[u]>n)return;//可行性\n\t\n\tif(s+mins[u]>=res)return;//最优解\n\tif(s+2*(n-v)/rr[u+1]>=res)return;\n//\tcout<<n<<\" \"<<m<<endl;\n\tif(!u)\n\t{\n\t\tif(v==n)res=s;\n\t\treturn;\n\t} \n\tfor(int r=min(rr[u+1]-1,(int)sqrt((n-v)));r>=u;r--)\n\t{\n\t\tfor(int h=min(hh[u+1]-1,(n-v)/r/r);h>=u;h--)\n\t\t{\n\t\t\tint t=0;\n\t\t\t//最底层的时候需要加上r*r\n\t\t\tif(u==m)t=r*r;\n\t\t\trr[u]=r,hh[u]=h;\n//\t\t\tif(u==1)\n//\t\t\tcout<<u<<\" \"<<r<<\" \"<<h<<cnt++<<endl;\n\t\t\tdfs(u-1,v+r*r*h,s+2*r*h+t);\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tminv[i]=minv[i-1]+i*i*i;\n\t\tmins[i]=mins[i-1]+2*i*i;\n\t}\n\t//m+1层不存在，作为哨兵，减少边界情况的判断\n\trr[m+1]=hh[m+1]=INF;\n//\tcout<<n<<m<<endl;\n\tdfs(m,0,0);\n\tif(res==INF)res=0;\n\tcout<<res<<endl;\n    return 0;\n}\n```\n\n## 迭代加深\n\n### *[170. 加成序列](https://www.acwing.com/problem/content/submission/code_detail/26796583/)*\n\n> ​\t\t1\n>\n> ​\t\t2\n>\n> **4**     \t\t 3\n>\n> 8 6 5      6 5 **4**\n>\n> 不是同一层不能去重\n\n#### 写法1：\n\n```c++\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<string.h>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1010;\n\n//char g[maxn][maxn];\nint a[maxn];\nint ans=100;\nint n=0,w=0,k,sx,sy;\nvector<vector<int> > g;\nint path[maxn];\n\nint dfs(int u,int depth)\n{\n\tif(u>depth)return 0;\n\tif(u==depth)return path[u-1]==n;\n\tint st[maxn]={0};//定义在本层，只进行本层去重\n\tfor(int i=u-1;i>=0;i--)\n\t{\n\t\tfor(int j=i;j>=0;j--)\n\t\t{\n\t\t\tint s=path[i]+path[j];\n\t\t\tif(s > n || s <= path[u - 1] || st[s])continue;\n\t\t\tst[s]=1;\n\t\t\tpath[u]=s;\n\t\t\tif(dfs(u+1,depth))return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tpath[0]=1;\n\twhile(cin>>n&&n)\n\t{\n\t\tint dep=1;\n\t\twhile(!dfs(1,dep))\n\t\t{\n\t\t\tdep++;\n\t\t}\n\t\tfor(int i=0;i<dep;i++)\n\t\t{\n\t\t\tcout<<path[i]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n    return 0;\n}\n```\n\n#### 写法2：\n\n```c++\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<string.h>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1010;\n\n//char g[maxn][maxn];\nint a[maxn];\nint ans=100;\nint n=0,w=0,k,sx,sy;\nvector<vector<int> > g;\nint path[maxn];\nint st[maxn]={0};\nint dfs(int u,int depth)\n{\n\tif(u>depth)return 0;\n\tif(u==depth)return path[u-1]==n;\n\t\n\tfor(int i=u-1;i>=0;i--)\n\t{\n\t\tfor(int j=i;j>=0;j--)\n\t\t{\n\t\t\tint s=path[i]+path[j];\n//\t\t\tcout<<s<<endl;\n\t\t\tif(s > n || s <= path[u - 1] || st[s])continue;\n//\t\t\tcout<<s<<\" u:\"<<u<<\" \"<<path[u-1]<<\" \"<<depth<<endl;\n\t\t\tst[s]=1;\n\t\t\tpath[u]=s;\n\t\t\tif(dfs(u+1,depth))return 1;\n\t\t\tst[s]=0;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tpath[0]=1;\n\twhile(cin>>n&&n)\n\t{\n\t\tint dep=1;\n\t\tmemset(st,0,sizeof(st));\n\t\twhile(!dfs(1,dep))\n\t\t{\n\t\t\tdep++;\n\t\t\t\n\t\t}\n\t\tfor(int i=0;i<dep;i++)\n\t\t{\n\t\t\tcout<<path[i]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n    return 0;\n}\n```\n\n## *双向DFS*\n\n### [171. 送礼物](https://www.acwing.com/problem/content/172/)\n\n```c++\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<string.h>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1010;\n\n//char g[maxn][maxn];\nint a[maxn];\nint ans=100;\nint n=0,w=0,k,sx,sy;\nvector<vector<int> > g;\nint path[maxn];\nint st[maxn]={0};\nint dfs(int u,int depth)\n{\n\tif(u>depth)return 0;\n\tif(u==depth)return path[u-1]==n;\n\t\n\tfor(int i=u-1;i>=0;i--)\n\t{\n\t\tfor(int j=i;j>=0;j--)\n\t\t{\n\t\t\tint s=path[i]+path[j];\n//\t\t\tcout<<s<<endl;\n\t\t\tif(s > n || s <= path[u - 1] || st[s])continue;\n//\t\t\tcout<<s<<\" u:\"<<u<<\" \"<<path[u-1]<<\" \"<<depth<<endl;\n\t\t\tst[s]=1;\n\t\t\tpath[u]=s;\n\t\t\tif(dfs(u+1,depth))return 1;\n\t\t\tst[s]=0;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tpath[0]=1;\n\twhile(cin>>n&&n)\n\t{\n\t\tint dep=1;\n\t\tmemset(st,0,sizeof(st));\n\t\twhile(!dfs(1,dep))\n\t\t{\n\t\t\tdep++;\n\t\t\t\n\t\t}\n\t\tfor(int i=0;i<dep;i++)\n\t\t{\n\t\t\tcout<<path[i]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n    return 0;\n}\n\n```\n\n\n\n## *IDA* *\n\n### [180. 排书](https://www.acwing.com/problem/content/182/)\n\nhttps://www.acwing.com/solution/content/161158/\n\n```c++\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<string.h>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\nconst int maxn=1010,N=31;\n//char g[maxn][maxn];\nint n;\nint q[N],w[5][N];\nint f()\n{\n\tint res=0;\n\tfor(int i=0;i+1<n;i++)\n\t{\n\t\tif(q[i+1]!=q[i]+1)\n\t\t{\n\t\t\tres++;\n\t\t}\n\t}\n\treturn (res+2)/3;\n\t\n}\nbool check()\n{\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(q[i]!=i+1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nint dfs(int dep,int maxdep)\n{\n\tif(dep+f()>maxdep)return 0;\n\tif(check())return 1;\n\tfor(int l=0;l<n;l++)\n\t{\n\t\tfor(int r=l;r<n;r++)\n\t\t{\n\t\t\tfor(int k=r+1;k<n;k++)\n\t\t\t{\n\t\t\t\tmemcpy(w[dep],q,sizeof(q));\n\t\t\t\tint x=0,y=0;\n\t\t\t\tfor(x=r+1,y=l;x<=k;x++,y++)q[y]=w[dep][x];\n\t\t\t\tfor(x=l;x<=r;x++,y++)q[y]=w[dep][x];\n\t\t\t\tif(dfs(dep+1,maxdep))return 1;\n\t\t\t\tmemcpy(q,w[dep],sizeof(q));\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint t=0;\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++)\n\t\tcin>>q[i];\n\t\tint dep=0;\n\t\twhile(dep<5&&!dfs(0,dep))dep++;\n\t\tif(dep>=5)\n\t\t{\n\t\t\tcout<<\"5 or more\"<<endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout<<dep<<endl;\n\t\t}\n\t} \n    return 0;\n}\n\n```\n\n### [AcWing 181. 回转游戏](https://www.acwing.com/problem/content/183/)\n\nhttps://www.acwing.com/solution/content/4056/\n\n![image-20230728233423620](D:\\wyh\\大学\\信息\\image-20230728233423620.png)\n\n先A后F等于浪费了两次操作，剪枝opposite\n\nop为每个调整的字母对映的位置\n\ncenter为中间8个数的编号\n\n```c++\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<string.h>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\nconst int maxn=1010,N=24;\n//char g[maxn][maxn];\nint n;\nint q[N];\nint op[8][7] = {\n    {0, 2, 6, 11, 15, 20, 22},\n    {1, 3, 8, 12, 17, 21, 23},\n    {10, 9, 8, 7, 6, 5, 4},\n    {19, 18, 17, 16, 15, 14, 13},\n    {23, 21, 17, 12, 8, 3, 1},\n    {22, 20, 15, 11, 6, 2, 0},\n    {13, 14, 15, 16, 17, 18, 19},\n    {4, 5, 6, 7, 8, 9, 10}\n};\nint center[8] = {6, 7, 8, 11, 12, 15, 16, 17};\nint opposite[8] = {5, 4, 7, 6, 1, 0, 3, 2};\nint path[100];\n\nint sum[4];\nint f()\n{\n\tmemset(sum,0,sizeof(sum));\n\tfor(int i=0;i<8;i++)\n\t{\n\t\tsum[q[center[i]]]++;\n\t}\n\tint s=0;\n\tfor(int i=1;i<=3;i++)\n\t{\n\t\ts = max(s, sum[i]);\n\t}\n\treturn 8-s;\n\n}\nbool check()\n{\n    for (int i = 1; i < 8; i ++ )\n        if (q[center[i]] != q[center[0]])\n            return false;\n    return true;\n}\nvoid oper(int x)\n{\n\tint t=q[op[x][0]];\n\tfor(int i=0;i<6;i++)q[op[x][i]]=q[op[x][i+1]];\n\t\n\tq[op[x][6]] = t;\n}\nint dfs(int dep,int maxdep,int last)\n{\n\tif(dep+f()>maxdep)return 0;\n\tif(!f())return 1;\n\tfor(int i=0;i<8;i++)\n\t{\n\t\tif(opposite[i]==last)continue;\n\t\toper(i);\n\t\tpath[dep]=i;\n\t\tif(dfs(dep+1,maxdep,i))return 1;\n\t\toper(opposite[i]);\n\t}\n\treturn 0;\n}\nint main()\n{\n//\tint t=0;\n//\tcin>>t;\n\twhile(cin>>q[0]&&q[0])\n\t{\n\t\t\n\t\tfor(int i=1;i<N;i++)\n\t\t\tcin>>q[i];\n//\t\tcout<<q[0];\n\t\tint dep=0;\n\t\twhile(!dfs(0,dep,-1))dep++;\n\t\tif(!dep)\n\t\t{\n\t\t\tcout<<\"No moves needed\";\n\t\t}\n\t\tfor(int i=0;i<dep;i++)\n\t\t \tprintf(\"%c\", 'A' + path[i]);\n\t\tcout<<endl;\n\t\tcout<<q[6]<<endl;\n\t} \n    return 0;\n}\n\n```\n\n","tags":["加密文章tag"],"categories":["Algorithm"]},{"title":"linklist","url":"/2024/04/16/linklist/","content":"\n|                                                              |                                                              | refer                                                        |                                                              |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| [链表 - 反转系列](https://www.bilibili.com/video/BV1sd4y1x7KN/) | [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)<br />[LCR 141. 训练计划 III](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/) | [代码](https://leetcode.cn/problems/reverse-linked-list/solution/you-xie-cuo-liao-yi-ge-shi-pin-jiang-tou-o5zy/) | 迭代+递归                                                    |\n|                                                              | [92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/) | [代码 ](https://leetcode.cn/problems/reverse-linked-list-ii/solution/you-xie-cuo-liao-yi-ge-shi-pin-jiang-tou-teqq/) |                                                              |\n|                                                              | [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/) | [代码<br />](https://leetcode.cn/problems/reverse-nodes-in-k-group/solution/you-xie-cuo-liao-yi-ge-shi-pin-jiang-tou-plfs/)迭代<br /> for(;n>0;n-=k)<br/>        {<br/>            for(int i=0;i<min(k,n);i++)<br/>不足k也反转 | 递归<br /><br />[评论](https://leetcode.cn/problems/reverse-nodes-in-k-group/solutions/1992228/you-xie-cuo-liao-yi-ge-shi-pin-jiang-tou-plfs) |\n|                                                              | [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/) | [代码](https://leetcode.cn/problems/swap-nodes-in-pairs/solution/tu-jie-die-dai-di-gui-yi-zhang-tu-miao-d-51ap) | 25 k=2情况                                                   |\n|                                                              | [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)<br />[面试题 02.05. 链表求和](https://leetcode.cn/problems/sum-lists-lcci/) | [递归](https://leetcode.cn/problems/add-two-numbers/solutions/2327008/dong-hua-jian-ji-xie-fa-cong-di-gui-dao-oe0di) | [迭代](https://leetcode.cn/problems/add-two-numbers/solutions/2327008/dong-hua-jian-ji-xie-fa-cong-di-gui-dao-oe0di) |\n|                                                              | [445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/) | [代码](https://leetcode.cn/problems/add-two-numbers-ii/solution/fan-zhuan-lian-biao-liang-shu-xiang-jia-okw6q)反转+两数相加（迭代） | 栈                                                           |\n|                                                              | [2816. 翻倍以链表形式表示的数字](https://leetcode.cn/problems/double-a-number-represented-as-a-linked-list/) | [代码](https://leetcode.cn/problems/double-a-number-represented-as-a-linked-list/solution/o1-kong-jian-zuo-fa-kan-cheng-shi-head-y-1dco/) | 和[445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/)差不多 |\n| [链表 - 快慢指针](https://www.bilibili.com/video/BV1KG4y1G7cu/) | [876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/) | [代码](https://leetcode.cn/problems/middle-of-the-linked-list/solutions/1999265/mei-xiang-ming-bai-yi-ge-shi-pin-jiang-t-wzwm/) |                                                              |\n| 环形链表三连问： <br />1. 是否有环(141) <br />2. 找出环的入口(142) <br />3. 环中节点个数<br/>环中节点的个数?<br/>pre与post相遇在环的入口, 让pre单独在环里再走一圈, 并进行计数, 当pre.next == post时, 返回count+1, 就是所谓的环中节点的个数。 | [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/) | [代码](https://leetcode.cn/problems/linked-list-cycle/solutions/1999269/mei-xiang-ming-bai-yi-ge-shi-pin-jiang-t-c4sw/) |                                                              |\n|                                                              | [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/) | [代码](https://leetcode.cn/problems/linked-list-cycle-ii/solutions/1999271/mei-xiang-ming-bai-yi-ge-shi-pin-jiang-t-nvsq/) |                                                              |\n|                                                              | [143. 重排链表](https://leetcode.cn/problems/reorder-list/)<br /><br />[LCR 026. 重排链表](https://leetcode.cn/problems/LGjMqU/) | [代码](https://leetcode.cn/problems/reorder-list/solutions/1999276/mei-xiang-ming-bai-yi-ge-shi-pin-jiang-t-u66q/) |                                                              |\n|                                                              | [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)<br />[LCR 027. 回文链表](https://leetcode.cn/problems/aMhZSa/) | 快慢指针+反转                                                |                                                              |\n|                                                              | [61. 旋转链表](https://leetcode.cn/problems/rotate-list/)    | [快慢指针](https://leetcode.cn/problems/rotate-list/solutions/2709835/yong-shuang-zhi-zhen-jie-jue-by-daz2ling-bdaw) |                                                              |\n| [链表 - 删除系列](https://www.bilibili.com/video/BV1VP4y1Q71e/) | [237. 删除链表中的节点](https://leetcode.cn/problems/delete-node-in-a-linked-list/) | [代码](https://leetcode.cn/problems/delete-node-in-a-linked-list/solutions/2004056/ru-he-shan-chu-jie-dian-liu-fen-zhong-ga-x3kn/) | 脑筋急转弯                                                   |\n|                                                              | [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)<br />[LCR 140. 训练计划 II](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)<br />[面试题 02.02. 返回倒数第 k 个节点](https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/) | [快慢](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solutions/2004057/ru-he-shan-chu-jie-dian-liu-fen-zhong-ga-xpfs/) | 栈（官解）<br /><br />递归（官解评论）                       |\n|                                                              | [83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/) | [代码](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/solutions/2004062/ru-he-qu-zhong-yi-ge-shi-pin-jiang-tou-p-98g7/) | 去重                                                         |\n|                                                              | [82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/) | [代码](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/solutions/2004067/ru-he-qu-zhong-yi-ge-shi-pin-jiang-tou-p-2ddn/) |                                                              |\n|                                                              | [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)<br />[LCR 136. 删除链表的节点](https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/) |                                                              |                                                              |\n| 合并                                                         | [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/) | [递归](https://leetcode.cn/problems/merge-two-sorted-lists/solutions/103891/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-递归) | [合并俩个有序列表并去重](https://leetcode.cn/problems/merge-two-sorted-lists/solutions/1333622/he-bing-by-handsometaoa-bc42/)<br />[去重合集](https://blog.csdn.net/chemistryer/article/details/132641975?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22132641975%22%2C%22source%22%3A%22chemistryer%22%7D) |\n|                                                              | [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/) | 优先队列（最优）<br />手写堆（[从0计数可参考](https://leetcode.cn/problems/merge-k-sorted-lists/solutions/1697507/by-hjlogzw-bruv)） | 归并                                                         |\n| 插入                                                         | [147. 对链表进行插入排序](https://leetcode.cn/problems/insertion-sort-list/) | 官解                                                         |                                                              |\n|                                                              | [LCR 029. 循环有序列表的插入](https://leetcode.cn/problems/4ueAj6/)<br />708 | [边界](https://leetcode.cn/problems/4ueAj6/solutions/1608952/by-ac_oier-kqv3) |                                                              |\n| 其他                                                         | [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)<br />[LCR 171. 训练计划 V](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)<br />[面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/) | 将头对其                                                     | [pa走完转pb的head](https://leetcode.cn/problems/intersection-of-two-linked-lists/solutions/10774/tu-jie-xiang-jiao-lian-biao-by-user7208t) |\n|                                                              | [148. 排序链表](https://leetcode.cn/problems/sort-list/)     | [快排，选取中间节点注意快慢指针分割，要加dummy](https://leetcode.cn/problems/sort-list/solutions/2400774/ge-chong-pai-xu-suan-fa-jie-jue-mou-pao-9dwmt)<br />//将head放在右半段的头结点位置 | 归并递归<br />[归并迭代](https://leetcode.cn/problems/sort-list/solutions/437400/pai-xu-lian-biao-di-gui-die-dai-xiang-jie-by-cherr) |\n|                                                              | [86. 分隔链表](https://leetcode.cn/problems/partition-list/) | 148的快排分割前置                                            |                                                              |\n|                                                              | [138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)<br />[LCR 154. 复杂链表的复制](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/) | dfs+hash<br />[迭代](https://leetcode.cn/problems/copy-list-with-random-pointer/solutions/889447/gong-shui-san-xie-yi-ti-shuang-jie-ha-xi-pqek)<br />[哈希一次](https://cnwangzhou.gitbook.io/algorithm/leetcode-part1/data_structure#id-138.-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao)<br />哈希两次 |                                                              |\n|                                                              | [排序奇升偶降链表](https://mp.weixin.qq.com/s/0WVa2wIAeG0nYnVndZiEXQ)<br />[**NC207** **排序奇升偶降链表**](https://www.nowcoder.com/practice/3a188e9c06ce4844b031713b82784a2a?tpId=117&tqId=39396&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26pageSize%3D50%26search%3D207%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D117&difficulty=undefined&judgeStatus=undefined) | 1. 按奇偶位置拆分链表，得1->3->5->7->NULL和8->6->4->2->NULL（[328. 奇偶链表](https://leetcode.cn/problems/odd-even-linked-list/)）<br />2. 反转偶链表，得1->3->5->7->NULL和2->4->6->8->NULL<br />3. 合并两个有序链表，得1->2->3->4->5->6->7->8->NULL（[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)） |                                                              |\n|                                                              | [430. 扁平化多级双向链表](https://leetcode.cn/problems/flatten-a-multilevel-doubly-linked-list/)<br /><br />[LCR 028. 扁平化多级双向链表](https://leetcode.cn/problems/Qv1Da2/) | [迭代+递归](https://leetcode.cn/problems/flatten-a-multilevel-doubly-linked-list/solutions/1014046/gong-shui-san-xie-yi-ti-shuang-jie-di-gu-9wfz) |                                                              |\n|                                                              | [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)<br />[面试题 16.25. LRU 缓存](https://leetcode.cn/problems/lru-cache-lcci/) | [双向链表+hash](https://leetcode.cn/problems/lru-cache/solutions/2456294/tu-jie-yi-zhang-tu-miao-dong-lrupythonja-czgt) | 过期时间https://zhuanlan.zhihu.com/p/659625596<br/>线程安全（java）https://zhuanlan.zhihu.com/p/135936339 |\n|                                                              | [1171. 从链表中删去总和值为零的连续节点](https://leetcode.cn/problems/remove-zero-sum-consecutive-nodes-from-linked-list/) | 哈希+前缀和<br />[思路](https://leetcode.cn/problems/remove-zero-sum-consecutive-nodes-from-linked-list/solutions/2305659/javapython3qian-zhui-he-ha-xi-biao-yi-ci-6nya) |                                                              |\n|                                                              |                                                              |                                                              |                                                              |\n\n\n\n# [链表 - 反转系列](https://www.bilibili.com/video/BV1sd4y1x7KN/)\n\n## [206. 反转链表(HOT100)](https://leetcode.cn/problems/reverse-linked-list/)\n\n### 迭代\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* pre=nullptr;\n        ListNode* cur=head;\n        while(cur)\n        {\n            ListNode*nxt=cur->next;\n            cur->next=pre;\n            pre=cur;\n            cur=nxt;\n        }\n        return pre;\n    }\n};\n```\n\n### 递归\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n/*\n            第一轮出栈，head为5，head.next为空，返回5\n            第二轮出栈，head为4，head.next为5，执行head.next.next=head也就是5.next=4，\n                      把当前节点的子节点的子节点指向当前节点\n                      此时链表为1->2->3->4<->5，由于4与5互相指向，所以此处要断开4.next=null\n                      此时链表为1->2->3->4<-5\n                      返回节点5\n            第三轮出栈，head为3，head.next为4，执行head.next.next=head也就是4.next=3，\n                      此时链表为1->2->3<->4<-5，由于3与4互相指向，所以此处要断开3.next=null\n                      此时链表为1->2->3<-4<-5\n                      返回节点5\n            第四轮出栈，head为2，head.next为3，执行head.next.next=head也就是3.next=2，\n                      此时链表为1->2<->3<-4<-5，由于2与3互相指向，所以此处要断开2.next=null\n                      此时链表为1->2<-3<-4<-5\n                      返回节点5\n            第五轮出栈，head为1，head.next为2，执行head.next.next=head也就是2.next=1，\n                      此时链表为1<->2<-3<-4<-5，由于1与2互相指向，所以此处要断开1.next=null\n                      此时链表为1<-2<-3<-4<-5\n                      返回节点5\n            出栈完成，最终头节点5->4->3->2->1\n         */\n    ListNode* reverseList(ListNode* head) {\n       if(!head||!head->next)\n       {\n            return head;\n       }\n       ListNode* newHead=reverseList(head->next);\n       head->next->next=head;\n       head->next=nullptr;\n       return newHead;\n    }\n};\n```\n\n\n\n## [445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/)\n\n### 反转+两数相加（迭代）\n\n### 栈\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        stack<int>s1,s2;\n        while(l1)\n        {\n            s1.push(l1->val);\n            l1=l1->next;\n        }\n        while(l2)\n        {\n            s2.push(l2->val);\n            l2=l2->next;\n        }\n        int sum=0,carry=0;\n        ListNode* ans=nullptr;\n        while(!s1.empty()||!s2.empty()||carry)\n        {\n           \n            if(!s1.empty())\n            {\n                sum+=s1.top();\n                s1.pop();\n            }\n            if(!s2.empty())\n            {\n                sum+=s2.top();\n                s2.pop();\n            }\n            sum+=carry; \n            // cout<<sum<<endl;\n            carry=sum/10;\n            sum%=10;\n            ListNode* curnode=new ListNode(sum);\n            curnode->next=ans;\n            ans=curnode;\n            sum=0;\n        }\n        return ans;\n    }\n};\n```\n\n\n\n## \n\n## [430. 扁平化多级双向链表](https://leetcode.cn/problems/flatten-a-multilevel-doubly-linked-list/)\n\n## [LCR 028. 扁平化多级双向链表](https://leetcode.cn/problems/Qv1Da2/)\n\nhttps://leetcode.cn/problems/flatten-a-multilevel-doubly-linked-list/solutions/1014046/gong-shui-san-xie-yi-ti-shuang-jie-di-gu-9wfz\n\n### 迭代\n\n```c++\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* prev;\n    Node* next;\n    Node* child;\n};\n*/\n\nclass Solution {\npublic:\n\n    Node* flatten(Node* head) {\n        Node* dummy = new Node(0);\n        dummy->next = head;\n        while(head)\n        {\n            if(head->child)\n            {\n               Node* tmp=head->next;\n               Node* childStart=head->child ;\n               head->next=childStart;\n               childStart->prev=head;\n               head->child=nullptr;\n               Node* last=head;\n               while(last->next)last=last->next; \n               last->next=tmp;\n               if(tmp)tmp->prev=last;\n            }\n            head=head->next;\n        }\n\n        return dummy->next;\n    }\n};\n```\n\n### 递归\n\n```c++\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* prev;\n    Node* next;\n    Node* child;\n};\n*/\n\nclass Solution {\npublic:\n    Node* dfs(Node* head)\n    {\n\n        Node* last=head;\n        while(head)\n        {\n            if(!head->child)\n            {\n                last=head;\n                head=head->next;\n                \n            }\n            else\n            {\n                Node* rear=head->next;\n                Node* childStart=head->child;\n                Node* childEnd=dfs(head->child);\n                head->next=childStart;\n                childStart->prev=head;\n                head->child=nullptr;//记得消除child\n                childEnd->next=rear;\n                \n                if(rear)//rear可能是空\n                {\n                    rear->prev=childEnd;\n                }\n                last=childEnd;\n                head=rear;\n            }\n        }\n        return last;\n    }\n    Node* flatten(Node* head) {\n        dfs(head);\n        return head;\n    }\n};\n```\n\n## NC207 排序奇升偶降链表\n\n```c++\n/**\n * struct ListNode {\n *\tint val;\n *\tstruct ListNode *next;\n *\tListNode(int x) : val(x), next(nullptr) {}\n * };\n */\nclass Solution {\npublic:\n    /**\n     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可\n     *\n     * \n     * @param head ListNode类 \n     * @return ListNode类\n     */\n     vector<ListNode*> oddEvenList(ListNode* head) {\n        // if(!head)return nullptr;\n        ListNode* even=head->next;\n        ListNode*evenHead=even;\n        ListNode*odd=head;\n        while(even&&even->next)\n        {\n            odd->next=even->next;\n            odd=odd->next;\n            even->next=odd->next;\n            even=even->next;\n        }\n        odd->next=nullptr;\n        vector<ListNode*> ans;\n        ans.push_back(head);\n        ans.push_back(evenHead);\n        return ans;\n    }\n    ListNode* reverseList(ListNode* head) {\n        ListNode* pre=nullptr;\n        ListNode* cur=head;\n        while(cur)\n        {\n            ListNode*nxt=cur->next;\n            cur->next=pre;\n            pre=cur;\n            cur=nxt;\n        }\n        return pre;\n    }\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode* dummy=new ListNode(INT_MIN);\n        ListNode* rear=dummy;\n        while(list1&&list2)\n        {\n            if(list1->val<list2->val)\n            {\n                rear->next=list1;\n                list1=list1->next;\n            }\n            else\n            {\n                rear->next=list2;\n                list2=list2->next;\n            }\n            rear=rear->next;\n        }\n        rear->next=(list1?list1:list2);\n        return dummy->next;\n    }\n    ListNode* sortLinkedList(ListNode* head) {\n        \n        // write code here\n        if(!head||!head->next)\n        {\n            return head;\n        }\n        vector<ListNode*> allHead=oddEvenList(head);\n        allHead[1]=reverseList(allHead[1]);\n        return mergeTwoLists(allHead[0],allHead[1]);\n    }\n};\n```\n\n","tags":["加密文章tag"],"categories":["Algorithm"]},{"title":"前缀树（字典树）","url":"/2024/04/16/Trie/","content":"\n# 前缀树（字典树）\n\n## [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)\n\nhttps://leetcode.cn/problems/implement-trie-prefix-tree/solutions/721110/gong-shui-san-xie-yi-ti-shuang-jie-er-we-esm9\n\n### 二维数组\n\n```c++\nconst int N = 100086;\nint son[N][26],cnt[N],idx,n;\nclass Trie {\npublic:\n    Trie() {\n        memset(cnt,0,sizeof cnt);\n        memset(son,0,sizeof son);\n        idx = 0;\n    }\n    \n    void insert(string word) {\n        int p=0;\n        for(int i=0;i<word.size();i++)\n        {\n            int u=word[i]-'a';\n            if(!son[p][u])son[p][u]=++idx;\n            p=son[p][u];\n        }\n        cnt[p]++;\n    }\n    \n    bool search(string word) {\n        int p=0;\n        for(int i=0;i<word.size();i++)\n        {\n            int u=word[i]-'a';\n            if(!son[p][u])return false;\n            p=son[p][u];\n        }\n        return cnt[p];\n    }\n    \n    bool startsWith(string word) {\n        int p=0;\n        for(int i=0;i<word.size();i++)\n        {\n            int u=word[i]-'a';\n            if(!son[p][u])return false;\n            p=son[p][u];\n        }\n        return true;\n    }\n};\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie* obj = new Trie();\n * obj->insert(word);\n * bool param_2 = obj->search(word);\n * bool param_3 = obj->startsWith(prefix);\n */\n```\n\n### 指针\n\n```c++\nconst int N = 100086;\nint son[N][26],cnt[N],idx,n;\nclass Trie {\nprivate:\n    Trie* son[26];\n    bool isWord;\npublic:\n    Trie() {\n        isWord=false;\n        for(int i=0;i<26;i++)son[i]=nullptr;\n    }\n    //c++安全性\n    ~Trie()\n    {\n        for(int i = 0; i < 26 ; i++)\n        {\n            if(son[i] != nullptr) delete son[i];\n        }\n    }\n    void insert(string word) {\n        Trie* root=this;\n        for(int i=0;i<word.size();i++)\n        {\n            int u=word[i]-'a';\n            if(root->son[u]==nullptr)root->son[u]= new Trie();\n           root=root->son[u];\n        }\n        root->isWord=true;\n    }\n    \n    bool search(string word) {\n        Trie* root=this;\n        for(int i=0;i<word.size();i++)\n        {\n            int u=word[i]-'a';\n            if(root->son[u]==nullptr)return false;\n           root=root->son[u];\n        }\n        return root->isWord;\n    }\n    \n    bool startsWith(string word) {\n        Trie* root=this;\n        for(int i=0;i<word.size();i++)\n        {\n            int u=word[i]-'a';\n            if(root->son[u]==nullptr)return false;\n           root=root->son[u];\n        }\n        return true;\n    }\n};\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie* obj = new Trie();\n * obj->insert(word);\n * bool param_2 = obj->search(word);\n * bool param_3 = obj->startsWith(prefix);\n */\n```\n\n\n\n## [AC835. Trie字符串统计](https://www.acwing.com/file_system/file/content/whole/index/content/4363/)\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100086;\nint son[N][26],cnt[N],idx,n;\n\nvoid insert(string s)\n{\n\tint p=0;\n\tfor(int i=0;i<s.size();i++)\n\t{\n\t\tint u=s[i]-'a';\n\t\tif(!son[p][u])son[p][u]=++idx;\n\t\tp=son[p][u];\n\t}\n\tcnt[p]++;\n}\nint query(string s)\n{\n\tint p=0;\n\tfor(int i=0;i<s.size();i++)\n\t{\n\t\tint u=s[i]-'a';\n\t\tif(!son[p][u])return 0;\n\t\tp=son[p][u];\n\t}\n\treturn cnt[p];\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n\tcin>>n;\n\twhile(n--)\n\t{\n\t\tchar op;\n\t\tstring s1\n\t\tcin>>op;\n\t\tif(op=='I')\n\t\t{\n\t\t\tcin>>s1;\n\t\t\tinsert(s1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcin>>s1;\n\t\t\tcout<<query(s1)<<endl;\n\t\t}\n\t}\n    return 0;\n}\n\n```\n\n## [AC143. 最大异或对](https://www.acwing.com/file_system/file/content/whole/index/content/3694/)\n\n在给定的 N 个整数 中选出两个进行 xor（异或）运算，得到的结果最大是多少？\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100086;\nint son[3000000][2],cnt[N],idx,n;\nint a[N];\nvoid insert(int x)\n{\n\tint p=0;\n\tfor(int i=30;~i;i--)\n\t{\n\t\tint u=x>>i&1;\n\t\tif(!son[p][u])son[p][u]=++idx;\n\t\tp=son[p][u];\n\t\t//cout<<u<<endl;\n\t}\n}\nint query(int x)\n{\n\tint p=0,res=0;\n\tfor(int i=30;~i;i--)\n\t{\n\t\tint u=x>>i&1;\n\t\tif(son[p][!u])\n\t\t{\n\t\t\tp=son[p][!u];\n\t\t\tres+=1<<i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp=son[p][u];\n\t\t}\t\n\t}\n\treturn res;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i];\n\t\tinsert(a[i]);\n\t}\n\tint ans=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tans=max(query(a[i]),ans);\n//\t\tcout<<ans<<endl;\n\t}\n\tcout<<ans<<endl;\n    return 0;\n}\n\n```\n\n### [LCR 067. 数组中两个数的最大异或值](https://leetcode.cn/problems/ms70jA/)\n\n[421. 数组中两个数的最大异或值](https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/)\n\n指针\n\n```c++\nconst int N = 100086;\nclass Trie {\npublic:\n    Trie* son[2];\n    Trie() {\n\n        for(int i=0;i<2;i++)son[i]=nullptr;\n    }\n    //c++安全性\n    ~Trie()\n    {\n        for(int i = 0; i < 2 ; i++)\n        {\n            if(son[i] != nullptr) delete son[i];\n        }\n    }\n    void insert(int word) {\n        Trie* root=this;\n        for(int i=30;~i;i--)\n        {\n            int u=word>>i&1;\n            if(root->son[u]==nullptr)root->son[u]= new Trie();\n           root=root->son[u];\n        }\n\n    }\n    \n    int search(int word) {\n        Trie* root=this;\n        int sum=0;\n        for(int i=30;~i;i--)\n        {\n            int u=word>>i&1;\n\n            if(root->son[u^1])\n            {\n                root=root->son[!u];\n                sum+=1<<i;\n            }\n            else\n            {\n                root=root->son[u];\n            }\n           \n        }\n        return sum;\n    }\n    \n   \n};\nclass Solution {\npublic:\n\n    int findMaximumXOR(vector<int>& nums) {\n        Trie* trie = new Trie();\n        int n=nums.size();\n        if(n==1)return 0;\n        for(int i=0;i<n;i++)\n        {\n            trie->insert(nums[i]);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++)\n\t    {\n\t\t    ans=max(trie->search(nums[i]),ans);\n//\t\t    cout<<ans<<endl;\n\t    }\n        return ans;\n    }\n};\n```\n\n## [211. 添加与搜索单词 - 数据结构设计](https://leetcode.cn/problems/design-add-and-search-words-data-structure/)\n\nhttps://leetcode.cn/problems/design-add-and-search-words-data-structure/solutions/1054657/gong-shui-san-xie-yi-ti-shuang-jie-er-we-un94\n\n### 数组+dfs\n\n```c++\nconst int N = 1000086;\nint son[N][26],cnt[N],idx,n;\nclass WordDictionary {\npublic:\n    WordDictionary() {\n        memset(cnt,0,sizeof cnt);\n        memset(son,0,sizeof son);\n        idx = 0;\n    }\n    \n    void addWord(string word) {\n        int p=0;\n        for(int i=0;i<word.size();i++)\n        {\n            int u=word[i]-'a';\n            if(!son[p][u])son[p][u]=++idx;\n            p=son[p][u];\n        }\n        cnt[p]++;\n    }\n    \n    bool search(string word) {\n        return dfs(word,0,0);\n    }\n    bool dfs(string word,int p1,int cur)\n    {\n        if(cur==word.size())return cnt[p1];\n        if(word[cur]=='.')\n        {\n            for(int i=0;i<26;i++)\n            {\n                int p=son[p1][i];\n                if(p)\n                {\n                    if(dfs(word,p,cur+1))return true;\n                }\n            }\n        }\n        else\n        {\n           \n            int u=word[cur]-'a';\n            \n            int p=son[p1][u];\n            if(p)return dfs(word,p,cur+1);\n        \n        }\n        return false;\n    }\n};\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary* obj = new WordDictionary();\n * obj->addWord(word);\n * bool param_2 = obj->search(word);\n */\n```\n\n\n\n### 指针+dfs\n\n```c++\nconst int N = 1000086;\nint son[N][26],cnt[N],idx,n;\nclass Trie {\nprivate:\n    \npublic:\n    Trie* son[26];\n    bool isWord;\n    Trie() {\n        isWord=false;\n        for(int i=0;i<26;i++)son[i]=nullptr;\n    }\n    //c++安全性\n    ~Trie()\n    {\n        for(int i = 0; i < 26 ; i++)\n        {\n            if(son[i] != nullptr) delete son[i];\n        }\n    }\n    \n\n};\nclass WordDictionary {\npublic:\n    Trie* root;\n    WordDictionary() {\n       root= new Trie();\n    }\n    \n    void addWord(string word) {\n        Trie* node=root;\n        for(int i=0;i<word.size();i++)\n        {\n            int u=word[i]-'a';\n            if(node->son[u]==nullptr)node->son[u]= new Trie();\n           node=node->son[u];\n        }\n        node->isWord=true;\n    }\n    \n    bool search(string word) {\n        Trie* node=root;\n        return dfs(word,node,0);\n    }\n    bool dfs(string word,Trie* node,int cur)\n    {\n        if(cur==word.size())return node->isWord;\n        if(word[cur]=='.')\n        {\n            for(int i=0;i<26;i++)\n            {\n                Trie* p=node->son[i];\n                if(p)\n                {\n                    if(dfs(word,p,cur+1))return true;\n                }\n            }\n        }\n\n        else\n        {\n           \n            int u=word[cur]-'a';\n            \n            Trie* p=node->son[u];\n            if(p)return dfs(word,p,cur+1);\n        \n        }\n        return false;\n    }\n};\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary* obj = new WordDictionary();\n * obj->addWord(word);\n * bool param_2 = obj->search(word);\n */\n```\n\n\n\n### 数组+层序\n\n```c++\nconst int N = 1000086;\nint son[N][26],cnt[N],idx,n;\ntypedef pair<int,int >PII;\n\nclass WordDictionary {\npublic:\n    WordDictionary() {\n        memset(cnt,0,sizeof cnt);\n        memset(son,0,sizeof son);\n        idx = 0;\n    }\n    \n    void addWord(string word) {\n        int p=0;\n        for(int i=0;i<word.size();i++)\n        {\n            int u=word[i]-'a';\n            if(!son[p][u])son[p][u]=++idx;\n            p=son[p][u];\n        }\n        cnt[p]++;\n    }\n    \n    bool search(string word) {\n       queue<PII>q;\n       q.push({0,0});\n       for(int i=0;i<word.size();i++)\n       {\n            while(q.size()&&q.front().second == i)\n            {\n                auto it=q.front();\n                q.pop();\n                if(word[i]=='.')\n                {\n                    for(int j=0;j<26;j++)\n                    {\n                        if(son[it.first][j])\n                        {\n                            q.push({son[it.first][j],i+1});\n                        }\n                    }\n                }\n                else\n                {\n                    int u=word[i]-'a';\n                    if(son[it.first][u])\n                    {\n                        q.push({son[it.first][u],i+1});\n                    }\n                }\n            }\n            \n       }\n       while(q.size())\n        {\n            auto it=q.front();\n            q.pop();\n            if(cnt[it.first])return true;\n        }\n         return false;\n    }\n    \n};\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary* obj = new WordDictionary();\n * obj->addWord(word);\n * bool param_2 = obj->search(word);\n */\n```\n\n## [676. 实现一个魔法字典](https://leetcode.cn/problems/implement-magic-dictionary/)\n\n### 数组+dfs\n\n```c++\n\nclass MagicDictionary {\npublic:\n    vector<string> words;\n    MagicDictionary() {\n\n    }\n\n    void buildDict(vector<string> dictionary) {\n        words = dictionary;\n    }\n   \n    bool search(string searchWord) {\n        for(auto word:words)\n        {\n            if(word.size()!=searchWord.size())continue;\n            int cnt=0;\n            for(int i=0;i<word.size();i++)\n            {\n                if(word[i]!=searchWord[i])\n                {\n                    cnt++;\n                    if(cnt>1)break;\n                }\n            }\n            if(cnt==1)return true;\n        }\n        return false;\n    }\n};\n\n/**\n * Your MagicDictionary object will be instantiated and called as such:\n * MagicDictionary* obj = new MagicDictionary();\n * obj->buildDict(dictionary);\n * bool param_2 = obj->search(searchWord);\n */\n```\n\n### 模拟\n\n```c++\n\nclass MagicDictionary {\npublic:\n    vector<string> words;\n    MagicDictionary() {\n\n    }\n\n    void buildDict(vector<string> dictionary) {\n        words = dictionary;\n    }\n   \n    bool search(string searchWord) {\n        for(auto word:words)\n        {\n            if(word.size()!=searchWord.size())continue;\n            int cnt=0;\n            for(int i=0;i<word.size();i++)\n            {\n                if(word[i]!=searchWord[i])\n                {\n                    cnt++;\n                    if(cnt>1)break;\n                }\n            }\n            if(cnt==1)return true;\n        }\n        return false;\n    }\n};\n\n/**\n * Your MagicDictionary object will be instantiated and called as such:\n * MagicDictionary* obj = new MagicDictionary();\n * obj->buildDict(dictionary);\n * bool param_2 = obj->search(searchWord);\n */\n```\n\n## [720. 词典中最长的单词](https://leetcode.cn/problems/longest-word-in-dictionary/)\n\n### 数组\n\n```c++\nconst int N = 100086;\nint son[N][26],cnt[N],idx,n;\nclass Solution {\npublic:\n    void insert(string word) {\n        int p=0;\n        for(int i=0;i<word.size();i++)\n        {\n            int u=word[i]-'a';\n            if(!son[p][u])son[p][u]=++idx;\n            p=son[p][u];\n        }\n        cnt[p]++;\n    }\n    \n    bool search(string word) {\n        int p=0;\n        for(int i=0;i<word.size();i++)\n        {\n            int u=word[i]-'a';\n            if(!son[p][u]||!cnt[son[p][u]])return false;\n            p=son[p][u];\n        }\n        return cnt[p];\n    }\n    string longestWord(vector<string>& words) {\n        memset(cnt,0,sizeof cnt);\n        memset(son,0,sizeof son);\n        idx = 0;\n        string ans=\"\";\n        for(auto s:words)\n        {\n            insert(s);\n        }\n        for(auto s:words)\n        {\n            if(search(s)&&(ans.size()<s.size()||(s.size()==ans.size()&&ans>s)))\n            {\n                ans=s;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n### set+sort模拟\n\n思路在官解\n\n```c++\nclass Solution {\npublic:\n    static bool cmp (const string & a, const string & b) \n        {\n            if (a.size() != b.size()) \n            {\n                return a.size() < b.size();\n            } else \n            {\n                return a > b;\n            }\n        }\n    string longestWord(vector<string>& words) {\n        sort(words.begin(), words.end(), &cmp);\n        string longest = \"\";\n        unordered_set<string> cnt;\n        cnt.emplace(\"\");\n        for (auto & word : words) \n        {\n\n            if (cnt.count(word.substr(0, word.size() - 1))) \n            {\n                cnt.emplace(word);\n                longest = word;\n            }\n        }\n        return longest;\n    }\n};\n```\n\n### 指针（以前写的）\n\n```c++\nclass Trie {\n\npublic:\n    bool isEnd;\n    Trie* next[26];\n    Trie()\n    {\n        isEnd = false;\n        memset(next, 0, sizeof(next));\n    }\n    void insert(string word) {\n        Trie* node=this;\n        for(int i=0;i<word.size();i++)\n        {\n            if(!node->next[word[i]-'a'])\n            {\n                node->next[word[i]-'a']=new Trie();\n            }\n            node=node->next[word[i]-'a'];\n        }\n        node->isEnd=true;\n    }\n    \n    bool search(string word) {\n        Trie* node=this;\n        for(int i=0;i<word.size();i++)\n        {\n            if(!node->next[word[i]-'a']||(!node->next[word[i]-'a']->isEnd)) //题意必须连续\n            {\n                return false;\n            }\n            node=node->next[word[i]-'a'];\n        }\n        return node&&node->isEnd;\n\n    }\n};\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie* obj = new Trie();\n * obj->insert(word);\n * bool param_2 = obj->search(word);\n * bool param_3 = obj->startsWith(prefix);\n */\nclass Solution {\n    \npublic:\n    \n    string longestWord(vector<string>& words) \n    {\n        //sort(words);\n        Trie* trie = new Trie();\n        string ans = \"\";\n        \n        for (string s:words) \n        {\n            trie->insert(s);\n            \n        }\n        for (string s:words) \n        {\n            if(trie->search(s) &&(ans.size()<s.size() || (s.size()==ans.size()&&ans>s)))\n            {\n                ans=s;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n## [677. 键值映射](https://leetcode.cn/problems/map-sum-pairs/)\n\n### Trie+dfs+hash\n\n注意umap清空\n\n```c++\nconst int N = 100086;\nint son[N][26],cnt[N],idx,n;\n\nclass MapSum {\npublic:\n    MapSum() {\n        memset(cnt,0,sizeof cnt);\n        memset(son,0,sizeof son);\n        idx = 0;\n    }\n    unordered_map<string,int> umap;\n    void insert(string word, int val) {\n        int p=0;\n        int delta = val;\n        if(umap.count(word)){\n            delta -=umap[word];\n        }\n        umap[word]=val;\n        // cout<<delta<<endl;\n        for(int i=0;i<word.size();i++)\n        {\n            int u=word[i]-'a';\n            if(!son[p][u])son[p][u]=++idx;\n            p=son[p][u];\n            cnt[p]+=delta;\n        }\n        \n    }\n    \n    int sum(string word) {\n        int p=0;\n        for(int i=0;i<word.size();i++)\n        {\n            int u=word[i]-'a';\n            if(!son[p][u])return 0;\n            p=son[p][u];\n        }\n        return cnt[p];\n    }\n};\n\n/**\n * Your MapSum object will be instantiated and called as such:\n * MapSum* obj = new MapSum();\n * obj->insert(key,val);\n * int param_2 = obj->sum(prefix);\n */\n```\n\n### Trie+dfs\n\n```c++\nconst int N = 100086;\nint son[N][26],cnt[N],idx,n;\nclass MapSum {\npublic:\n    MapSum() {\n        memset(cnt,0,sizeof cnt);\n        memset(son,0,sizeof son);\n        idx = 0;\n    }\n    \n    void insert(string word, int val) {\n        int p=0;\n        for(int i=0;i<word.size();i++)\n        {\n            int u=word[i]-'a';\n            if(!son[p][u])son[p][u]=++idx;\n            p=son[p][u];\n        }\n        cnt[p]=val;\n    }\n    int dfs(int p)\n    {\n        // if(!p)return 0;\n        int res=cnt[p];\n        for(int i=0;i<26;i++)\n        {\n            if(son[p][i])res+=dfs(son[p][i]);\n        }\n        return res;\n    }\n    int sum(string word) {\n        int p=0;\n        for(int i=0;i<word.size();i++)\n        {\n            int u=word[i]-'a';\n            if(!son[p][u])return 0;\n            p=son[p][u];\n        }\n        return dfs(p);\n    }\n};\n\n/**\n * Your MapSum object will be instantiated and called as such:\n * MapSum* obj = new MapSum();\n * obj->insert(key,val);\n * int param_2 = obj->sum(prefix);\n */\n```\n\n## [212. 单词搜索 II](https://leetcode.cn/problems/word-search-ii/)\n\n### Trie+dfs\n\nhttps://leetcode.cn/problems/word-search-ii/solutions/1000331/gong-shui-san-xie-yi-ti-shuang-jie-hui-s-am8f\nisend变成存整个word\n代码参考评论第三页\n\n```c++\n\nint dir[4][2]={{0,-1},{-1,0},{0,1},{1,0}};\nclass Trie {\nprivate:\n    \npublic:\n    Trie* son[26];\n    string s;\n    Trie() {\n\n        for(int i=0;i<26;i++)son[i]=nullptr;\n    }\n    //c++安全性\n    ~Trie()\n    {\n        for(int i = 0; i < 26 ; i++)\n        {\n            if(son[i] != nullptr) delete son[i];\n        }\n    }\n    void insert(string word) {\n        Trie* root=this;\n        for(int i=0;i<word.size();i++)\n        {\n            int u=word[i]-'a';\n            if(root->son[u]==nullptr)root->son[u]= new Trie();\n           root=root->son[u];\n        }\n        root->s=word;\n    }\n    \n};\nclass Solution {\npublic:\n    unordered_map<string, int> mp;\n    // vector<string>ans;\n    unordered_set<string> ans;\n    Trie* root=new Trie();\n    int dp[13][13] = {0};\n    void dfs(vector<vector<char>>& board, Trie * node, int x,int y)\n    {\n        int dx=0,dy=0;\n        int m=board.size();\n        int n=board[0].size();\n        if(node->s!= \"\"){\n            ans.insert(node->s);\n        }\n\t\tif(x>=m||y>=n||x<0||y<0)\n\t\t{\n\t\t\treturn;\n\t\t}\n        // if(u==word.size()-1&&board[x][y]==word[u])return true;//防止只有一个格子\n        for(int i=0;i<4;i++)\n        {\n            dx=x+dir[i][0];\n            dy=y+dir[i][1];\n            \n            if(dx>=0&&dx<m&&dy>=0&&dy<n&&!dp[dx][dy])\n            {\n                int u=board[dx][dy]-'a';\n                if(node->son[u])\n                {\n                    dp[dx][dy]=1;\n                    \n                    dfs(board,node->son[u],dx,dy);\n                    dp[dx][dy]=0;\n                }\n                \n                \n            }\n        }\n\n    }\n\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\n        int m=board.size();\n        int n=board[0].size();\n\n        for(auto w:words)root->insert(w);\n        \n        for(int i=0;i<m;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                int u=board[i][j]-'a';\n                if(root->son[u])\n                {\n                    dp[i][j]=1;\n                \n                    dfs(board,root->son[u],i,j);\n                    \n                    dp[i][j]=0;\n                }\n                \n               \n            }\n        }\n        return vector<string>(ans.begin(), ans.end());\n    }\n};\n```\n\n## [LCR 063. 单词替换](https://leetcode.cn/problems/UhWRSj/)(648)\n\n[648. 单词替换](https://leetcode.cn/problems/replace-words/)\n\n板子题，注意search改动主要是\n\n```c++\n string search(string word) {\n        int p=0;\n        for(int i=0;i<word.size();i++)\n        {\n            int u=word[i]-'a';\n            if(!son[p][u])break;//\n            if(cnt[son[p][u]])return word.substr(0, i + 1);//\n            p=son[p][u];\n        }\n        return word;//\n    }\n```\n\n\n\n## [3093. 最长公共后缀查询](https://leetcode.cn/problems/longest-common-suffix-queries/)\n\n### 指针（数组超时）\n\nhttps://www.bilibili.com/video/BV1wr421h7xY/?spm_id_from=333.999.0.0&vd_source=446947e89517447be9aac68199196f4f\n\n```c++\n\nconst int N = 500086;\nclass Trie {\nprivate:\n    \npublic:\n    Trie* son[26];\n    pair<int,int>cnt;\n    Trie() {\n    \n        for(int i=0;i<26;i++)son[i]=nullptr;\n    }\n    //c++安全性\n    ~Trie()\n    {\n        for(int i = 0; i < 26 ; i++)\n        {\n            if(son[i] != nullptr) delete son[i];\n        }\n    }    \n    void insert(string word,int id) \n    {\n        Trie* root=this;\n        if(root->cnt.first==0||root->cnt.first > word.size())root->cnt = {word.size(), id};\n        for(int i=word.size()-1;i>=0;i--)\n        {\n            int u=word[i]-'a';\n            if(!root->son[u])root->son[u]= new Trie();\n            root=root->son[u];\n            if(root->cnt.first==0||root->cnt.first > word.size())root->cnt=make_pair(word.size(), id);\n        }\n        \n    }\n    void search(string word, vector<int>&ans) \n    {\n        Trie* root=this;\n        for(int i=word.size()-1;i>=0;i--)\n        {\n            int u=word[i]-'a';\n            if(!root->son[u])break;\n            root=root->son[u];\n        }\n        ans.push_back(root->cnt.second);\n    } \n};\nclass Solution {\npublic:\n    vector<int>ans;\n    \n    // pair<int,int>cnt[N];\n\n    vector<int> stringIndices(vector<string>& wordsContainer, vector<string>& wordsQuery) {\n        Trie* root=new Trie();\n        int lenn=wordsContainer.size();\n        for(int i=0;i<lenn;i++)\n        {\n            root->insert(wordsContainer[i],i);\n        }\n        for(auto str:wordsQuery)\n        {\n            root->search(str,ans);\n        }\n        return ans;\n    }\n};\n```\n\n## [440. 字典序的第K小数字](https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/)\n\nhttps://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/solutions/1360662/by-ac_oier-m3zl\n\n```c++\nclass Solution {\npublic:\n    // 根据 前缀 和 限制 n 查找该前缀下有多少可能值\n    int getcnt(int x,int limit)\n    {\n        int ans=0;\n        string a = to_string(x), b = to_string(limit);\n        int n=a.size(),m=b.size(),k=m-n;\n        int u=stoi(b.substr(0,n));\n        for (int i = 0; i < k; ++i) ans += pow(10, i);\n        if (x < u) ans += pow(10, k);\n        else if(x==u)ans+=limit-x*pow(10,k)+1;\n        return ans;\n    }\n    int findKthNumber(int n, int k) {\n        int ans=1;\n        while(k>1)\n        {\n            int cnt=getcnt(ans,n);\n            if(cnt<k)\n            {\n                ans+=1;\n                k-=cnt;\n\n            }\n            else\n            {\n                ans*=10;\n                k-=1;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n","tags":["加密文章tag"],"categories":["Algorithm"]},{"title":"滑动窗口+双指针+哈希","url":"/2024/04/16/slidingwindow/","content":"\n# 滑动窗口\n\n| [滑动窗口](https://www.bilibili.com/video/BV1hd4y1r7Gq/) | [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/) | [滑窗](https://leetcode.cn/problems/minimum-size-subarray-sum/solutions/306066/javade-jie-fa-ji-bai-liao-9985de-yong-hu-by-sdwwld) <br />[前缀和+二分（用vector超时](https://leetcode.cn/problems/minimum-size-subarray-sum/solutions/306066/javade-jie-fa-ji-bai-liao-9985de-yong-hu-by-sdwwld) | [额外需求：打印出所有满足条件的子序列](https://leetcode.cn/problems/minimum-size-subarray-sum/solutions/2401649/e-wai-xu-qiu-da-yin-chu-suo-you-man-zu-t-lkif) |            |\n| -------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------- |\n|                                                          | [LCR 180. 文件组合](https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/description/) | 209版 滑动窗口<br/>注意r<=target/2+1                         | [数学](https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solutions/128296/mian-shi-ti-57-ii-he-wei-sde-lian-xu-zheng-shu-x-2) |            |\n|                                                          | [1658. 将 x 减到 0 的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/) | [正向，逆向](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/solutions/2048811/ni-xiang-si-wei-pythonjavacgo-by-endless-b4jt) | 前缀和+hash<br/>两数之和升级                                 |            |\n|                                                          | [713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/) | 滑窗，板子<br/>二分和209思路一样                             | 方案数                                                       |            |\n| 中位数                                                   | [480. 滑动窗口中位数](https://leetcode.cn/problems/sliding-window-median/) | [滑窗+二分](https://leetcode.cn/problems/sliding-window-median/description/comments/772331) | [优先队列，思路参考（评论指出一个bug](https://leetcode.cn/problems/sliding-window-median/solutions/589213/feng-xian-dui-chong-shuang-dui-dui-ding-hq1dt/comments/1902043) |            |\n|                                                          | [295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/) | [进阶](https://leetcode.cn/problems/find-median-from-data-stream/solutions/847885/java-cong-tou-shi-xian-dui-heap-by-docke-fxi9)<br/>类似480，官解 |                                                              | **HOT100** |\n| 两个左指针                                               | [930. 和相同的二元子数组](https://leetcode.cn/problems/binary-subarrays-with-sum/) | 前缀+hash                                                    | 滑窗，两个指针（官解）992低级版                              |            |\n|                                                          | [992. K 个不同整数的子数组](https://leetcode.cn/problems/subarrays-with-k-different-integers/) | [滑窗](https://leetcode.cn/problems/subarrays-with-k-different-integers/solutions/598337/miao-dong-xi-lie-xiang-jie-shuang-zhi-zh-9k8w)<br />K个不同整数的子数组 = 不大于k个不同整数的子数组 - 不大于k-1个不同整数的子数组 |                                                              |            |\n| 2                                                        | [395. 至少有 K 个重复字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/description/) | [滑动窗口](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/solutions/623888/bao-mu-ji-jiao-cheng-hua-dong-chuang-kou-2cdf) | [递归](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/solutions/623991/jie-ben-ti-bang-zhu-da-jia-li-jie-di-gui-obla) |            |\n|                                                          | [1004. 最大连续 1 的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/) | 滑窗or 二分+前缀和                                           |                                                              |            |\n|                                                          | [424. 替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/description/) | 与1004区别，判定不在窗口条件while(maxx+k<r-l+1)              |                                                              |            |\n|                                                          | [1208. 尽可能使字符串相等](https://leetcode.cn/problems/get-equal-substrings-within-budget/submissions/) | 类似424，1004                                                |                                                              |            |\n| 定长                                                     | [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/) | 不管是否符合条件l右移                                        | 定长                                                         | **HOT100** |\n|                                                          | [567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/description/) | 438改一下返回true false                                      |                                                              |            |\n|                                                          | [30. 串联所有单词的子串](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/) | [438升级](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/solutions/2694714/duo-zhong-hua-dong-chuang-kou-by-cool-ar-uhw2) | 固定窗口大小，用r作为固定，一定要2个hashmap，因为l再次遍历的时候需要的是words给出的umap<br/>s =<br/>\"dddddddddddd\"<br/>words =<br/>[\"dddd\",\"dddd\"] |            |\n|                                                          | [2841. 几乎唯一子数组的最大和](https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/)<br />[2461. 长度为 K 子数组中的最大和](https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/) |                                                              |                                                              |            |\n|                                                          |                                                              |                                                              |                                                              |            |\n|                                                          | [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/) | s =<br/>\"bba\"<br/>t =<br/>\"ab\"<br/>不能用umap.count判断      |                                                              | **HOT100** |\n|                                                          | [面试题 17.18. 最短超串](https://leetcode.cn/problems/shortest-supersequence-lcci/description/) | 76                                                           |                                                              |            |\n| 3                                                        | [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)<br />[LCR 167. 招式拆解 I](https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/description/) | [1.滑窗， hash记录l移动的位置](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solution/xia-biao-zong-suan-cuo-qing-kan-zhe-by-e-iaks/)，2.while循环移动l<br />3.衍生 评论，（有两种理解https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/795144/li-yong-mapji-lu-yuan-su-shang-ci-chu-xi-sp81<br /> | 最长                                                         | **HOT100** |\n|                                                          | [386 · 最多有k个不同字符的最长子字符串](https://www.lintcode.com/problem/386/description?showListFe=true&page=8&ordering=id&pageSize=50)<br />[340. 至多包含 K 个不同字](https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters) | lc3的特殊版                                                  |                                                              |            |\n|                                                          | [928 · 最多有两个不同字符的最长子串](https://www.lintcode.com/problem/928/)<br />[159. 至多包含两个不同字](https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters) | lc340 k=2版                                                  |                                                              |            |\n|                                                          | [2962. 统计最大元素出现至少 K 次的子数组](https://leetcode.cn/problems/count-subarrays-where-max-element-appears-at-least-k-times/) |                                                              |                                                              |            |\n| 4                                                        | [LCR 183. 望远镜中最高的海拔](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/description/)<br />[239. 滑动窗口最大值](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/description/) | https://leetcode.cn/problems/sliding-window-maximum/solutions/2361228/239-hua-dong-chuang-kou-zui-da-zhi-dan-d-u6h0 |                                                              | **HOT100** |\n|                                                          | [1438. 绝对差不超过限制的最长连续子数组](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/description/) | 类239<br />单调队列                                          | multiset                                                     |            |\n| 周赛（排序+滑窗）                                        | [2294. 划分数组使最大差为 K](https://leetcode.cn/problems/partition-array-such-that-maximum-difference-is-k/) |                                                              |                                                              |            |\n|                                                          | [2779. 数组的最大美丽值](https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/) |                                                              |                                                              |            |\n\n## 386 · 最多有k个不同字符的最长子字符串\n\n```c++\nclass Solution {\npublic:\n    /**\n     * @param s: A string\n     * @param k: An integer\n     * @return: An integer\n     */\n    int lengthOfLongestSubstringKDistinct(string &s, int k) {\n        // write your code here\n        int l=0,r=0;\n        unordered_map<char,int>umap;\n        int ans=0;\n        while(r<s.size())\n        {\n            umap[s[r]]++;\n            while(umap.size()>k)\n            {\n                umap[s[l]]--;\n                if(umap[s[l]]==0)\n                {\n                    umap.erase(s[l]);\n                }\n                l++;\n            }\n            ans=max(ans,r-l+1);\n            r++;\n        }\n        return ans;\n    }\n};\n```\n\n# 双指针\n\n| 双指针     | [283. 移动零](https://leetcode.cn/problems/move-zeroes/)     | HOT100                                                       |                                                              |\n| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n|            | [349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/) |                                                              | hash<br/>面试官会先问：两个数组求交集，怎么求？以及说一下时间复杂度（不允许使用编程语言自带的交集功能）O(M+N)。答完之后再问：如果两个数组都是非递减的，又应该怎么求？时间复杂度多少？(双指针O(M+N)) |\n|            | [14. 最长公共前缀](https://leetcode.cn/problems/longest-common-prefix/) |                                                              | 二分（O(mnlogm)） or 纵向比较（O(MN)）                       |\n|            | [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/) | **HOT100**                                                   | https://leetcode.cn/problems/container-with-most-water/solutions/94102/on-shuang-zhi-zhen-jie-fa-li-jie-zheng-que-xing-tu |\n|            | [面试题 16.06. 最小差](https://leetcode.cn/problems/smallest-difference-lcci/) |                                                              | 排序+双指针（类似11                                          |\n| 3指针      | [15. 三数之和](https://leetcode.cn/problems/3sum/)           | **HOT100**                                                   | [去重](https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#思路) |\n|            | [18. 四数之和](https://leetcode.cn/problems/4sum/)           |                                                              | 15进阶，[有坑](https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF) |\n|            | [611. 有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/) |                                                              | [参考](https://leetcode.cn/problems/valid-triangle-number/solutions/914449/gong-shui-san-xie-yi-ti-san-jie-jian-dan-y1we) |\n|            | [16. 最接近的三数之和](https://leetcode.cn/problems/3sum-closest/) | 15改一下就行                                                 | 常数级优化：加了两个优化，但感觉写起来很怪，循环条件改成i<n-2<br/>https://leetcode.cn/problems/3sum-closest/solutions/2337801/ji-zhi-you-hua-ji-yu-san-shu-zhi-he-de-z-qgqi |\n|            | [75. 颜色分类](https://leetcode.cn/problems/sort-colors/)    | [3指针](https://leetcode.cn/problems/sort-colors/solutions/71322/kuai-su-pai-xu-partition-guo-cheng-she-ji-xun-huan) |                                                              |\n| 合并数组   | [88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/) | **HOT100**                                                   | 倒序进行填充，注意m和n表示长度要减1，表示索引。最后n可能会有剩余 |\n|            |                                                              | 进阶：合并k个有序数组<br />类似：[23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/) | https://leetcode.cn/problems/merge-k-sorted-lists/description/ |\n|            |                                                              | 去重<br />[26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/) | https://blog.csdn.net/he_wen_jie/article/details/105049024   |\n|            | [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/) |                                                              |                                                              |\n| 反转字符串 | [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)<br />[LCR 181. 字符串中的单词反转](https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/) | 直接反转，看下写法<br />百度一面，变形：保留中间所有空格（见笔记） | 快慢指针+反转整个+反转单词<br/>https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html#思路 |\n|            | [557. 反转字符串中的单词 III](https://leetcode.cn/problems/reverse-words-in-a-string-iii/) | 344升级                                                      | 异或                                                         |\n|            | [344. 反转字符串](https://leetcode.cn/problems/reverse-string/) |                                                              |                                                              |\n|            | [541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/) |                                                              | 让 i += (2 * k)，i 每次移动 2 * k 就可以了                   |\n| 反转       | [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)  | **HOT100**                                                   | 数学，官解 :要让bk/n为整数，所以lcm（n,k）=bk，要求的是n/b<br />反转 |\n| 字符串     | [165. 比较版本号](https://leetcode.cn/problems/compare-version-numbers/) |                                                              | 按点分割                                                     |\n\n# 哈希\n\n|          | [1. 两数之和](https://leetcode.cn/problems/two-sum/)         | HOT100     | [面试变形](https://blog.csdn.net/chemistryer/article/details/133067354?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22133067354%22%2C%22source%22%3A%22chemistryer%22%7D)：该数组有重复数字，需要输出所有符合要求的数字对 |\n| -------- | ------------------------------------------------------------ | ---------- | ------------------------------------------------------------ |\n|          | [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/) | HOT100     |                                                              |\n|          | [242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/) |            | 排序orhash                                                   |\n|          | [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/) | HOT100     | dp<br />[并查集2](https://leetcode.cn/problems/longest-consecutive-sequence/solutions/1176496/xiao-bai-lang-ha-xi-ji-he-ha-xi-biao-don-j5a2)<br/>并查集<br/>哈希表作为 Parent 数组，遍历数组中元素 num --映射为--> num + 1。<br/>findParent 函数中，路径压缩方法（递归查询）优化父节点查询效率。 |\n|          | [383. 赎金信](https://leetcode.cn/problems/ransom-note/)     |            |                                                              |\n| 字符串   | [205. 同构字符串](https://leetcode.cn/problems/isomorphic-strings/) |            | 官解                                                         |\n|          | [290. 单词规律](https://leetcode.cn/problems/word-pattern/)  |            |                                                              |\n| 设计     | [380. O(1) 时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/) |            | [评论](https://leetcode.cn/problems/insert-delete-getrandom-o1/solutions/1411578/o1-shi-jian-cha-ru-shan-chu-he-huo-qu-su-rlz2) |\n|          | [381. O(1) 时间插入、删除和获取随机元素 - 允许重复](https://leetcode.cn/problems/insert-delete-getrandom-o1-duplicates-allowed/) |            | https://leetcode.cn/problems/insert-delete-getrandom-o1-duplicates-allowed/solutions/45056/c-ha-xi-ti-jie-by-da-li-wang-2<br/>https://leetcode.cn/problems/insert-delete-getrandom-o1-duplicates-allowed/solutions/467892/c-unordered_multimapjie-fa-by-vclip 评论multiplemap |\n|          | [202. 快乐数](https://leetcode.cn/problems/happy-number/)    |            | 快慢指针or hash 官解                                         |\n| 原地hash | [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/) | HOT100     | [原地hash](https://leetcode.cn/problems/first-missing-positive/solutions/7703/tong-pai-xu-python-dai-ma-by-liweiwei1419) |\n|          | [287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/) | **HOT100** | 二分 or [快慢指针（类似142）](https://leetcode.cn/problems/find-the-duplicate-number/solutions/2869190/xun-zhao-zhong-fu-shu-qi-fa-shi-fang-fa-qptqj) or 原地哈希（需要修改数组） |\n|          | [442. 数组中重复的数据](https://leetcode.cn/problems/find-all-duplicates-in-an-array/) |            | hash（可解决k个） or 正负 or 原地交换（[官解](https://leetcode.cn/problems/find-all-duplicates-in-an-array/solutions/1473718/shu-zu-zhong-zhong-fu-de-shu-ju-by-leetc-782l)）<br /> |\n|          | [LCR 120. 寻找文件副本](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/) |            | 原地交换                                                     |\n|          | [448. 找到所有数组中消失的数字](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/) |            | 正负（和442类似                                              |\n|          |                                                              |            |                                                              |\n|          |                                                              |            |                                                              |\n|          |                                                              |            |                                                              |\n|          |                                                              |            |                                                              |\n|          |                                                              |            |                                                              |\n|          |                                                              |            |                                                              |\n","tags":["加密文章tag"],"categories":["Algorithm"]},{"title":"滑动窗口+双指针+哈希","url":"/2024/04/16/stack/","content":"\n# 滑动窗口\n\n| [滑动窗口](https://www.bilibili.com/video/BV1hd4y1r7Gq/) | [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/) | [滑窗](https://leetcode.cn/problems/minimum-size-subarray-sum/solutions/306066/javade-jie-fa-ji-bai-liao-9985de-yong-hu-by-sdwwld) <br />[前缀和+二分（用vector超时](https://leetcode.cn/problems/minimum-size-subarray-sum/solutions/306066/javade-jie-fa-ji-bai-liao-9985de-yong-hu-by-sdwwld) | [额外需求：打印出所有满足条件的子序列](https://leetcode.cn/problems/minimum-size-subarray-sum/solutions/2401649/e-wai-xu-qiu-da-yin-chu-suo-you-man-zu-t-lkif) |            |\n| -------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------- |\n|                                                          | [LCR 180. 文件组合](https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/description/) | 209版 滑动窗口<br/>注意r<=target/2+1                         | [数学](https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solutions/128296/mian-shi-ti-57-ii-he-wei-sde-lian-xu-zheng-shu-x-2) |            |\n|                                                          | [1658. 将 x 减到 0 的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/) | [正向，逆向](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/solutions/2048811/ni-xiang-si-wei-pythonjavacgo-by-endless-b4jt) | 前缀和+hash<br/>两数之和升级                                 |            |\n|                                                          | [713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/) | 滑窗，板子<br/>二分和209思路一样                             | 方案数                                                       |            |\n| 中位数                                                   | [480. 滑动窗口中位数](https://leetcode.cn/problems/sliding-window-median/) | [滑窗+二分](https://leetcode.cn/problems/sliding-window-median/description/comments/772331) | [优先队列，思路参考（评论指出一个bug](https://leetcode.cn/problems/sliding-window-median/solutions/589213/feng-xian-dui-chong-shuang-dui-dui-ding-hq1dt/comments/1902043) |            |\n|                                                          | [295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/) | [进阶](https://leetcode.cn/problems/find-median-from-data-stream/solutions/847885/java-cong-tou-shi-xian-dui-heap-by-docke-fxi9)<br/>类似480，官解 |                                                              | **HOT100** |\n| 两个左指针                                               | [930. 和相同的二元子数组](https://leetcode.cn/problems/binary-subarrays-with-sum/) | 前缀+hash                                                    | 滑窗，两个指针（官解）992低级版                              |            |\n|                                                          | [992. K 个不同整数的子数组](https://leetcode.cn/problems/subarrays-with-k-different-integers/) | [滑窗](https://leetcode.cn/problems/subarrays-with-k-different-integers/solutions/598337/miao-dong-xi-lie-xiang-jie-shuang-zhi-zh-9k8w)<br />K个不同整数的子数组 = 不大于k个不同整数的子数组 - 不大于k-1个不同整数的子数组 |                                                              |            |\n| 2                                                        | [395. 至少有 K 个重复字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/description/) | [滑动窗口](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/solutions/623888/bao-mu-ji-jiao-cheng-hua-dong-chuang-kou-2cdf) | [递归](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/solutions/623991/jie-ben-ti-bang-zhu-da-jia-li-jie-di-gui-obla) |            |\n|                                                          | [1004. 最大连续 1 的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/) | 滑窗or 二分+前缀和                                           |                                                              |            |\n|                                                          | [424. 替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/description/) | 与1004区别，判定不在窗口条件while(maxx+k<r-l+1)              |                                                              |            |\n|                                                          | [1208. 尽可能使字符串相等](https://leetcode.cn/problems/get-equal-substrings-within-budget/submissions/) | 类似424，1004                                                |                                                              |            |\n| 3                                                        | [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/) | 不管是否符合条件l右移                                        | 定长                                                         | **HOT100** |\n|                                                          | [567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/description/) | 438改一下返回true false                                      |                                                              |            |\n|                                                          | [30. 串联所有单词的子串](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/) | [438升级](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/solutions/2694714/duo-zhong-hua-dong-chuang-kou-by-cool-ar-uhw2) | 固定窗口大小，用r作为固定，一定要2个hashmap，因为l再次遍历的时候需要的是words给出的umap<br/>s =<br/>\"dddddddddddd\"<br/>words =<br/>[\"dddd\",\"dddd\"] |            |\n|                                                          | [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/) | s =<br/>\"bba\"<br/>t =<br/>\"ab\"<br/>不能用umap.count判断      |                                                              | **HOT100** |\n|                                                          | [面试题 17.18. 最短超串](https://leetcode.cn/problems/shortest-supersequence-lcci/description/) | 76                                                           |                                                              |            |\n| 3                                                        | [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)<br />[LCR 167. 招式拆解 I](https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/description/) | [1.滑窗， hash记录l移动的位置](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solution/xia-biao-zong-suan-cuo-qing-kan-zhe-by-e-iaks/)，2.while循环移动l<br />3.衍生 评论，（有两种理解https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/795144/li-yong-mapji-lu-yuan-su-shang-ci-chu-xi-sp81<br /> | 最长                                                         | **HOT100** |\n|                                                          | [386 · 最多有k个不同字符的最长子字符串](https://www.lintcode.com/problem/386/description?showListFe=true&page=8&ordering=id&pageSize=50)<br />[340. 至多包含 K 个不同字](https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters) | lc3的特殊版                                                  |                                                              |            |\n|                                                          | [928 · 最多有两个不同字符的最长子串](https://www.lintcode.com/problem/928/)<br />[159. 至多包含两个不同字](https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters) | lc340 k=2版                                                  |                                                              |            |\n| 4                                                        | [LCR 183. 望远镜中最高的海拔](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/description/)<br />[239. 滑动窗口最大值](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/description/) | https://leetcode.cn/problems/sliding-window-maximum/solutions/2361228/239-hua-dong-chuang-kou-zui-da-zhi-dan-d-u6h0 |                                                              | **HOT100** |\n|                                                          | [1438. 绝对差不超过限制的最长连续子数组](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/description/) | 类239<br />单调队列                                          | multiset                                                     |            |\n\n## 386 · 最多有k个不同字符的最长子字符串\n\n```c++\nclass Solution {\npublic:\n    /**\n     * @param s: A string\n     * @param k: An integer\n     * @return: An integer\n     */\n    int lengthOfLongestSubstringKDistinct(string &s, int k) {\n        // write your code here\n        int l=0,r=0;\n        unordered_map<char,int>umap;\n        int ans=0;\n        while(r<s.size())\n        {\n            umap[s[r]]++;\n            while(umap.size()>k)\n            {\n                umap[s[l]]--;\n                if(umap[s[l]]==0)\n                {\n                    umap.erase(s[l]);\n                }\n                l++;\n            }\n            ans=max(ans,r-l+1);\n            r++;\n        }\n        return ans;\n    }\n};\n```\n\n# 双指针\n\n| 双指针     | [283. 移动零](https://leetcode.cn/problems/move-zeroes/)     | HOT100                                                       |                                                              |\n| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n|            | [349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/) |                                                              | hash<br/>面试官会先问：两个数组求交集，怎么求？以及说一下时间复杂度（不允许使用编程语言自带的交集功能）O(M+N)。答完之后再问：如果两个数组都是非递减的，又应该怎么求？时间复杂度多少？(双指针O(M+N)) |\n|            | [14. 最长公共前缀](https://leetcode.cn/problems/longest-common-prefix/) |                                                              | 二分（O(mnlogm)） or 纵向比较（O(MN)）                       |\n|            | [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/) | **HOT100**                                                   | https://leetcode.cn/problems/container-with-most-water/solutions/94102/on-shuang-zhi-zhen-jie-fa-li-jie-zheng-que-xing-tu |\n|            | [面试题 16.06. 最小差](https://leetcode.cn/problems/smallest-difference-lcci/) |                                                              | 排序+双指针（类似11                                          |\n| 3指针      | [15. 三数之和](https://leetcode.cn/problems/3sum/)           | **HOT100**                                                   | [去重](https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#思路) |\n|            | [611. 有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/) |                                                              | [参考](https://leetcode.cn/problems/valid-triangle-number/solutions/914449/gong-shui-san-xie-yi-ti-san-jie-jian-dan-y1we) |\n|            | [16. 最接近的三数之和](https://leetcode.cn/problems/3sum-closest/) | 15改一下就行                                                 | 常数级优化：加了两个优化，但感觉写起来很怪，循环条件改成i<n-2<br/>https://leetcode.cn/problems/3sum-closest/solutions/2337801/ji-zhi-you-hua-ji-yu-san-shu-zhi-he-de-z-qgqi |\n|            | [75. 颜色分类](https://leetcode.cn/problems/sort-colors/)    | [3指针](https://leetcode.cn/problems/sort-colors/solutions/71322/kuai-su-pai-xu-partition-guo-cheng-she-ji-xun-huan) |                                                              |\n| 合并数组   | [88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/) | **HOT100**                                                   | 倒序进行填充，注意m和n表示长度要减1，表示索引。最后n可能会有剩余 |\n|            |                                                              | 进阶：合并k个有序数组<br />类似：[23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/) | https://leetcode.cn/problems/merge-k-sorted-lists/description/ |\n|            |                                                              | 去重<br />[26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/) | https://blog.csdn.net/he_wen_jie/article/details/105049024   |\n|            | [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/) |                                                              |                                                              |\n| 反转字符串 | [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)<br />[LCR 181. 字符串中的单词反转](https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/) | 直接反转，看下写法<br />百度一面，变形：保留中间所有空格（见笔记） | 快慢指针+反转整个+反转单词<br/>https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html#思路 |\n|            | [557. 反转字符串中的单词 III](https://leetcode.cn/problems/reverse-words-in-a-string-iii/) | 344升级                                                      | 异或                                                         |\n|            | [344. 反转字符串](https://leetcode.cn/problems/reverse-string/) |                                                              |                                                              |\n|            | [541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/) |                                                              | 让 i += (2 * k)，i 每次移动 2 * k 就可以了                   |\n| 反转       | [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)  | **HOT100**                                                   | 数学，官解 :要让bk/n为整数，所以lcm（n,k）=bk，要求的是n/b<br />反转 |\n| 字符串     | [165. 比较版本号](https://leetcode.cn/problems/compare-version-numbers/) |                                                              | 按点分割                                                     |\n\n# 哈希\n\n|          | [1. 两数之和](https://leetcode.cn/problems/two-sum/)         | HOT100     | [面试变形](https://blog.csdn.net/chemistryer/article/details/133067354?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22133067354%22%2C%22source%22%3A%22chemistryer%22%7D)：该数组有重复数字，需要输出所有符合要求的数字对 |\n| -------- | ------------------------------------------------------------ | ---------- | ------------------------------------------------------------ |\n|          | [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/) | HOT100     |                                                              |\n|          | [242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/) |            | 排序orhash                                                   |\n|          | [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/) | HOT100     | dp<br />[并查集2](https://leetcode.cn/problems/longest-consecutive-sequence/solutions/1176496/xiao-bai-lang-ha-xi-ji-he-ha-xi-biao-don-j5a2)<br/>并查集<br/>哈希表作为 Parent 数组，遍历数组中元素 num --映射为--> num + 1。<br/>findParent 函数中，路径压缩方法（递归查询）优化父节点查询效率。 |\n|          | [383. 赎金信](https://leetcode.cn/problems/ransom-note/)     |            |                                                              |\n| 字符串   | [205. 同构字符串](https://leetcode.cn/problems/isomorphic-strings/) |            | 官解                                                         |\n|          | [290. 单词规律](https://leetcode.cn/problems/word-pattern/)  |            |                                                              |\n| 设计     | [380. O(1) 时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/) |            | [评论](https://leetcode.cn/problems/insert-delete-getrandom-o1/solutions/1411578/o1-shi-jian-cha-ru-shan-chu-he-huo-qu-su-rlz2) |\n|          | [381. O(1) 时间插入、删除和获取随机元素 - 允许重复](https://leetcode.cn/problems/insert-delete-getrandom-o1-duplicates-allowed/) |            | https://leetcode.cn/problems/insert-delete-getrandom-o1-duplicates-allowed/solutions/45056/c-ha-xi-ti-jie-by-da-li-wang-2<br/>https://leetcode.cn/problems/insert-delete-getrandom-o1-duplicates-allowed/solutions/467892/c-unordered_multimapjie-fa-by-vclip 评论multiplemap |\n|          | [202. 快乐数](https://leetcode.cn/problems/happy-number/)    |            | 快慢指针or hash 官解                                         |\n| 原地hash | [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/) | HOT100     | [原地hash](https://leetcode.cn/problems/first-missing-positive/solutions/7703/tong-pai-xu-python-dai-ma-by-liweiwei1419) |\n|          | [287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/) | **HOT100** | 二分 or [快慢指针（类似142）](https://leetcode.cn/problems/find-the-duplicate-number/solutions/2869190/xun-zhao-zhong-fu-shu-qi-fa-shi-fang-fa-qptqj) or 原地哈希（需要修改数组） |\n|          | [442. 数组中重复的数据](https://leetcode.cn/problems/find-all-duplicates-in-an-array/) |            | hash（可解决k个） or 正负 or 原地交换（[官解](https://leetcode.cn/problems/find-all-duplicates-in-an-array/solutions/1473718/shu-zu-zhong-zhong-fu-de-shu-ju-by-leetc-782l)）<br /> |\n|          | [LCR 120. 寻找文件副本](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/) |            | 原地交换                                                     |\n|          | [448. 找到所有数组中消失的数字](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/) |            | 正负（和442类似                                              |\n|          |                                                              |            |                                                              |\n|          |                                                              |            |                                                              |\n|          |                                                              |            |                                                              |\n|          |                                                              |            |                                                              |\n|          |                                                              |            |                                                              |\n|          |                                                              |            |                                                              |\n","tags":["加密文章tag"],"categories":["Algorithm"]},{"title":"dp","url":"/2024/03/13/dp/","content":"\n\n| 爬楼梯                                                       | [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)  | **HOT100** | 滚动数组 or 矩阵快速幂                                       | 变式：<br />1.要求输出每条路径(类似39)<br />要求不能连续跳两次一格（类似股票）`dp[i][0]：走1阶到i层 dp[i][1]：走2阶到i层(上一步不是走1级) dp[i][0] = dp[i - 1][1] dp[i][1] = dp[i - 2][0] + dp[i - 2][1]` |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n|                                                              | [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/) |            | 滚动数组                                                     |                                                              |\n|                                                              | [补充题2. 圆环回原点问题](https://mp.weixin.qq.com/s/NZPaFsFrTybO3K3s7p7EVg)<br />[**NC311** **圆环回原点**](https://www.nowcoder.com/practice/16409dd00ab24a408ddd0c46e49ddcf8?tpId=196&tqId=40267&ru=/exam/oj) |            | dp                                                           | `dp[i][j]表示走i步到点编号为j的点有多少种方法·`<br />`dp[i][j] = dp[i-1][(j-1+length)%length] + dp[i-1][(j+1)%length]` |\n|                                                              | [2466. 统计构造好字符串的方案数](https://leetcode.cn/problems/count-ways-to-build-good-strings/) |            | 70套壳                                                       |                                                              |\n|                                                              | [2266. 统计打字方案数](https://leetcode.cn/problems/count-number-of-texts/) |            | 70进阶                                                       | 分割一下字符串                                               |\n| 01背包                                                       | [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/) | **HOT100** |                                                              | 变式：<br />输出子集（可dp可dfs）                            |\n|                                                              | [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/) |            |                                                              | 416进阶<br />`return sum - dp[target] - dp[target];`         |\n|                                                              | [494. 目标和](https://leetcode.cn/problems/target-sum/)      |            |                                                              | 416的 target变为<br />`target=(sum+target)/2; ``dp[0]=1;dp[j]=dp[j]+dp[j-nums[i]];`<br />[输出路径dfs](https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html#%E6%80%9D%E8%B7%AF) |\n|                                                              | [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/) |            | 01背包但是两个维度                                           |                                                              |\n|                                                              | [3180. 执行操作可获得的最大总奖励 I](https://leetcode.cn/problems/maximum-total-reward-using-operations-i/) |            | [背包](https://leetcode.cn/problems/maximum-total-reward-using-operations-i/solutions/2826341/er-wei-dp-by-silencezheng66-moxr)有点难想，[记忆化搜索](https://leetcode.cn/problems/maximum-total-reward-using-operations-i/solutions/2805711/ji-yi-hua-sou-suo-by-sleepy-herschelouf-cawx)好做（可二分优化） |                                                              |\n|                                                              | [3181. 执行操作可获得的最大总奖励 II](https://leetcode.cn/problems/maximum-total-reward-using-operations-ii/) |            | [dp+bitset](https://leetcode.cn/problems/maximum-total-reward-using-operations-ii/solutions/2805413/bitset-you-hua-0-1-bei-bao-by-endlessche-m1xn) | 3181升级只能bitset                                           |\n|                                                              | [1981. 最小化目标值与所选元素的差](https://leetcode.cn/problems/minimize-the-difference-between-target-and-chosen-elements/) |            | 背包dp or dfs                                                |                                                              |\n| 完全背包                                                     | [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii) |            | 组合（先循环物品）                                           |                                                              |\n|                                                              | [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/) |            | 排列，类似爬楼梯（先循环价值）                               | dp（注意顺序） or 记忆化                                     |\n|                                                              | [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)   | **HOT100** | 板子                                                         |                                                              |\n|                                                              | [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/) |            | 不能先遍历物品                                               |                                                              |\n|                                                              | [139. 单词拆分](https://leetcode.cn/problems/word-break/)    |            | [dfs or dp](https://programmercarl.com/0139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.html#%E6%80%9D%E8%B7%AF) |                                                              |\n|                                                              | [140. 单词拆分 II](https://leetcode.cn/problems/word-break-ii/) |            | [dp（存储结果）](https://leetcode.cn/problems/word-break-ii/solutions/2803097/cji-bai-100wu-xu-hui-su-zai-dpguo-cheng-150g9)<br />dfs+set（用umap标记需要分割的位置，其余和139差不多）<br />dfs+trie（同理） | 139进阶，需输出所有结果                                      |\n|                                                              | [91. 解码方法](https://leetcode.cn/problems/decode-ways/)    |            | [dp 空间优化](https://leetcode.cn/problems/decode-ways/solutions/730937/gong-shui-san-xie-gen-ju-shu-ju-fan-wei-ug3dd)可记忆化 |                                                              |\n|                                                              | [2522. 将字符串分割成值不超过 K 的子字符串](https://leetcode.cn/problems/partition-string-into-substrings-with-values-at-most-k/)<br />微软面经：给一个长度为n的数字组成的字符串s，它是由若干个不大于k的数组成的，给出所有的组成的数的方案(每个数不能有前导零)。比如s是\"120\"，k是20，那么可以有[1,2,0],[1,20]，[12,0]这3种方案。最终答案对1e9+7取模。c++实现，dp做法，复杂度O(NLOGK) |            | 方案输出类似140，dp方程类似2252                              |                                                              |\n| 打家劫舍                                                     | [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)  | **HOT100** | dp，输出路径（两种）                                         |                                                              |\n|                                                              | [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/) |            |                                                              | 比198加了个环形<br />[分类讨论](https://leetcode.cn/problems/house-robber-ii/solutions/2445622/jian-ji-xie-fa-zhi-jie-diao-yong-198-ti-qhvri)，考虑是否偷 nums[0]，两种情况<br /><br />`return max(nums[0] + rob1(nums, 2, n - 1), rob1(nums, 1, n));` |\n| [股票](https://leetcode.cn/circle/discuss/qiAgHn/)<br />参考2： | [ 121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock)<br />[LCR 188. 买卖芯片的最佳时机](https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/) |            | `dp[i][k] 的定义需要分成两项：`(k从0开始算)<br />`dp[i][k][0] 表示在第 i 天结束时，最多进行 k 次交易且持有股票（可能是之前买的也可能现在买的）可以获得的最大收益；`<br />`dp[i][k][1] 表示在第 i 天结束时，最多进行 k 次交易且不持有股票（可能是之前卖出也可能第i天卖出）<br/>` | 情况一：k = 1<br />`dp[i][0] = max(dp[i - 1][0], -prices[i]);`<br />` dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);` |\n|                                                              | [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii) |            |                                                              | 情况二：k 为正无穷<br />`dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]); // 注意这里是和121. 买卖股票的最佳时机唯一不同的地方。            `<br />`dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);` |\n|                                                              | [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii) |            |                                                              | 情况三：k = 2                                                |\n|                                                              | [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv) |            |                                                              | 情况四：k 为任意值<br />`for(int j=k-1;j>=0;j--){`<br />`             dp[j][1]=max(dp[j][1],dp[j][0]+prices[i]);`<br />`              dp[j][0]=max(dp[j][0],((j-1)>=0?dp[j-1][1]:0)-prices[i]);           }` |\n|                                                              | [309. 买卖股票的最佳时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/) |            |                                                              | 和122区别<br />`dp[i][0]=max(dp[i-1][0],(i-2>=0?dp[i-2][1]:0)-prices[i]);` |\n|                                                              | [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/) |            |                                                              | 和122区别<br />` dp[i][1]=max(dp[i-1][1],dp[i-1][0]+prices[i]-fee);` |\n| 子数组                                                       | [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/) |            | dp：第i个为结尾的最大值与最小值，                            | 输出数组                                                     |\n|                                                              | [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/) | **HOT100** | dp 贪心                                                      | 进阶版：[求该数组中2个不重叠的连续子数组之和的最大值](https://blog.csdn.net/grllery/article/details/89159989)。方法是从左到右和从右到左各扫描一遍，时间复杂度O(n) <br />终极版：[求该数组中k个不重叠的连续子数组之和的最大值](https://verytoolz.com/blog/91600c813a/#:~:text=%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E5%80%BC%20k%EF%BC%8C%E6%89%BE%E5%87%BA%20k%20%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%8F%A0%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%9C%89%20k%20%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%92%8C%E3%80%82%20%E4%BE%8B%E5%AD%90%EF%BC%9A%20Input,sum1%3A%208%2C%20starting%20index%3A%206%2C%20ending%20index%3A%207.)。要求时间复杂度最低，因此不可用递归，因此采用DP。时间复杂度O(nk)，网上可以找到答案，但这些答案的空间复杂度是O(nk)，面试官要求降低到O(k) |\n|                                                              | [最大连续子序列_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/afe7c043f0644f60af98a0fba61af8e7?tpId=63&tqId=29588&tPage=2&ru=/kaoyan/retest/9001&qru=/ta/zju-kaoyan/question-ranking) |            | 53输出数组                                                   |                                                              |\n| LIS详解见下                                                  | [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/?envType=featured-list&envId=2cktkvj) | **HOT100** |                                                              |                                                              |\n|                                                              | [673. 最长递增子序列的个数](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/) |            |                                                              |                                                              |\n|                                                              | [最长上升子序列(三)__牛客网 (nowcoder.com)](https://www.nowcoder.com/questionTerminal/9cf027bf54714ad889d4f30ff0ae5481?toCommentId=11635899) |            | 输出字典序最小序列                                           |                                                              |\n|                                                              | [1671. 得到山形数组的最少删除次数](https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array/) |            | 合唱队形（正着倒着LIS相加-1），注意pre[i] > 1 && suf[i] > 1  |                                                              |\n| LCS                                                          | [718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/) |            | `dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。 （特别注意： “以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ）` | [滑动窗口](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/solutions/28583/wu-li-jie-fa-by-stg-2)空间O(1) |\n|                                                              | [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)<br />[1035. 不相交的线](https://leetcode.cn/problems/uncrossed-lines/) | **HOT100** | 空间优化，输出路径(见下)                                     |                                                              |\n|                                                              | [392. 判断子序列](https://leetcode.cn/problems/is-subsequence/) |            | dp or 双指针                                                 | [拓展：判断多个字符串](https://leetcode.cn/problems/is-subsequence/solutions/1/dui-hou-xu-tiao-zhan-de-yi-xie-si-kao-ru-he-kuai-s) |\n|                                                              | [115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/) |            |                                                              | `if(s[i-1]==t[j-1])dp[i][j]=dp[i-1][j-1]+dp[i-1][j];`<br />`else dp[i][j]=dp[i-1][j];`<br />注意初始化` for (int i = 0; i <=n1; i++) dp[i][0] = 1;` |\n|                                                              | [516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/) |            | 空间优化                                                     | 或者原字符串倒过来变为1143                                   |\n|                                                              | [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)  |            | dp,空间优化                                                  |                                                              |\n|                                                              | [**NC35** **编辑距离(二)**](https://www.nowcoder.com/practice/05fed41805ae4394ab6607d0d745c8e4?tpId=196&&tqId=37134&rp=1&ru=/ta/job-code-total&qru=/ta/job-code-total/question-ranking) |            | 72升级，每种有代价                                           |                                                              |\n|                                                              | [10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/) |            | [参考](https://leetcode.cn/problems/regular-expression-matching/solutions/296114/shou-hui-tu-jie-wo-tai-nan-liao-by-hyj8)<br />[空间优化](https://leetcode.cn/problems/regular-expression-matching/solutions/1444108/by-flix-musv) |                                                              |\n|                                                              | [44. 通配符匹配](https://leetcode.cn/problems/wildcard-matching/) |            | [dp](https://leetcode.cn/problems/wildcard-matching/solutions/316020/shou-hua-tu-jie-dong-tai-gui-hua-de-si-lu-by-hyj8) | 贪心 官解                                                    |\n| 回文                                                         | [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/) |            | 空间优化，[马拉车](https://leetcode.cn/problems/longest-palindromic-substring/solutions/551460/tu-jie-ma-la-che-suan-fa-by-wang_ni_ma-if33)<br />[代码参考](https://leetcode.cn/problems/palindromic-substrings/solutions/921325/cpython3java-1dp-2zhong-xin-kuo-san-3man-llu8) |                                                              |\n|                                                              | [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/) | **HOT100** | 马拉车参考同上                                               |                                                              |\n| 括号                                                         | [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/) | **HOT100** | [栈or dp](https://leetcode.cn/problems/longest-valid-parentheses/solutions/314827/shou-hua-tu-jie-zhan-de-xiang-xi-si-lu-by-hyj8)<br />[官解 贪心](https://leetcode.cn/problems/longest-valid-parentheses/solutions/314683/zui-chang-you-xiao-gua-hao-by-leetcode-solution) | [Follow Up：返回最长长度的下标索引（栈or dp）](https://cnwangzhou.gitbook.io/algorithm/leetcode-part1/heap_stack#id-32.-zui-chang-you-xiao-kuo-hao)<br/> |\n|                                                              | [678. 有效的括号字符串](https://leetcode.cn/problems/valid-parenthesis-string/) |            | [贪心，也可dp](https://leetcode.cn/problems/valid-parenthesis-string/solutions/992601/gong-shui-san-xie-yi-ti-shuang-jie-dong-801rq) |                                                              |\n|                                                              | [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/) |            | dp or 数学（卡特兰数                                         |                                                              |\n| 网格dp                                                       | [62. 不同路径](https://leetcode.cn/problems/unique-paths/)   | **HOT100** | 排列组合 ordp空间优化                                        |                                                              |\n|                                                              | [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/) |            | dp空间优化，初始化有坑                                       |                                                              |\n|                                                              | [97. 交错字符串](https://leetcode.cn/problems/interleaving-string/) |            | [dp](https://leetcode.cn/problems/interleaving-string/solutions/1/lei-si-lu-jing-wen-ti-zhao-zhun-zhuang-tai-fang-ch)<br />[记忆化](https://leetcode.cn/problems/interleaving-string/solutions/2835645/ling-shen-dpti-dan-ji-yi-hua-di-tui-kong-u0zi)<br />空间优化（注意每次循环dp[0]） |                                                              |\n|                                                              | [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/) | **HOT100** | dp空间优化                                                   | 打印路径                                                     |\n|                                                              | [119. 杨辉三角 II](https://leetcode.cn/problems/pascals-triangle-ii) |            | dp空间优化                                                   |                                                              |\n|                                                              | [118. 杨辉三角](https://leetcode.cn/problems/pascals-triangle/) | **HOT100** |                                                              |                                                              |\n|                                                              | [221. 最大正方形](https://leetcode.cn/problems/maximal-square/) |            | dp空间优化<br />[二分+前缀和](https://leetcode.cn/problems/maximal-square/solutions/2542609/ling-shen-fen-xiang-de-er-wei-qian-zhui-03r8k) | `dp[i][j]+=min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]))+1;                 res=max(res,dp[i][j]);` |\n|                                                              | [1277. 统计全为 1 的正方形子矩阵](https://leetcode.cn/problems/count-square-submatrices-with-all-ones/) |            | dp空间优化<br />[二分+前缀和](https://leetcode.cn/problems/count-square-submatrices-with-all-ones/solutions/336506/bu-yi-yang-de-si-lu-bao-li-qian-zhui-he-er-fen-by-) | res=max改成加                                                |\n| 其他                                                         | [264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/) |            | [dp](https://leetcode.cn/problems/ugly-number-ii/solutions/110653/san-zhi-zhen-fang-fa-de-li-jie-fang-shi-by-zzxn) |                                                              |\n|                                                              | [873. 最长的斐波那契子序列的长度](https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/) |            | [序列dp](https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/solutions/1656437/by-ac_oier-beo2) |                                                              |\n\n\n\n## 树上dp\n\n### [968. 监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/)\n\n[状态分解 + dfs + 树形dp](https://leetcode.cn/problems/binary-tree-cameras/solution/zhuang-tai-fen-jie-dfs-shu-xing-dp-by-ch-yz2g/)\n\n## 不知道怎么归类\n\n#### [序列 fdu2020](https://noobdream.com/DreamJudge/Issue/page/995/#)\n\n```c++\n#include<bits/stdc++.h>\n#define debug(a) cout<<#a<<\"=\"<<a<<\" \"\n#define ll long long\nusing namespace std;\ntypedef unsigned long long ull;\nconst int N=1e5+10;\nint n;\nint dp[N][10];\nint main()\n{\n    cin>>n;\n    int tmp=0;\n    cin>>tmp;\n    memset(dp,0x3f,sizeof(dp));\n    for(int i=0;i<10;i++)dp[0][i]=abs(tmp-i);\n    for(int i=1;i<n;i++)\n    {\n        cin>>tmp;\n        for(int j=0;j<10;j++)\n        {\n            for(int k=0;k<10;k++)\n            {\n                dp[i][j]=min(dp[i][j],dp[i-1][k]+(k-j)*(k-j)+abs(j-tmp));\n            }\n            \n        }\n    }\n    int minn=INT_MAX;\n    for(int i=0;i<10;i++)\n    {\n        // debug(dp[n][i]);\n        minn=min(dp[n-1][i],minn);\n    }\n    cout<<minn<<endl;\n\treturn 0;\n}\n```\n\n\n\n## 线性DP\n\n### [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)输出路径\n\n```c++\nusing namespace std; \nint cnt = 0; \nvector<string> ans; \nvoid dfs(int n, int cur, string s) \n{ \n\tif (cur == n) \n\t{ \n\t\tcnt++; \n\t\tans.push_back(s); \n\t\treturn; \n\t} \n\tif (cur > n) return; \n\tdfs(n, cur + 1, s + to_string(cur + 1)); \n\tdfs(n, cur + 2, s + to_string(cur + 2)); \n} \nint main() \n{ \n\tint n; \n\tcin >> n; \n\tdfs(n, 0, \"0\"); \n\tcout << cnt << endl; \n\tfor (auto& s : ans) cout << s << endl; \n\treturn 0; \n}\n```\n\n### 微软面经\n\n给一个长度为n的数字组成的字符串s，它是由若干个不大于k的数组成的，给出所有的组成的数的方案(每个数不能有前导零)。比如s是\"120\"，k是20，那么可以有[1,2,0],[1,20]，[12,0]这3种方案。最终答案对1e9+7取模。c++实现，dp做法，复杂度O(NLOGK)\n\n```c++\nint minimumPartition(string s, int k) {\n    int n = s.size();\n    int f[n + 1];\n    vector<vector<string>>dp(n+1);\n    dp[0]={\"\"};\n    const int INF = 1e6;\n    for (int i = 1; i <= n; i++) f[i] = 0;\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        long long now = 0, p = 1;\n        // 枚举 j\n        for (int j = i - 1; j >= 0; j--) {\n            // 计算现在构成的数\n            string tmp=s.substr(j, i - j);\n//            debug(tmp);\n//            now += (s[j] - '0') * p;\n//            p *= 10;\n            now=stoll(tmp);\n//            debug(now);\n            if(tmp.size()>1&&s[j]=='0')continue;\n            // 现在构成的数已经不符合条件，那么以后也不会符合\n            if (now > k) break;\n            f[i] +=f[j];\n            for(string x:dp[j])\n            {\n                string newstr=(x.size()?x+\" \":\"\")+tmp;\n                dp[i].push_back(newstr);\n            }\n        }\n    }\n    for(string x:dp[n])\n    {\n        cout<<x<<endl;\n    }\n    return f[n] < INF ? f[n] : -1;\n}\n```\n\n\n\n### 整数划分\n\n#### [343. 整数拆分](https://leetcode.cn/problems/integer-break/)\n\n随想录+官解（3种\n\n#### [KY41放苹果](https://www.nowcoder.com/practice/4f0c1e21010e4d849bde5297148e81d9?tpId=61&tqId=29513&tPage=1&ru=/kaoyan/retest/1002&qru=/ta/pku-kaoyan/question-ranking)\n\n题解\n\n```c++\n// 令f（n，m）表示n个盘子盛放m个苹果，注意到拿n-1个盘子（可以有空盘子）放m个苹果和n个盘子（无空盘子）放m个苹果无重复\n// 所有有 子问题1：f(n,m)[容许有空盘子] = f(n-1,m)[容许有空盘子] + f(n,m)[无空盘子]\n// 而什么时候n个盘子放m个苹果没有空盘子呢，就是n个盘子每个至少放一个：\n// 所以有 子问题2： f(n,m)[无空盘子] = f(n,m-n) [容许有空盘子]\n// 可以得到转移方程：f(n,m)[容许有空盘子] = f(n-1,m)[容许有空盘子] +f(n,m-n) [容许有空盘子]；\n#include<bits/stdc++.h>\nusing namespace std;\nint n=0,m=0;\nlong long v=0;\nconst int N = 15, mod = 1000000000;\nint dp[N];\nint main()\n{\n\tint n;\n    \n    while(cin>>m>>n)\n    {\n        dp[0]=1;\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=i;j<=m;j++)\n            {\n                dp[j]=dp[j]+dp[j-i];\n                // cout<<dp[j]<<\" \"<<j<<endl;\n            }\n            // cout<<endl;\n        }\n        cout<<dp[m]<<endl;\n    }\n    return 0;\n}\n```\n\n\n\n### LIS\n\n#### [HOT 300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/?envType=featured-list&envId=2cktkvj)\n\n#### [最长上升子序列(三)__牛客网 (nowcoder.com)](https://www.nowcoder.com/questionTerminal/9cf027bf54714ad889d4f30ff0ae5481?toCommentId=11635899)输出字典序最小序列\n\n```c++\n#define debug(a) cout<<#a<<\"=\"<<a<<\" \"\nclass Solution {\npublic:\n    vector<int> dp;\n    int lengthOfLIS(vector<int>& a) {\n        if(a.size() < 2) return a.size();\n        // 基本点在于维护一个数组maxEnd，\n        // 其元素maxEnd[k]表示长度为k+1的递增长子序列的最后一个元素，\n        // 并且是字典序最小的那个。显然maxEnd是一个递增数组。\n        vector<int> dp(a.size(), 1);\n        vector<int> maxEnd(1, a[0]);\n        for(int i = 1; i < a.size(); i++) \n        {\n            if(a[i] > maxEnd.back()) \n            { // in inc seq\n                dp[i] = maxEnd.size()+1;\n                maxEnd.push_back(a[i]);\n            } \n            else \n            { // ai < maxEnd\n                auto pos = std::lower_bound(maxEnd.begin(), maxEnd.end(), a[i]);\n                int idx = pos - maxEnd.begin();\n                maxEnd[idx] = a[i];\n                dp[i] = idx + 1;\n            }\n        }\n        int len = maxEnd.size();\n        vector<int> vres(len);\n        for(int i = dp.size()-1; i >= 0; --i) {\n            if(dp[i] == len) {\n                vres[len-1] = a[i];\n                --len;\n            }\n        }\n        return vres.size();\n    }\n};\n```\n\n\n\n#### [673. 最长递增子序列的个数](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/)\n\n优化版\n\nhttps://leetcode.cn/problems/number-of-longest-increasing-subsequence/solutions/1008527/yanglr-leetcode-accong-lei-si-jian-dan-t-er6c/?envType=study-plan-v2&envId=dynamic-programming\n\n我们知道，leetcode 300可以使用二分搜索来寻找当前处理值的\"插入点\"。在dp[k]处, 我们这次并不像经典的LIS的解那样存储一个代表存在长度为k+1的LIS的最小值的单个数。相反, 我们使用一个dp table, 在dp[k]处, 我们存储了所有曾经是k+1个LIS的结尾的这样的值(保存了历史记录)。\n\n这些值被保存在vector<pair<int, int>> 中的first part, 我们可以用dp[i]方式取到。因此, 例如在一对x = {a, b}中, first part -> a, 表示存在一个长度为k+1的且以数a结尾的LIS。second part -> b, 表示长度为k+1的LIS以一个等于或大于a的值结尾的可能选项的数量。\n\n如果我们想知道有多少个选项可以让长度为m的LIS以y的值结尾, 我们只需在dp[m-2]中二分搜索first part中严格小于y的一对索引i。那么选项的数量就是`dp[m-2].back().second-dp[m-2][i-1].second`, 或者如果i是0的话, 就只有dp[m-2].back()。\n\n这就是基本思路, 运行时间是O(N logN), 因为我们只是对输入数组的每个元素做2次二分搜索。空间复杂度是O(N), 因为输入的每一个元素都正好存到dp数组中一次。\n\n[例子](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/solutions/2337905/zui-chang-di-zeng-zi-xu-lie-de-ge-shu-er-c3yd/?envType=study-plan-v2&envId=dynamic-programming)\n\n非最优\n\n```c++\nclass Solution {\npublic:\n    int findNumberOfLIS(vector<int>& nums) {\n        vector<int>dp(nums.size()+1,1);\n        vector<int>g(nums.size()+1,1);\n        //边界啊啊啊啊\n        int ans=1;\n        for(int i=1;i<nums.size();i++)\n        {\n            for(int j=i-1;j>=0;j--)\n            {\n                if(nums[j]<nums[i])\n                {\n                    if(dp[i]<dp[j]+1)\n                    {\n                        dp[i]=max(dp[i],dp[j]+1);\n                        g[i]=g[j];\n                    }\n                    else if(dp[i]==dp[j]+1)\n                    {\n                        g[i]+=g[j];\n                    } \n                }\n                \n                \n                // cout<<dp[i]<<\" \";\n            }\n            // cout<<dp[i]<<\" \";\n            ans=max(dp[i],ans);\n        }\n        int res=0;\n        for(int i=0;i<nums.size();i++)\n        {\n            if(dp[i]==ans)\n            {\n                res+=g[i];\n            }\n        }\n        return res;\n    }\n};\n```\n\n最优\n\n<img src=\"D:\\wyh\\大学\\信息\\QQ图片20240706202351.jpg\" alt=\"QQ图片20240706202351\" style=\"zoom:50%;\" />\n\n```c++\n#define debug(a) cout<<#a<<\"=\"<<a<<\" \"\nclass Solution {\npublic:\n// 这些值被保存在vector<pair<int, int>> 中的first part, 我们可以用dp[i]方式取到。\n// 因此, 例如在一对x = {a, b}中, first part -> a, 表示存在一个长度为k+1的且以数a结尾的LIS。\n// second part -> b, 表示长度为k+1的LIS以一个等于或大于a的值结尾的可能选项的数量。\n// 如果我们想知道有多少个选项可以让长度为m的LIS以y的值结尾, \n// 我们只需在dp[m-2]中二分搜索first part中严格小于y的一对索引i。\n// 那么选项的数量就是`dp[m-2].back().second-dp[m-2][i-1].second`, \n// 或者如果i是0的话, 就只有dp[m-2].back().second。\n    int findNumberOfLIS(vector<int>& nums) {\n        // [1,3,5,4,4,8,6,2,0,1]\n        if (nums.empty()) return 0;\n        const int N = nums.size();\n        vector<vector<pair<int, int>>> dp(N + 1);  /* dp table */\n        //dp row倒叙排列\n        int curMaxLen = 0;\n        for (int i = 0; i < N; i++)\n        {\n            // debug(nums[i]);\n            // bsearch insertion point\n            int L = -1, R = curMaxLen;\n            while (L+1 < R)\n            {\n                int mid = L + (R - L) / 2;\n                if (dp[mid].back().first < nums[i])\n                    L = mid ;\n                else R = mid;\n            }\n            // cout<<L<<\" \"<<R<<\"    \";\n            // bsearch number of options\n            int options = 1;\n            int row = L;\n            if (row >= 0)\n            {\n                int L1 = -1, R1 = dp[row].size();\n                while (L1+1 < R1)\n                {\n                    int mid = L1 + (R1 - L1) / 2;\n                    if (dp[row][mid].first < nums[i])\n                        R1 = mid;\n                    else L1 = mid ;\n                } \n                // cout<<L<<\" \"<<L1<<\" \"<<R1<<endl;\n                options = dp[row].back().second;\n                options -= (R1 == 0) ? 0 : dp[row][L1].second; \n                // options表示上一层的数量\n                // debug(L);\n                // debug(R1);\n                // debug(L1);\n                // debug( dp[row].back().second);\n            }\n            // debug(options);\n            //前缀和，nums可以生成的+之前算出的最大长度可生成的\n            dp[R].push_back({nums[i], dp[R].empty() ? options : dp[R].back().second + options});\n            if (R == curMaxLen) curMaxLen++;\n            // for(auto m:dp)\n            // {\n            //     for(auto x:m)\n            //     {\n            //         debug(x.first);\n            //         debug(x.second);\n            //     }\n            //     cout<<endl;\n            // }\n        }        \n        return dp[curMaxLen - 1].back().second;\n    }\n};\n```\n\n### [354. 俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes/)\n\n先排序\n\n#### [代码随想录41-51](https://programmercarl.com/0300.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html#算法公开课)\n\n### LCS空间优化，输出路径\n\n```c++\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int n1=text1.size(),n2=text2.size();\n        // vector<vector<int>>dp(n1+1,vector<int>(n2+1,0));\n        vector<string>dp(n2+1,\"\");\n        for(int i=1;i<=n1;i++)\n        {\n            string pre=dp[0];\n            for(int j=1;j<=n2;j++)\n            {\n                string nextPre=dp[j];//实际上是dp[i-1][j]\n                if(text1[i-1]==text2[j-1])dp[j]=pre+text1[i-1];\n                else \n                    dp[j]=dp[j].size()>dp[j-1].size()?dp[j]:dp[j-1];\n                pre=nextPre;\n            }\n        }\n        cout<<dp[n2]<<endl;\n        return dp[n2].size();\n    }\n};\n```\n\n### [**NC35** **编辑距离(二)**](https://www.nowcoder.com/practice/05fed41805ae4394ab6607d0d745c8e4?tpId=196&&tqId=37134&rp=1&ru=/ta/job-code-total&qru=/ta/job-code-total/question-ranking)\n\n## 描述\n\n给定两个字符串str1和str2，再给定三个整数ic，dc和rc，分别代表插入、删除和替换一个字符的代价，请输出将str1编辑成str2的最小代价。\n\n数据范围：0≤∣str1∣,∣str2∣≤50000≤∣*s**t**r*1∣,∣*s**t**r*2∣≤5000，0≤ic,dc,rc≤10000 0≤*ic*,*dc*,*rc*≤10000 \n\n要求：空间复杂度 O(n)*O*(*n*)，时间复杂度 O(nlogn)\n\n```c++\nclass Solution {\npublic:\n    /**\n     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可\n     *\n     * min edit cost\n     * @param str1 string字符串 the string\n     * @param str2 string字符串 the string\n     * @param ic int整型 insert cost\n     * @param dc int整型 delete cost\n     * @param rc int整型 replace cost\n     * @return int整型\n     */\n    int minEditCost(string text1, string text2, int ic, int dc, int rc) {\n        // write code here\n        int n1=text1.size(),n2=text2.size();\n        // vector<vector<int>>dp(n1+1,vector<int>(n2+1,0));\n        vector<int>dp(n2+1,0);\n        for(int j=1;j<=n2;j++)dp[j]=j*ic;\n        \n        for(int i=1;i<=n1;i++)\n        {\n            int pre=dp[0];\n            dp[0]=i*dc;           \n            // debug(dp[0]);\n            for(int j=1;j<=n2;j++)\n            {\n                int nextPre=dp[j];//实际上是dp[i-1][j]\n                if(text1[i-1]==text2[j-1])dp[j]=pre;\n                else dp[j]=min(min(dp[j]+dc,dp[j-1]+ic),pre+rc);\n                // debug(dp[j]);\n                pre=nextPre;\n            }\n            // cout<<endl;\n        }\n    \n        return dp[n2];\n    }\n};\n```\n\n\n\n#### [最长公共子串（3个）](https://noobdream.com/DreamJudge/Issue/page/1874/#)\n\n问题描述：输入3个子串， 输出这3个子串的最大公共子串\n**输入：**\nabcd acb abc\n**输出：**\nab\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF=1E9,N=1e5 + 10;\nstring dp[110][110][110];\nstring a,b,c;\nint ans=0,n=0,m=0,cnt=0;\nint main()\n{\n//\tcin>>n>>m;\n\tcin>>a>>b>>c;\n\tint n=a.size(),m=b.size(),len3=c.size();\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=m;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=len3;k++)\n\t\t\t{\n\t\t\t\tdp[i][j][0]=\"\";\n\t\t\t\tdp[i][0][k]=\"\";\n\t\t\t\tdp[0][j][k]=\"\";\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\t\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tfor(int k=1;k<=len3;k++)\n\t\t\t{\n\t\t\t\tint leni=dp[i-1][j][k].size();\n\t\t\t\tint lenj=(dp[i][j-1][k].size());\n\t\t\t\tint lenk=(dp[i][j][k-1].size());\n\t\t\t\tif(a[i-1]==b[j-1]&&a[i-1]==c[k-1])\n\t\t\t\t{\n\t\t\t\t\tint now=(dp[i][j][k].size());\n\t\t\t\t\tint past=(dp[i-1][j-1][k-1].size());\n\t\t\t\t\tif(now<=past)\n\t\t\t\t\t\tdp[i][j][k]=dp[i-1][j-1][k-1]+a[i-1];\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(leni>=lenj&&leni>=lenk)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][j][k]=dp[i-1][j][k];\n\t\t\t\t\t}\n\t\t\t\t\telse if(lenj>=leni&&lenj>=lenk)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][j][k]=dp[i][j-1][k];\n\t\t\t\t\t}\n\t\t\t\t\telse \n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][j][k]=dp[i][j][k-1];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n//\t\t\t\tcout<<i<<\",\"<<j<<\",\"<<k<<\":\"<<dp[i][j][k]<<endl;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tcout<<dp[n][m][len3]<<endl;\n\treturn 0;\n}\n```\n\n#### [求最大连续公共字串长度](https://noobdream.com/DreamJudge/Issue/page/1875/)\n\n[类似](https://programmercarl.com/0718.%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.html#算法公开课)\n\n题目描述：给定两个字符串，求最大公共字串的长度，长度小于1000\n分为两种问题：要求计算连续最长字串的长度\n如下按照寻找连续的字串理解\n**输入：**\n1111hello2222\n1133hello444\n**输出：**\n5\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF=1E9,N=1e5 + 10;\nint dp[1100][1100];\nstring a,b;\nint ans=0,n=0,m=0,cnt=0;\n\nint main()\n{\n\twhile(cin>>a>>b)\n\t{\n\t\tvector<vector<int>>dp(a.size()+1,vector<int>(b.size()+1,0));\n        int res=0;\n        for(int i=1;i<=a.size();i++)\n        {\n            for(int j=1;j<=b.size();j++)\n            {\n                if(a[i-1]==b[j-1])\n                {\n                    dp[i][j]=dp[i-1][j-1]+1;\n                }\n                if(res<dp[i][j])res=dp[i][j];\n            }\n        }\n        cout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}\n```\n\n#### [187. 导弹防御系统](https://www.acwing.com/problem/content/description/189/)\n\nhttps://www.acwing.com/solution/content/52200/\n\nhttps://www.acwing.com/activity/content/code/content/128088/\n\n### LICS\n\n#### [272. 最长公共上升子序列](https://www.acwing.com/problem/content/description/274/)\n\nhttps://www.acwing.com/solution/content/52304/\n\na[i]=b[j]替换后变为，在1-j-1找<a[i]的f【i】【k】+1的max\n\n##### （朴素版）\n\n\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\nconst int N = 3010;\n\nint n;\nint a[N], b[N];\nint f[N][N];\n\nint main()\n{\n    //input\n    cin >> n;\n    for (int i = 1; i <= n; ++ i) cin >> a[i];\n    for (int i = 1; i <= n; ++ i) cin >> b[i];\n\n    //dp\n    for (int i = 1; i <= n; ++ i)\n    {\n        for (int j = 1; j <= n; ++ j)\n        {\n            f[i][j] = f[i - 1][j];\n            if (a[i] == b[j])\n            {\n                for (int k = 0; k < j; ++ k)\n                {\n                    if (b[j] > b[k])\n                    {\n                        f[i][j] = max(f[i][j], f[i - 1][k] + 1);\n                    }\n                }\n            }\n        }\n    }\n    \n    //find result\n    int res = 0;\n    for (int i = 0; i <= n; ++ i) res = max(res, f[n][i]);\n    cout << res << endl;\n    \n    return 0;\n\n}\n```\n\n\n\n##### （优化版）\n\n\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\nconst int N = 3010;\n\nint n;\nint a[N], b[N];\nint f[N][N];\n\nint main()\n{\n    //input\n    cin >> n;\n    for (int i = 1; i <= n; ++ i) cin >> a[i];\n    for (int i = 1; i <= n; ++ i) cin >> b[i];\n\n    //dp\n    for (int i = 1; i <= n; ++ i)\n    {\n        int maxv = 1;\n        for (int j = 1; j <= n; ++ j)\n        {\n            f[i][j] = f[i - 1][j];\n            if (b[j] == a[i]) f[i][j] = max(f[i][j], maxv);\n            if (b[j] < a[i]) maxv = max(maxv, f[i - 1][j] + 1);\n        }\n    }\n    \n    //find result\n    int res = 0;\n    for (int i = 0; i <= n; ++ i) res = max(res, f[n][i]);\n    cout << res << endl;\n    \n    return 0;\n\n}\n```\n\n\n\n### 回文\n\n#### [52-53](https://programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html)\n\n#### [hot647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)\n\n#### [hot 5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)\n\n##### [图解马拉车算法](https://leetcode.cn/problems/longest-palindromic-substring/solution/tu-jie-ma-la-che-suan-fa-by-wang_ni_ma-if33/)\n\n#### [剑指 Offer II 094. 最少回文分割](https://leetcode.cn/problems/omKAoA/)\n\n#### [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)（可纯dfs）\n\n### [132. 分割回文串 II](https://leetcode.cn/problems/palindrome-partitioning-ii/)\n\n[LCR 094. 分割回文串 II](https://leetcode.cn/problems/omKAoA/)\n\n参考https://programmercarl.com/0132.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2II.html#思路\n\n其实是2个dp\n一个是记录是否是回文串\n一个是存答案，ans[i]=min(ans[i],ans[j]+1);\n\n## 杂题：分组循环\n\n[228. 汇总区间](https://leetcode.cn/problems/summary-ranges/)\n\n## 股票\n\n### [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(int k, vector<int>& prices) {\n        int n=prices.size();\n        vector<vector<int>>dp(k, vector<int>(2, 0));\n\n        // dp[i][k][0] 表示在第 i 天结束时，最多进行 k 次交易且在进行操作后持有 0 份股票的情况下可以获得的最大收益；\n        // dp[i][k][1] 表示在第 i 天结束时，最多进行 k 次交易且在进行操作后持有 1 份股票的情况下可以获得的最大收益。\n        for(int i=0;i<k;i++)dp[i][0]=-prices[0];//初始化\n        for(int i=1;i<n;i++)\n        {\n            for(int j=k-1;j>=0;j--)\n            {\n                dp[j][1]=max(dp[j][1],dp[j][0]+prices[i]);\n                dp[j][0]=max(dp[j][0],((j-1)>=0?dp[j-1][1]:0)-prices[i]);\n            }\n        }\n        return dp[k-1][1];\n    }\n};\n```\n\n","tags":["加密文章tag"],"categories":["Algorithm"]},{"title":"E-Commerce Promotions Personalization via Online Multiple-Choice Knapsack with Uplift Modeling","url":"/2023/10/29/E-Commerce-Promotions-Personalization-via-Online-Multiple-Choice-Knapsack-with-Uplift-Modeling/","content":"\n\n# 问题背景\n\n促销在电子商务平台的营销工作中起着关键作用。他们通过为客户提供更多的价值，从而显著提升了销售额。向客户提供优惠(如图1所示)会产生完成预订的动机，并推动业务增长。在增加购买可能性的同时，如果促销活动时的销售净收入小于不提供促销活动时的净收入，促销活动也可能招致增量货币损失。通常，会制定专门的预算来弥补这一增加的净收入损失，以确保可持续的竞选活动。\n\n预算约束营销最近越来越受欢迎，尤其是在促销分配方面。许多解决方案考虑一个恒定的成本因素[18]。然而，在存在因果增量估计的情况下，晋升的货币影响可能导致不同的、积极的或消极的结果。现有的解决方案主要依赖于基于意图的模型，不能适应因果模型的负值，因此不适用于此类问题。\n\n本文利用提升模型(uplift modeling)的因果估计，形式化了预算约束下的多选择晋升分配问题。我们提出了一种新的在线选择背包设置中负值和权重的解决方案。我们在最大的在线旅游平台之一Booking.com上展示了该方法的部署，并在现实生活的实验研究中对其进行了各种基准测试。\n\n我们的主要贡献有:\n\n1. 将预算约束下的促销个性化问题表述为具有因果估计的在线mckp。\n2. 基于因果隆起模型估计和多项选择背包优化的两步求解方法。\n3. Online-MCKP解的新颖扩展，以适应负值和权值。\n4. 在Booking.com平台进行大规模的真实促销活动实验研究。\n\n# 解决方法\n\n## 符号定义\n\n𝑌𝑖 - a binary random variable representing a completion of a purchase \n\n​\t\t 一个二进制随机变量，表示购买完成\n\n𝑅𝑖 - a continuous random variable representing the net monetary revenue associated with the purchase (sum of all revenues minus all promotional costs)\n\n​\t 表示与购买相关的净货币收入的连续随机变量（所有收入的总和减去所有促销成本）\n\n𝑌𝑖 (𝑘): potential purchase 对于客户𝑖 和促销𝑘如果客户𝑖 获得促销𝑘\n\n𝑅𝑖 (𝑘): potential net revenue表示如果客户𝑖 获得促销𝑘.\n\nk=0, no promotion\n$$\nCATE_{𝑌} (𝑖, 𝑘) = E(𝑌_{𝑖} (𝑘) − 𝑌_{𝑖} (0) | 𝑋 = 𝑥𝑖 )\n$$\n\n表示如果促销k，则对客户i的预期购买概率的增量影响\n\n$$\nCATE_{𝑅} (𝑖, 𝑘) = E(𝑅_{𝑖}(𝑘) − 𝑅_{𝑖}(0) | 𝑋 = 𝑥𝑖 )\n$$\n\n***ppt66-68***\n\n![](image-20231029223156512.png)\n\nCATEL (𝑖, 𝑘) = −CATE𝑅 (𝑖, 𝑘)\n\n𝑣𝑖𝑘 is CATE𝑌 (𝑖, 𝑘)and 𝑤𝑖𝑘 is CATEL (𝑖, 𝑘)\n\n*MCKP：给你N组物品，然后每一组你至多选择一个物品,每个物品都有自己的体积和价值，现在给你一个容里为M的背包，让你用这个背包装物品，使得物品价值总和最大*\n\n*这里一个人是一组，K1,K2....*\n\n*每个人可能收到的优惠券k∈Ki,k=0表示这个用户没有优惠*\n\n![image-20231029224008191](image-20231029224008191.png)\n\n![屏幕截图 2023-10-29 224151](CATE.png)\n\n## 解决方案框架\n\n![zaiwen.top2023_10_29 23_01_58](solution.png)\n\n先调了公共的UpliftML package，Optimization部分\n\n### Dominant items\n\n删除Dominant和 LP-Dominant，和The Multiple-Choice Knapsack Problem这篇一样\n\n![image-20231029230943979](image-20231029230943979.png)\n\n### Incremental value and weight\n![image-20231029231056168.png](image-20231029231056168.png)\n\n感觉和mckp那篇也差不多\n\n此外，the incremental efficiency 𝑣𝑖𝑑/𝑤𝑖𝑑 is monotonically decreasing with 𝑑，除了d=0到d=1，可能w和v是负的，看图3。\n\n### Efficiency angle\n![image-20231029231331394.png](image-20231029231331394.png)\n\n\n### Efficiency angle threshold\n\n1: Input:\n\n• Set of past dominant items 𝑃\n\n• Knapsack capacity 𝐶\n\n• Current customer index 𝑖\n\n• Expected number of customers |𝑈 |\n\n2: Sort 𝑃 by decreasing angle 𝜃𝑝\n\n3: for 𝑝 ∈ 𝑃 do:\n\n4:\t if p=0: \n$$\n𝑓 ((𝜃_{0})  ) = w_{0}/|𝑃 |\n$$\n\n5: \telse:\n$$\n𝑓 ((𝜃_{p})  ) = 𝑓 (𝜃_{p} −1 ) + 𝑤_{p} /|𝑃 |\n$$\n\n6: end for\n\n7: \tReturn efficiency threshold 𝜃^{*}:\n$$\n𝜃^{ * } ← 𝑚𝑖𝑛_{𝑝∈𝑃} ({ 𝜃_{p} | 𝑓 (𝜃_{p} ) ≤ 𝐶/(|𝑃 |/𝑖 · (|𝑈 |−𝑖+1) )})\n$$\n// *TODO：这个就不知道咋想出来的，问问去*\n\n总的：O (|𝐾𝑖 | · 𝑙𝑜𝑔|𝐾𝑖 |)，𝜃更新具有O(|𝑈 |) 复杂性\n![](image-20231029231722341.png)\n\n## 系统架构\n\n比较了好几种optimization，global，local， Greedy，下面几个\n\n1. **Online MCKP (On-MCKP)**:\n   - **情境描述**：该方法对应于真实世界中的情景，其中顾客逐一到达，每次决策都必须在特定时间步骤中做出，即每到一个新顾客就需要做出促销活动的决策。\n   - **信息限制**：在开始时，没有有关一般权重和价值分布的信息。\n   - **决策过程**：方法会根据剩余预算和更新的效率角度函数（Algorithm 2描述）来调整促销活动的分配决策。\n2. **Offline MCKP (Off-MCKP)**:\n   - **情境描述**：与Online MCKP相比，这种方法不同的是提前知道所有物品，即所有的顾客和可能的促销活动。\n   - **信息利用**：因为提前知道所有物品，可以在分配决策之前仅适应一次效率角度函数（Algorithm 1描述）。\n   - **决策过程**：在知道所有顾客和促销活动之后，算法会决定为每个顾客提供哪种促销活动，而不需要更新效率角度函数。\n\n在这两种方法中，主要的区别在于信息利用和决策时机。Online MCKP需要在每个时间步骤中动态地做出决策，而Offline MCKP可以提前知道所有信息，然后在不需要动态更新的情况下做出决策。\n\n1. Integer Linear Programming (ILP)\n   - **解决方法**：ILP求解器用于在离线设置中寻找最优的上界解决方案。\n   - **线性规划**：MCKP问题可以被表示为一个线性规划，并且采用了论文中所描述的线性方程（Equation 1）来解决。\n   - **预算常数**：预算常数 C被设置为零（C=0）。\n   - **工具和求解器**：研究使用了 Python PuLP 软件包和 CBC（Coinor branch and cut）求解器。整体求解器运行时间被限制在3小时内。\n   - **性能说明**：尽管对于背包问题有更合适的求解器，研究中仅遇到了一个实例，即在有限的运行时间内无法达到最优解。不过，它达到了一个可行解，且具有微小的最优性差距。\n\nILP方法利用了数学规划中的整数线性规划来解决MCKP问题。在离线设置下，ILP被用来找到一个最优的上界解决方案，其依赖于线性规划的建模，并使用了特定的求解器和工具来解决问题。\n\n![](822e2156683c75b826d7c3ffb9807f32_6_Figure_6_433477608.png)\n\n# 结论\n\n这部分感觉看原文，比较了这几个方法比ILP垃圾多少（不是），然后是看online-mckp自己的一个性质：bound，然后three flat-discount levels 看ROI，最后是一个净利润和阈值的浮动（？\n\n","tags":["paper"],"categories":["research"]},{"title":"Uplift Summary","url":"/2023/10/26/Uplift-Summary/","content":"## 概率\n\n[条件期望与全期望公式 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/417592820)有错的\n\n[01 条件期望与条件方差 - 简书 (jianshu.com)](https://www.jianshu.com/p/e4c0a6db8a86)\n\n## A Survey on Causal Inference\n\n[因果推断综述解析|A Survey on Causal Inference(6) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/366740766)\n\n[基于潜在结果框架的因果推断入门 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/372399985)\n\n## 原理\n\n[阿里文娱](https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&mid=2247498630&idx=1&sn=b36515e54c2dbc20186942102497c390&chksm=fbd749eacca0c0fc9e285ffc7d06e336115f387394362a4707c71377f02832f8c42bcc71cc7a&mpshare=1&scene=24&srcid=&sharer_sharetime=1585109170232&sharer_shareid=255a68ecb152bdfa3b164d51ce560a8d&poc_token=HLRiK2WjKpUaQQw3Imx3TuOo3a4sQ025dN4gYppc)\n\n[*因果推断学习笔记二*](https://blog.csdn.net/TSzero/article/details/118410142)\n\n[智能营销增益模型（Uplift Modeling）的原理与实践](https://blog.csdn.net/jinping_shi/article/details/105583375)\n\n[整理](https://zhuanlan.zhihu.com/p/442881104)\n\n[模型和Package](https://zhuanlan.zhihu.com/p/349733349)\n\n[具体模型解释](https://www.mdnice.com/writing/1fb9fb09ceb64001b324b465b01c977f)\n\n[pylift实例](https://zhuanlan.zhihu.com/p/442882553)\n\n[资料收集](https://dango.rocks/blog/2018/11/04/Causality0-Collection-of-Study-Materials/)\n\n[因果推断案例集锦](https://zhuanlan.zhihu.com/p/410055461?utm_id=0)\n\n[概述](https://baijiahao.baidu.com/s?id=1753445414392961455)\n\n## uplift模型评估\n\n[Anticoder：因果推断--uplift model 评估](https://zhuanlan.zhihu.com/p/343747851)\n\n[uplift模型评估指标及分析](https://zhuanlan.zhihu.com/p/493811028)\n\n## **Uplift特征选择**\n\n- [Deep IV](http://proceedings.mlr.press/v70/hartford17a/hartford17a.pdf)\n- [CausalML特征选择工具](https://github.com/uber/causalml/tree/master/causalml/feature_selection)\n\n## **因果推断常用开源库**\n\n- [EconML](https://econml.azurewebsites.net/)\n- [CausalML](https://github.com/uber/causalml)\n  - [video+introduction](https://medium.com/grabngoinfo/s-learner-uplift-model-for-individual-treatment-effect-and-customer-segmentation-in-python-9d410746e122)\n  - [解释](https://www.modb.pro/db/601027)\n  - [tutorial](https://causal-machine-learning.github.io/kdd2021-tutorial/\n  )\n- [Dowhy](https://github.com/microsoft/dowhy)\n- [Pylift](https://github.com/wayfair/pylift)\n  - [图解释](https://www.modb.pro/db/601026)\n  - [官方](https://pylift.readthedocs.io/en/latest/usage.html)\n\n## Uplift实战\n\n[转行数据分析--6. 如何评价项目收益 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/164723534)\n\n[两个模型做差分模型、一个模型的标签转化模型](https://github.com/PGuti/Uplift.git)\n\n[两个模型做差分模型、一个模型(加入干预类特征)](https://nbviewer.jupyter.org/github/maks-sh/scikit-uplift/blob/master/notebooks/RetailHero_EN.ipynb#1.1-Single-model-with-treatment-as-feature)\n\n[Propensity Score Matching (Lalonde's Dataset)](https://www.dango.rocks/blog/2018/11/15/Causality1-Playaround-with-the-Lalonde-Dataset/)\n## 论文笔记\n[LBCF: A Large-Scale Budget-Constrained Causal Forest Algorithm](https://blog.csdn.net/zyl_wjl_1413/article/details/125407379)\n[LBCF: A Large-Scale Budget-Constrained Causal Forest Algorithm概述](https://mp.weixin.qq.com/s/VHKSiQO1u_nJbSDo49jiVg)\n\n[因果森林总结：基于树模型的异质因果效应估计](https://zhuanlan.zhihu.com/p/448524822)\n","tags":["paper"],"categories":["research"]},{"title":"亚麻（Amazon）实习经历记录","url":"/2023/10/26/亚麻（Amazon）实习经历记录/","content":"实习过半，后面要写后端了，防止以后要找工忘了这段实习干啥了，先记一点。\n\n# VAMOS Mapping Service迁移到AWS CDK v2\n\nhttps://docs.aws.amazon.com/zh_cn/cdk/v2/guide/migrating-v2.html\n\n其他都是内部文档，好多报错文档也没有，只能sage狂搜，搜不到的就看报错改。\n\n且内部项目还有依赖，还得先升级依赖的项目\n\n# VAMOS Data Catalog项目开发\n\n## 流程\n\n#### Requirement Iteration and Solution Pre-study：\n\nRequirement Clarification，Solution Pre-study \n\n#### Design and Plan ：\n\nDesign: LLD，Task Breakdown and Estimation，Setup review meeting for Task breakdown and Estimation，Milestone and Launch Plan \n\n#### Code Complete：\n\nSet up weblab，security-verify，FE package & pipeline set up，Add navigation bar ，Add data catalog header，Implement of SearchKeyword dropdown，Implement of Pagination and PageSize dropdown，Implement of DataGrid，Update pagination based on the keyword search，Adjust Css，Extend from beta to Gamma and Prod\n\n#### Ready for UAT：\n\nFE dashboard\n\n#### Ready for Lanuch：\n\nCypress test，UAT enhancement\n\n# VAMOS Assignment\n[实习总结参考](https://mp.weixin.qq.com/s/hVX4JTZJgPpmfuKI6cdByg)\n\n","tags":["加密文章tag"],"categories":["Internship"]},{"title":"日期模拟","url":"/2023/09/20/date/","content":"\n## [合集](https://www.acwing.com/blog/content/24163/)\n\n## [3498. 日期差值](https://www.acwing.com/problem/content/3501/)\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstring a,b;\nint mon[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\nint isleap(int y)\n{\n\tif((y%4==0&&y%100!=0)||(y%400==0))\n\t{\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nll getday(string a)\n{\n\tint y=atoi((a.substr(0,4)).c_str());\n\tint m=atoi((a.substr(4,2)).c_str());\n\tint d=atoi((a.substr(6,2)).c_str());\n\tll day=d;\n//\tcout<<y<<\" \"<<m<<\" \"<<d<<endl;\n\tif(isleap(y))\n\t{\n\t\tmon[2]=29;\n\t}\n\telse\n\t{\n\t\tmon[2]=28;\n\t}\n\tfor(int i=1;i<m;i++)\n\t{\n\t\tday=day+(ll)(mon[i]);\n\t}\n\tfor(int i=1;i<y;i++)\n\t{\n\t\tif(isleap(i))\n\t\t{\n\t\t\tday=day+366;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tday=day+365;\n\t\t}\n\t}\n//\tcout<<day<<endl;\n\treturn day;\n}\nint main()\n{\n\twhile(cin>>a>>b)\n\t{\n\t\tll daya=getday(a);\n\t\tll dayb=getday(b);\n\t\tcout<<abs(daya-dayb)+1<<endl;\n\t}\n\treturn 0;\n } \n```\n\n## [3489. 星期几](https://www.acwing.com/problem/content/description/3492/)\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstring m;\nint y,d;\nstring month[12]={\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"};\nstring week[7]={\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\"};\nmap<string,int> mp={\n       {\"January\",1},\n       {\"February\",2},\n       {\"March\",3},\n       {\"April\",4},\n       {\"May\",5},\n       {\"June\",6},\n       {\"July\",7},\n       {\"August\",8},\n       {\"September\",9},\n       {\"October\",10},\n       {\"November\",11},\n       {\"December\",12}\n    };\nint mon[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\nint isleap(int y)\n{\n\tif((y%4==0&&y%100!=0)||(y%400==0))\n\t{\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nstring getday(int y,int m,int d)\n{\n\t\n\tll day=d;\n//\tcout<<y<<\" \"<<m<<\" \"<<d<<endl;\n\tif(isleap(y))\n\t{\n\t\tmon[2]=29;\n\t}\n\telse\n\t{\n\t\tmon[2]=28;\n\t}\n\tfor(int i=1;i<m;i++)\n\t{\n\t\tday=day+(ll)(mon[i]);\n\t}\n\tfor(int i=1;i<y;i++)\n\t{\n\t\tif(isleap(i))\n\t\t{\n\t\t\tday=day+366;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tday=day+365;\n\t\t}\n\t}\n\tday=(day-1)%7;\n//\tcout<<day<<endl;\n\treturn week[day];\n}\nint main()\n{\n\twhile(cin>>d>>m>>y)\n\t{\n\t\tcout<<getday(y,mp[m],d)<<endl;;\n\t}\n\treturn 0;\n } \n```\n\n## [3573.日期累加](https://www.acwing.com/problem/content/description/3576/)\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint m,n,s;\nint y,d;\nstring month[12]={\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"};\nstring week[7]={\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\"};\nmap<string,int> mp={\n       {\"January\",1},\n       {\"February\",2},\n       {\"March\",3},\n       {\"April\",4},\n       {\"May\",5},\n       {\"June\",6},\n       {\"July\",7},\n       {\"August\",8},\n       {\"September\",9},\n       {\"October\",10},\n       {\"November\",11},\n       {\"December\",12}\n    };\nint mon[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\nint isleap(int y)\n{\n\tif((y%4==0&&y%100!=0)||(y%400==0))\n\t{\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nvoid getday(int y,int m,int d,int s)\n{\n\t\n//\tcout<<y<<\" \"<<m<<\" \"<<d<<endl;\n\td+=s;\n\tif(isleap(y))\n\t\t{\n\t\t\tmon[2]=29;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmon[2]=28;\n\t\t}\t\n\twhile(d>mon[m])\n\t{\n\t\td-=mon[m];\n\t\tif(isleap(y))\n\t\t{\n\t\t\tmon[2]=29;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmon[2]=28;\n\t\t}\n\t\tm++;\n\t\tif(m>12)\n\t\t{\n\t\t\tm=1;\n\t\t\ty++;\n\t\t}\n\t}\n\tcout<<y<<\"-\";\n\tif(m<10)cout<<0;\n\tcout<<m<<\"-\";\n\tif(d<10)cout<<0;\n\tcout<<d<<endl;\n\t\n}\nint main()\n{\n\tcin>>n;\n\twhile(n--)\n\t{\n\t\tcin>>y>>m>>d>>s;\n\t\tgetday(y,m,d,s);\n\t}\n\treturn 0;\n } \n```\n\n## [1341. 十三号星期五](https://www.acwing.com/problem/content/description/1343/)\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstring m;\nint y,d,n;\nstring month[12]={\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"};\nstring week[7]={\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\"};\nint a[8];\nint mon[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\nint isleap(int y)\n{\n\tif((y%4==0&&y%100!=0)||(y%400==0))\n\t{\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nvoid getday(int n)\n{\n\tint cnt=0;\n\tfor(int i=1900;i<=1900+n-1;i++)\n\t{\n\t\tif(isleap(i))\n\t\t{\n\t\t\tmon[2]=29;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmon[2]=28;\n\t\t}\n\t\tfor(int j=1;j<=12;j++)\n\t\t{\n\t\t\tfor(int d=1;d<=mon[j];d++)\n\t\t\t{\n\t\t\t\tcnt=(cnt+1)%7;\n\t\t\t\tif(d==13)\n\t\t\t\t{\n\t\t\t\t\ta[cnt]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a[6]<<\" \"<<a[0]<<\" \";\n\tfor(int i=1;i<=5;i++)\n\t{\n\t\tcout<<a[i]<<\" \";\n\t}\n\tcout<<endl;\n}\nint main()\n{\n\twhile(cin>>n)\n\t{\n\t\tgetday(n);\n\t}\n\treturn 0;\n } \n```\n\n## [466. 回文日期](https://www.acwing.com/problem/content/description/468/)\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstring a,b;\nint ans;\nint mon[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\nint isleap(int y)\n{\n\tif((y%4==0&&y%100!=0)||(y%400==0))\n\t{\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint ok(int y,int m,int d)\n{\n\tif(y/1000!=d%10)return 0;\n\tif(y/100%10!=d/10)return 0;\n\tif(y/10%10!=m%10)return 0;\n\tif(y%10!=m/10)return 0;\n\treturn 1;\n}\nvoid getday(string a,string b)\n{\n\tint y=stoi((a.substr(0,4)));\n\tint m=stoi((a.substr(4,2)));\n\tint d=stoi((a.substr(6,2)));\n\tint yb=stoi((b.substr(0,4)));\n\tint mb=stoi((b.substr(4,2)));\n\tint db=stoi((b.substr(6,2)));\n//\tll day=d;\n//\tcout<<y<<\" \"<<m<<\" \"<<d<<endl;\n\tif(isleap(y))\n\t{\n\t\tmon[2]=29;\n\t}\n\telse\n\t{\n\t\tmon[2]=28;\n\t}\n\twhile(1)\n\t{\n\t\tif(ok(y,m,d))ans++;\n\t\tif(y==yb&&m==mb&&d==db)break;\n\t\td++;\n\t\tif(isleap(y))\n\t\t{\n\t\t\tmon[2]=29;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmon[2]=28;\n\t\t}\n\t\tif(d>mon[m])\n\t\t{\n\t\t\tm++;\n\t\t\td=1;\n\t\t}\n\t\tif(m>12)\n\t\t{\n\t\t\ty++;\n\t\t\tm=1;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\nint main()\n{\n\twhile(cin>>a>>b)\n\t{\n\t\tif(a>b)swap(a,b);\n//\t\tcout<<a<<\" \"<<b<<endl;\n\t\tgetday(a,b);\n\t}\n\treturn 0;\n } \n```","tags":["c++"]},{"title":"Hello World","url":"/2023/09/19/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\nhexo clean\nhexo g\nhexo d\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n```bash\ngit status 查看修改文件\ngit add <fileName> 加入修改文件\ngit commit -m 'xxxx'  新填一条commit\ngit log 查看所有commit\ngit rebase -i HEAD / git rebase -i HEAD~2 合并前2条commit\n合并的时候选择squash即可\n然后删掉第二条commit的内容\ncr\ni\n编辑\n```\ngithub 镜像：https://bgithub.xyz\n```bash\npip install -i https://pypi.tuna.tsinghua.edu.cn/simple ortools\npip install -i https://pypi.tuna.tsinghua.edu.cn/simple numpy\n\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r/\n\npip install torch==1.4.0+cu100 -f https://download.pytorch.org/whl/torch_stable.html\n```\nsftp 同步\n参考：https://zhuanlan.zhihu.com/p/592665950\n```json\n{\n    \"name\": \"My Server\",\n    \"host\": \"10.224.128.25\",\n    \"protocol\": \"sftp\",\n    \"port\": 22,\n    \"username\": \"buzhidaoshei\",\n    \"remotePath\": \"/home/buzhidaoshei/repo/autoamenu\",\n    \"uploadOnSave\": true,\n    \"useTempFile\": false,\n    \"openSsh\": false\n}\n```"}]